
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model LoginHistory
 * 
 */
export type LoginHistory = $Result.DefaultSelection<Prisma.$LoginHistoryPayload>
/**
 * Model TwoFactor
 * 
 */
export type TwoFactor = $Result.DefaultSelection<Prisma.$TwoFactorPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model UserAcademyCEO
 * 
 */
export type UserAcademyCEO = $Result.DefaultSelection<Prisma.$UserAcademyCEOPayload>
/**
 * Model Academy
 * 
 */
export type Academy = $Result.DefaultSelection<Prisma.$AcademyPayload>
/**
 * Model Instructor
 * 
 */
export type Instructor = $Result.DefaultSelection<Prisma.$InstructorPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Path
 * 
 */
export type Path = $Result.DefaultSelection<Prisma.$PathPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model Option
 * 
 */
export type Option = $Result.DefaultSelection<Prisma.$OptionPayload>
/**
 * Model Submission
 * 
 */
export type Submission = $Result.DefaultSelection<Prisma.$SubmissionPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Group
 * 
 */
export type Group = $Result.DefaultSelection<Prisma.$GroupPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Channel
 * 
 */
export type Channel = $Result.DefaultSelection<Prisma.$ChannelPayload>
/**
 * Model Owner
 * 
 */
export type Owner = $Result.DefaultSelection<Prisma.$OwnerPayload>
/**
 * Model Bookmark
 * 
 */
export type Bookmark = $Result.DefaultSelection<Prisma.$BookmarkPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model Community
 * 
 */
export type Community = $Result.DefaultSelection<Prisma.$CommunityPayload>
/**
 * Model Discussion
 * 
 */
export type Discussion = $Result.DefaultSelection<Prisma.$DiscussionPayload>
/**
 * Model LiveRoom
 * 
 */
export type LiveRoom = $Result.DefaultSelection<Prisma.$LiveRoomPayload>
/**
 * Model AccountingEntry
 * 
 */
export type AccountingEntry = $Result.DefaultSelection<Prisma.$AccountingEntryPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model SalaryPayment
 * 
 */
export type SalaryPayment = $Result.DefaultSelection<Prisma.$SalaryPaymentPayload>
/**
 * Model PublicRelationsRecord
 * 
 */
export type PublicRelationsRecord = $Result.DefaultSelection<Prisma.$PublicRelationsRecordPayload>
/**
 * Model PRResponse
 * 
 */
export type PRResponse = $Result.DefaultSelection<Prisma.$PRResponsePayload>
/**
 * Model Meeting
 * 
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>
/**
 * Model MeetingParticipant
 * 
 */
export type MeetingParticipant = $Result.DefaultSelection<Prisma.$MeetingParticipantPayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model AdminRole
 * 
 */
export type AdminRole = $Result.DefaultSelection<Prisma.$AdminRolePayload>
/**
 * Model AdminAssignment
 * 
 */
export type AdminAssignment = $Result.DefaultSelection<Prisma.$AdminAssignmentPayload>
/**
 * Model LegalCase
 * 
 */
export type LegalCase = $Result.DefaultSelection<Prisma.$LegalCasePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const LoginDevice: {
  DESKTOP: 'DESKTOP',
  MOBILE: 'MOBILE',
  TABLET: 'TABLET',
  LAPTOP: 'LAPTOP'
};

export type LoginDevice = (typeof LoginDevice)[keyof typeof LoginDevice]


export const UserRole: {
  STUDENT: 'STUDENT',
  INSTRUCTOR: 'INSTRUCTOR',
  PARENT: 'PARENT',
  ADMIN: 'ADMIN',
  ACADEMY: 'ACADEMY'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const CourseStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED'
};

export type CourseStatus = (typeof CourseStatus)[keyof typeof CourseStatus]


export const MilestoneStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  NOT_STARTED: 'NOT_STARTED'
};

export type MilestoneStatus = (typeof MilestoneStatus)[keyof typeof MilestoneStatus]


export const LessonStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  NOT_STARTED: 'NOT_STARTED'
};

export type LessonStatus = (typeof LessonStatus)[keyof typeof LessonStatus]


export const FileType: {
  VIDEO: 'VIDEO',
  PDF: 'PDF',
  DOCUMENT: 'DOCUMENT',
  IMAGE: 'IMAGE',
  AUDIO: 'AUDIO'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const NotificationType: {
  ASSIGNMENT: 'ASSIGNMENT',
  GRADE: 'GRADE',
  MESSAGE: 'MESSAGE',
  ACHIEVEMENT: 'ACHIEVEMENT',
  URGENT: 'URGENT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const AccountingType: {
  EXPENSE: 'EXPENSE',
  INCOME: 'INCOME',
  SALARY: 'SALARY',
  ADVANCE: 'ADVANCE',
  INVOICE: 'INVOICE'
};

export type AccountingType = (typeof AccountingType)[keyof typeof AccountingType]


export const InvoiceStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const PRRequestStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type PRRequestStatus = (typeof PRRequestStatus)[keyof typeof PRRequestStatus]


export const AdminRoleType: {
  DIRECTOR: 'DIRECTOR',
  ACCOUNTANT: 'ACCOUNTANT',
  SECRETARY: 'SECRETARY',
  LEGAL_ADVISOR: 'LEGAL_ADVISOR',
  HR_MANAGER: 'HR_MANAGER',
  IT_MANAGER: 'IT_MANAGER',
  GENERAL_MANAGER: 'GENERAL_MANAGER',
  ADMIN: 'ADMIN',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type AdminRoleType = (typeof AdminRoleType)[keyof typeof AdminRoleType]


export const LegalCaseType: {
  CONTRACT: 'CONTRACT',
  DISPUTE: 'DISPUTE',
  INSURANCE: 'INSURANCE',
  EMPLOYMENT: 'EMPLOYMENT',
  INTELLECTUAL_PROPERTY: 'INTELLECTUAL_PROPERTY'
};

export type LegalCaseType = (typeof LegalCaseType)[keyof typeof LegalCaseType]


export const LegalCaseStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  CLOSED: 'CLOSED',
  PENDING: 'PENDING'
};

export type LegalCaseStatus = (typeof LegalCaseStatus)[keyof typeof LegalCaseStatus]

}

export type LoginDevice = $Enums.LoginDevice

export const LoginDevice: typeof $Enums.LoginDevice

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type CourseStatus = $Enums.CourseStatus

export const CourseStatus: typeof $Enums.CourseStatus

export type MilestoneStatus = $Enums.MilestoneStatus

export const MilestoneStatus: typeof $Enums.MilestoneStatus

export type LessonStatus = $Enums.LessonStatus

export const LessonStatus: typeof $Enums.LessonStatus

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type AccountingType = $Enums.AccountingType

export const AccountingType: typeof $Enums.AccountingType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type PRRequestStatus = $Enums.PRRequestStatus

export const PRRequestStatus: typeof $Enums.PRRequestStatus

export type AdminRoleType = $Enums.AdminRoleType

export const AdminRoleType: typeof $Enums.AdminRoleType

export type LegalCaseType = $Enums.LegalCaseType

export const LegalCaseType: typeof $Enums.LegalCaseType

export type LegalCaseStatus = $Enums.LegalCaseStatus

export const LegalCaseStatus: typeof $Enums.LegalCaseStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.loginHistory`: Exposes CRUD operations for the **LoginHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoginHistories
    * const loginHistories = await prisma.loginHistory.findMany()
    * ```
    */
  get loginHistory(): Prisma.LoginHistoryDelegate<ExtArgs>;

  /**
   * `prisma.twoFactor`: Exposes CRUD operations for the **TwoFactor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwoFactors
    * const twoFactors = await prisma.twoFactor.findMany()
    * ```
    */
  get twoFactor(): Prisma.TwoFactorDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.userAcademyCEO`: Exposes CRUD operations for the **UserAcademyCEO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAcademyCEOS
    * const userAcademyCEOS = await prisma.userAcademyCEO.findMany()
    * ```
    */
  get userAcademyCEO(): Prisma.UserAcademyCEODelegate<ExtArgs>;

  /**
   * `prisma.academy`: Exposes CRUD operations for the **Academy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Academies
    * const academies = await prisma.academy.findMany()
    * ```
    */
  get academy(): Prisma.AcademyDelegate<ExtArgs>;

  /**
   * `prisma.instructor`: Exposes CRUD operations for the **Instructor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instructors
    * const instructors = await prisma.instructor.findMany()
    * ```
    */
  get instructor(): Prisma.InstructorDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.path`: Exposes CRUD operations for the **Path** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paths
    * const paths = await prisma.path.findMany()
    * ```
    */
  get path(): Prisma.PathDelegate<ExtArgs>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs>;

  /**
   * `prisma.option`: Exposes CRUD operations for the **Option** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Options
    * const options = await prisma.option.findMany()
    * ```
    */
  get option(): Prisma.OptionDelegate<ExtArgs>;

  /**
   * `prisma.submission`: Exposes CRUD operations for the **Submission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submissions
    * const submissions = await prisma.submission.findMany()
    * ```
    */
  get submission(): Prisma.SubmissionDelegate<ExtArgs>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.notificationSettings`: Exposes CRUD operations for the **NotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSettings.findMany()
    * ```
    */
  get notificationSettings(): Prisma.NotificationSettingsDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **Group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.GroupDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<ExtArgs>;

  /**
   * `prisma.owner`: Exposes CRUD operations for the **Owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owners
    * const owners = await prisma.owner.findMany()
    * ```
    */
  get owner(): Prisma.OwnerDelegate<ExtArgs>;

  /**
   * `prisma.bookmark`: Exposes CRUD operations for the **Bookmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookmarks
    * const bookmarks = await prisma.bookmark.findMany()
    * ```
    */
  get bookmark(): Prisma.BookmarkDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs>;

  /**
   * `prisma.community`: Exposes CRUD operations for the **Community** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communities
    * const communities = await prisma.community.findMany()
    * ```
    */
  get community(): Prisma.CommunityDelegate<ExtArgs>;

  /**
   * `prisma.discussion`: Exposes CRUD operations for the **Discussion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discussions
    * const discussions = await prisma.discussion.findMany()
    * ```
    */
  get discussion(): Prisma.DiscussionDelegate<ExtArgs>;

  /**
   * `prisma.liveRoom`: Exposes CRUD operations for the **LiveRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LiveRooms
    * const liveRooms = await prisma.liveRoom.findMany()
    * ```
    */
  get liveRoom(): Prisma.LiveRoomDelegate<ExtArgs>;

  /**
   * `prisma.accountingEntry`: Exposes CRUD operations for the **AccountingEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountingEntries
    * const accountingEntries = await prisma.accountingEntry.findMany()
    * ```
    */
  get accountingEntry(): Prisma.AccountingEntryDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.salaryPayment`: Exposes CRUD operations for the **SalaryPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryPayments
    * const salaryPayments = await prisma.salaryPayment.findMany()
    * ```
    */
  get salaryPayment(): Prisma.SalaryPaymentDelegate<ExtArgs>;

  /**
   * `prisma.publicRelationsRecord`: Exposes CRUD operations for the **PublicRelationsRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PublicRelationsRecords
    * const publicRelationsRecords = await prisma.publicRelationsRecord.findMany()
    * ```
    */
  get publicRelationsRecord(): Prisma.PublicRelationsRecordDelegate<ExtArgs>;

  /**
   * `prisma.pRResponse`: Exposes CRUD operations for the **PRResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PRResponses
    * const pRResponses = await prisma.pRResponse.findMany()
    * ```
    */
  get pRResponse(): Prisma.PRResponseDelegate<ExtArgs>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.MeetingDelegate<ExtArgs>;

  /**
   * `prisma.meetingParticipant`: Exposes CRUD operations for the **MeetingParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeetingParticipants
    * const meetingParticipants = await prisma.meetingParticipant.findMany()
    * ```
    */
  get meetingParticipant(): Prisma.MeetingParticipantDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.adminRole`: Exposes CRUD operations for the **AdminRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminRoles
    * const adminRoles = await prisma.adminRole.findMany()
    * ```
    */
  get adminRole(): Prisma.AdminRoleDelegate<ExtArgs>;

  /**
   * `prisma.adminAssignment`: Exposes CRUD operations for the **AdminAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAssignments
    * const adminAssignments = await prisma.adminAssignment.findMany()
    * ```
    */
  get adminAssignment(): Prisma.AdminAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.legalCase`: Exposes CRUD operations for the **LegalCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LegalCases
    * const legalCases = await prisma.legalCase.findMany()
    * ```
    */
  get legalCase(): Prisma.LegalCaseDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.1.0
   * Query Engine version: 11f085a2012c0f4778414c8db2651556ee0ef959
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    LoginHistory: 'LoginHistory',
    TwoFactor: 'TwoFactor',
    Profile: 'Profile',
    UserAcademyCEO: 'UserAcademyCEO',
    Academy: 'Academy',
    Instructor: 'Instructor',
    Course: 'Course',
    Path: 'Path',
    Milestone: 'Milestone',
    Lesson: 'Lesson',
    File: 'File',
    Enrollment: 'Enrollment',
    Quiz: 'Quiz',
    Question: 'Question',
    Option: 'Option',
    Submission: 'Submission',
    Achievement: 'Achievement',
    Notification: 'Notification',
    NotificationSettings: 'NotificationSettings',
    Message: 'Message',
    Post: 'Post',
    Comment: 'Comment',
    Group: 'Group',
    Admin: 'Admin',
    Channel: 'Channel',
    Owner: 'Owner',
    Bookmark: 'Bookmark',
    Event: 'Event',
    Attendance: 'Attendance',
    Payment: 'Payment',
    Report: 'Report',
    Badge: 'Badge',
    Certificate: 'Certificate',
    Community: 'Community',
    Discussion: 'Discussion',
    LiveRoom: 'LiveRoom',
    AccountingEntry: 'AccountingEntry',
    Invoice: 'Invoice',
    SalaryPayment: 'SalaryPayment',
    PublicRelationsRecord: 'PublicRelationsRecord',
    PRResponse: 'PRResponse',
    Meeting: 'Meeting',
    MeetingParticipant: 'MeetingParticipant',
    Permission: 'Permission',
    AdminRole: 'AdminRole',
    AdminAssignment: 'AdminAssignment',
    LegalCase: 'LegalCase'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "loginHistory" | "twoFactor" | "profile" | "userAcademyCEO" | "academy" | "instructor" | "course" | "path" | "milestone" | "lesson" | "file" | "enrollment" | "quiz" | "question" | "option" | "submission" | "achievement" | "notification" | "notificationSettings" | "message" | "post" | "comment" | "group" | "admin" | "channel" | "owner" | "bookmark" | "event" | "attendance" | "payment" | "report" | "badge" | "certificate" | "community" | "discussion" | "liveRoom" | "accountingEntry" | "invoice" | "salaryPayment" | "publicRelationsRecord" | "pRResponse" | "meeting" | "meetingParticipant" | "permission" | "adminRole" | "adminAssignment" | "legalCase"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      LoginHistory: {
        payload: Prisma.$LoginHistoryPayload<ExtArgs>
        fields: Prisma.LoginHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          findFirst: {
            args: Prisma.LoginHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          findMany: {
            args: Prisma.LoginHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>[]
          }
          create: {
            args: Prisma.LoginHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          createMany: {
            args: Prisma.LoginHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoginHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>[]
          }
          delete: {
            args: Prisma.LoginHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          update: {
            args: Prisma.LoginHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          deleteMany: {
            args: Prisma.LoginHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoginHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginHistoryPayload>
          }
          aggregate: {
            args: Prisma.LoginHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoginHistory>
          }
          groupBy: {
            args: Prisma.LoginHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<LoginHistoryCountAggregateOutputType> | number
          }
        }
      }
      TwoFactor: {
        payload: Prisma.$TwoFactorPayload<ExtArgs>
        fields: Prisma.TwoFactorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwoFactorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwoFactorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          findFirst: {
            args: Prisma.TwoFactorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwoFactorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          findMany: {
            args: Prisma.TwoFactorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>[]
          }
          create: {
            args: Prisma.TwoFactorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          createMany: {
            args: Prisma.TwoFactorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwoFactorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>[]
          }
          delete: {
            args: Prisma.TwoFactorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          update: {
            args: Prisma.TwoFactorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          deleteMany: {
            args: Prisma.TwoFactorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwoFactorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TwoFactorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwoFactorPayload>
          }
          aggregate: {
            args: Prisma.TwoFactorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwoFactor>
          }
          groupBy: {
            args: Prisma.TwoFactorGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwoFactorCountArgs<ExtArgs>
            result: $Utils.Optional<TwoFactorCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      UserAcademyCEO: {
        payload: Prisma.$UserAcademyCEOPayload<ExtArgs>
        fields: Prisma.UserAcademyCEOFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAcademyCEOFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademyCEOPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAcademyCEOFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademyCEOPayload>
          }
          findFirst: {
            args: Prisma.UserAcademyCEOFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademyCEOPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAcademyCEOFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademyCEOPayload>
          }
          findMany: {
            args: Prisma.UserAcademyCEOFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademyCEOPayload>[]
          }
          create: {
            args: Prisma.UserAcademyCEOCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademyCEOPayload>
          }
          createMany: {
            args: Prisma.UserAcademyCEOCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAcademyCEOCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademyCEOPayload>[]
          }
          delete: {
            args: Prisma.UserAcademyCEODeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademyCEOPayload>
          }
          update: {
            args: Prisma.UserAcademyCEOUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademyCEOPayload>
          }
          deleteMany: {
            args: Prisma.UserAcademyCEODeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAcademyCEOUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAcademyCEOUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAcademyCEOPayload>
          }
          aggregate: {
            args: Prisma.UserAcademyCEOAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAcademyCEO>
          }
          groupBy: {
            args: Prisma.UserAcademyCEOGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAcademyCEOGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAcademyCEOCountArgs<ExtArgs>
            result: $Utils.Optional<UserAcademyCEOCountAggregateOutputType> | number
          }
        }
      }
      Academy: {
        payload: Prisma.$AcademyPayload<ExtArgs>
        fields: Prisma.AcademyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademyPayload>
          }
          findFirst: {
            args: Prisma.AcademyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademyPayload>
          }
          findMany: {
            args: Prisma.AcademyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademyPayload>[]
          }
          create: {
            args: Prisma.AcademyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademyPayload>
          }
          createMany: {
            args: Prisma.AcademyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademyPayload>[]
          }
          delete: {
            args: Prisma.AcademyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademyPayload>
          }
          update: {
            args: Prisma.AcademyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademyPayload>
          }
          deleteMany: {
            args: Prisma.AcademyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademyPayload>
          }
          aggregate: {
            args: Prisma.AcademyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademy>
          }
          groupBy: {
            args: Prisma.AcademyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademyCountArgs<ExtArgs>
            result: $Utils.Optional<AcademyCountAggregateOutputType> | number
          }
        }
      }
      Instructor: {
        payload: Prisma.$InstructorPayload<ExtArgs>
        fields: Prisma.InstructorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstructorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstructorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          findFirst: {
            args: Prisma.InstructorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstructorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          findMany: {
            args: Prisma.InstructorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>[]
          }
          create: {
            args: Prisma.InstructorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          createMany: {
            args: Prisma.InstructorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstructorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>[]
          }
          delete: {
            args: Prisma.InstructorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          update: {
            args: Prisma.InstructorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          deleteMany: {
            args: Prisma.InstructorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstructorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstructorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          aggregate: {
            args: Prisma.InstructorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstructor>
          }
          groupBy: {
            args: Prisma.InstructorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstructorGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstructorCountArgs<ExtArgs>
            result: $Utils.Optional<InstructorCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Path: {
        payload: Prisma.$PathPayload<ExtArgs>
        fields: Prisma.PathFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PathFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PathFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathPayload>
          }
          findFirst: {
            args: Prisma.PathFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PathFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathPayload>
          }
          findMany: {
            args: Prisma.PathFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathPayload>[]
          }
          create: {
            args: Prisma.PathCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathPayload>
          }
          createMany: {
            args: Prisma.PathCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PathCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathPayload>[]
          }
          delete: {
            args: Prisma.PathDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathPayload>
          }
          update: {
            args: Prisma.PathUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathPayload>
          }
          deleteMany: {
            args: Prisma.PathDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PathUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PathUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PathPayload>
          }
          aggregate: {
            args: Prisma.PathAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePath>
          }
          groupBy: {
            args: Prisma.PathGroupByArgs<ExtArgs>
            result: $Utils.Optional<PathGroupByOutputType>[]
          }
          count: {
            args: Prisma.PathCountArgs<ExtArgs>
            result: $Utils.Optional<PathCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      Option: {
        payload: Prisma.$OptionPayload<ExtArgs>
        fields: Prisma.OptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          findFirst: {
            args: Prisma.OptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          findMany: {
            args: Prisma.OptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          create: {
            args: Prisma.OptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          createMany: {
            args: Prisma.OptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>[]
          }
          delete: {
            args: Prisma.OptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          update: {
            args: Prisma.OptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          deleteMany: {
            args: Prisma.OptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OptionPayload>
          }
          aggregate: {
            args: Prisma.OptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOption>
          }
          groupBy: {
            args: Prisma.OptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptionCountArgs<ExtArgs>
            result: $Utils.Optional<OptionCountAggregateOutputType> | number
          }
        }
      }
      Submission: {
        payload: Prisma.$SubmissionPayload<ExtArgs>
        fields: Prisma.SubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          findFirst: {
            args: Prisma.SubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          findMany: {
            args: Prisma.SubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[]
          }
          create: {
            args: Prisma.SubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          createMany: {
            args: Prisma.SubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[]
          }
          delete: {
            args: Prisma.SubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          update: {
            args: Prisma.SubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          deleteMany: {
            args: Prisma.SubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          aggregate: {
            args: Prisma.SubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubmission>
          }
          groupBy: {
            args: Prisma.SubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<SubmissionCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationSettings: {
        payload: Prisma.$NotificationSettingsPayload<ExtArgs>
        fields: Prisma.NotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          update: {
            args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSettings>
          }
          groupBy: {
            args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Group: {
        payload: Prisma.$GroupPayload<ExtArgs>
        fields: Prisma.GroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findFirst: {
            args: Prisma.GroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          findMany: {
            args: Prisma.GroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          create: {
            args: Prisma.GroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          createMany: {
            args: Prisma.GroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>[]
          }
          delete: {
            args: Prisma.GroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          update: {
            args: Prisma.GroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          deleteMany: {
            args: Prisma.GroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.GroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupCountArgs<ExtArgs>
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Channel: {
        payload: Prisma.$ChannelPayload<ExtArgs>
        fields: Prisma.ChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findFirst: {
            args: Prisma.ChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          findMany: {
            args: Prisma.ChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          create: {
            args: Prisma.ChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          createMany: {
            args: Prisma.ChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>[]
          }
          delete: {
            args: Prisma.ChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          update: {
            args: Prisma.ChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelPayload>
          }
          aggregate: {
            args: Prisma.ChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannel>
          }
          groupBy: {
            args: Prisma.ChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCountAggregateOutputType> | number
          }
        }
      }
      Owner: {
        payload: Prisma.$OwnerPayload<ExtArgs>
        fields: Prisma.OwnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findFirst: {
            args: Prisma.OwnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          findMany: {
            args: Prisma.OwnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          create: {
            args: Prisma.OwnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          createMany: {
            args: Prisma.OwnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>[]
          }
          delete: {
            args: Prisma.OwnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          update: {
            args: Prisma.OwnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          deleteMany: {
            args: Prisma.OwnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OwnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnerPayload>
          }
          aggregate: {
            args: Prisma.OwnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwner>
          }
          groupBy: {
            args: Prisma.OwnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnerCountArgs<ExtArgs>
            result: $Utils.Optional<OwnerCountAggregateOutputType> | number
          }
        }
      }
      Bookmark: {
        payload: Prisma.$BookmarkPayload<ExtArgs>
        fields: Prisma.BookmarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookmarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookmarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          findFirst: {
            args: Prisma.BookmarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookmarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          findMany: {
            args: Prisma.BookmarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          create: {
            args: Prisma.BookmarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          createMany: {
            args: Prisma.BookmarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookmarkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          delete: {
            args: Prisma.BookmarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          update: {
            args: Prisma.BookmarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          deleteMany: {
            args: Prisma.BookmarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookmarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookmarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          aggregate: {
            args: Prisma.BookmarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookmark>
          }
          groupBy: {
            args: Prisma.BookmarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookmarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookmarkCountArgs<ExtArgs>
            result: $Utils.Optional<BookmarkCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      Community: {
        payload: Prisma.$CommunityPayload<ExtArgs>
        fields: Prisma.CommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findFirst: {
            args: Prisma.CommunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findMany: {
            args: Prisma.CommunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          create: {
            args: Prisma.CommunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          createMany: {
            args: Prisma.CommunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          delete: {
            args: Prisma.CommunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          update: {
            args: Prisma.CommunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          deleteMany: {
            args: Prisma.CommunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          aggregate: {
            args: Prisma.CommunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunity>
          }
          groupBy: {
            args: Prisma.CommunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityCountAggregateOutputType> | number
          }
        }
      }
      Discussion: {
        payload: Prisma.$DiscussionPayload<ExtArgs>
        fields: Prisma.DiscussionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscussionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscussionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionPayload>
          }
          findFirst: {
            args: Prisma.DiscussionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscussionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionPayload>
          }
          findMany: {
            args: Prisma.DiscussionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionPayload>[]
          }
          create: {
            args: Prisma.DiscussionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionPayload>
          }
          createMany: {
            args: Prisma.DiscussionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscussionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionPayload>[]
          }
          delete: {
            args: Prisma.DiscussionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionPayload>
          }
          update: {
            args: Prisma.DiscussionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionPayload>
          }
          deleteMany: {
            args: Prisma.DiscussionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscussionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiscussionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscussionPayload>
          }
          aggregate: {
            args: Prisma.DiscussionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscussion>
          }
          groupBy: {
            args: Prisma.DiscussionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscussionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscussionCountArgs<ExtArgs>
            result: $Utils.Optional<DiscussionCountAggregateOutputType> | number
          }
        }
      }
      LiveRoom: {
        payload: Prisma.$LiveRoomPayload<ExtArgs>
        fields: Prisma.LiveRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiveRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiveRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveRoomPayload>
          }
          findFirst: {
            args: Prisma.LiveRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiveRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveRoomPayload>
          }
          findMany: {
            args: Prisma.LiveRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveRoomPayload>[]
          }
          create: {
            args: Prisma.LiveRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveRoomPayload>
          }
          createMany: {
            args: Prisma.LiveRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LiveRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveRoomPayload>[]
          }
          delete: {
            args: Prisma.LiveRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveRoomPayload>
          }
          update: {
            args: Prisma.LiveRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveRoomPayload>
          }
          deleteMany: {
            args: Prisma.LiveRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiveRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LiveRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiveRoomPayload>
          }
          aggregate: {
            args: Prisma.LiveRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiveRoom>
          }
          groupBy: {
            args: Prisma.LiveRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiveRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.LiveRoomCountArgs<ExtArgs>
            result: $Utils.Optional<LiveRoomCountAggregateOutputType> | number
          }
        }
      }
      AccountingEntry: {
        payload: Prisma.$AccountingEntryPayload<ExtArgs>
        fields: Prisma.AccountingEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountingEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountingEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          findFirst: {
            args: Prisma.AccountingEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountingEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          findMany: {
            args: Prisma.AccountingEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>[]
          }
          create: {
            args: Prisma.AccountingEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          createMany: {
            args: Prisma.AccountingEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountingEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>[]
          }
          delete: {
            args: Prisma.AccountingEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          update: {
            args: Prisma.AccountingEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          deleteMany: {
            args: Prisma.AccountingEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountingEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountingEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
          }
          aggregate: {
            args: Prisma.AccountingEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountingEntry>
          }
          groupBy: {
            args: Prisma.AccountingEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountingEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountingEntryCountArgs<ExtArgs>
            result: $Utils.Optional<AccountingEntryCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      SalaryPayment: {
        payload: Prisma.$SalaryPaymentPayload<ExtArgs>
        fields: Prisma.SalaryPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          findFirst: {
            args: Prisma.SalaryPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          findMany: {
            args: Prisma.SalaryPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>[]
          }
          create: {
            args: Prisma.SalaryPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          createMany: {
            args: Prisma.SalaryPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>[]
          }
          delete: {
            args: Prisma.SalaryPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          update: {
            args: Prisma.SalaryPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          deleteMany: {
            args: Prisma.SalaryPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalaryPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPaymentPayload>
          }
          aggregate: {
            args: Prisma.SalaryPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryPayment>
          }
          groupBy: {
            args: Prisma.SalaryPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryPaymentCountAggregateOutputType> | number
          }
        }
      }
      PublicRelationsRecord: {
        payload: Prisma.$PublicRelationsRecordPayload<ExtArgs>
        fields: Prisma.PublicRelationsRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicRelationsRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicRelationsRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicRelationsRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicRelationsRecordPayload>
          }
          findFirst: {
            args: Prisma.PublicRelationsRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicRelationsRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicRelationsRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicRelationsRecordPayload>
          }
          findMany: {
            args: Prisma.PublicRelationsRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicRelationsRecordPayload>[]
          }
          create: {
            args: Prisma.PublicRelationsRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicRelationsRecordPayload>
          }
          createMany: {
            args: Prisma.PublicRelationsRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublicRelationsRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicRelationsRecordPayload>[]
          }
          delete: {
            args: Prisma.PublicRelationsRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicRelationsRecordPayload>
          }
          update: {
            args: Prisma.PublicRelationsRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicRelationsRecordPayload>
          }
          deleteMany: {
            args: Prisma.PublicRelationsRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicRelationsRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PublicRelationsRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicRelationsRecordPayload>
          }
          aggregate: {
            args: Prisma.PublicRelationsRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublicRelationsRecord>
          }
          groupBy: {
            args: Prisma.PublicRelationsRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicRelationsRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicRelationsRecordCountArgs<ExtArgs>
            result: $Utils.Optional<PublicRelationsRecordCountAggregateOutputType> | number
          }
        }
      }
      PRResponse: {
        payload: Prisma.$PRResponsePayload<ExtArgs>
        fields: Prisma.PRResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PRResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PRResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRResponsePayload>
          }
          findFirst: {
            args: Prisma.PRResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PRResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRResponsePayload>
          }
          findMany: {
            args: Prisma.PRResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRResponsePayload>[]
          }
          create: {
            args: Prisma.PRResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRResponsePayload>
          }
          createMany: {
            args: Prisma.PRResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PRResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRResponsePayload>[]
          }
          delete: {
            args: Prisma.PRResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRResponsePayload>
          }
          update: {
            args: Prisma.PRResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRResponsePayload>
          }
          deleteMany: {
            args: Prisma.PRResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PRResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PRResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PRResponsePayload>
          }
          aggregate: {
            args: Prisma.PRResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePRResponse>
          }
          groupBy: {
            args: Prisma.PRResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PRResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PRResponseCountArgs<ExtArgs>
            result: $Utils.Optional<PRResponseCountAggregateOutputType> | number
          }
        }
      }
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>
        fields: Prisma.MeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      MeetingParticipant: {
        payload: Prisma.$MeetingParticipantPayload<ExtArgs>
        fields: Prisma.MeetingParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingParticipantPayload>
          }
          findFirst: {
            args: Prisma.MeetingParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingParticipantPayload>
          }
          findMany: {
            args: Prisma.MeetingParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingParticipantPayload>[]
          }
          create: {
            args: Prisma.MeetingParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingParticipantPayload>
          }
          createMany: {
            args: Prisma.MeetingParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingParticipantPayload>[]
          }
          delete: {
            args: Prisma.MeetingParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingParticipantPayload>
          }
          update: {
            args: Prisma.MeetingParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingParticipantPayload>
          }
          deleteMany: {
            args: Prisma.MeetingParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeetingParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingParticipantPayload>
          }
          aggregate: {
            args: Prisma.MeetingParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeetingParticipant>
          }
          groupBy: {
            args: Prisma.MeetingParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingParticipantCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      AdminRole: {
        payload: Prisma.$AdminRolePayload<ExtArgs>
        fields: Prisma.AdminRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          findFirst: {
            args: Prisma.AdminRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          findMany: {
            args: Prisma.AdminRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>[]
          }
          create: {
            args: Prisma.AdminRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          createMany: {
            args: Prisma.AdminRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>[]
          }
          delete: {
            args: Prisma.AdminRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          update: {
            args: Prisma.AdminRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          deleteMany: {
            args: Prisma.AdminRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminRolePayload>
          }
          aggregate: {
            args: Prisma.AdminRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminRole>
          }
          groupBy: {
            args: Prisma.AdminRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminRoleCountArgs<ExtArgs>
            result: $Utils.Optional<AdminRoleCountAggregateOutputType> | number
          }
        }
      }
      AdminAssignment: {
        payload: Prisma.$AdminAssignmentPayload<ExtArgs>
        fields: Prisma.AdminAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAssignmentPayload>
          }
          findFirst: {
            args: Prisma.AdminAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAssignmentPayload>
          }
          findMany: {
            args: Prisma.AdminAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAssignmentPayload>[]
          }
          create: {
            args: Prisma.AdminAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAssignmentPayload>
          }
          createMany: {
            args: Prisma.AdminAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAssignmentPayload>[]
          }
          delete: {
            args: Prisma.AdminAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAssignmentPayload>
          }
          update: {
            args: Prisma.AdminAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AdminAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAssignmentPayload>
          }
          aggregate: {
            args: Prisma.AdminAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAssignment>
          }
          groupBy: {
            args: Prisma.AdminAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAssignmentCountAggregateOutputType> | number
          }
        }
      }
      LegalCase: {
        payload: Prisma.$LegalCasePayload<ExtArgs>
        fields: Prisma.LegalCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LegalCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LegalCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalCasePayload>
          }
          findFirst: {
            args: Prisma.LegalCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LegalCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalCasePayload>
          }
          findMany: {
            args: Prisma.LegalCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalCasePayload>[]
          }
          create: {
            args: Prisma.LegalCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalCasePayload>
          }
          createMany: {
            args: Prisma.LegalCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LegalCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalCasePayload>[]
          }
          delete: {
            args: Prisma.LegalCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalCasePayload>
          }
          update: {
            args: Prisma.LegalCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalCasePayload>
          }
          deleteMany: {
            args: Prisma.LegalCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LegalCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LegalCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegalCasePayload>
          }
          aggregate: {
            args: Prisma.LegalCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLegalCase>
          }
          groupBy: {
            args: Prisma.LegalCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LegalCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LegalCaseCountArgs<ExtArgs>
            result: $Utils.Optional<LegalCaseCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    enrollments: number
    achievements: number
    notifications: number
    messages: number
    posts: number
    groups: number
    channels: number
    bookmarks: number
    Submission: number
    Attendance: number
    Instructor: number
    Owner: number
    Admin: number
    Lesson: number
    Payment: number
    Report: number
    Badge: number
    Certificate: number
    Community: number
    LiveRoom: number
    NotificationSettings: number
    Path: number
    LoginHistory: number
    TwoFactor: number
    UserAcademyCEO: number
    SalaryPayment: number
    MeetingParticipant: number
    LegalCase: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | UserCountOutputTypeCountEnrollmentsArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    groups?: boolean | UserCountOutputTypeCountGroupsArgs
    channels?: boolean | UserCountOutputTypeCountChannelsArgs
    bookmarks?: boolean | UserCountOutputTypeCountBookmarksArgs
    Submission?: boolean | UserCountOutputTypeCountSubmissionArgs
    Attendance?: boolean | UserCountOutputTypeCountAttendanceArgs
    Instructor?: boolean | UserCountOutputTypeCountInstructorArgs
    Owner?: boolean | UserCountOutputTypeCountOwnerArgs
    Admin?: boolean | UserCountOutputTypeCountAdminArgs
    Lesson?: boolean | UserCountOutputTypeCountLessonArgs
    Payment?: boolean | UserCountOutputTypeCountPaymentArgs
    Report?: boolean | UserCountOutputTypeCountReportArgs
    Badge?: boolean | UserCountOutputTypeCountBadgeArgs
    Certificate?: boolean | UserCountOutputTypeCountCertificateArgs
    Community?: boolean | UserCountOutputTypeCountCommunityArgs
    LiveRoom?: boolean | UserCountOutputTypeCountLiveRoomArgs
    NotificationSettings?: boolean | UserCountOutputTypeCountNotificationSettingsArgs
    Path?: boolean | UserCountOutputTypeCountPathArgs
    LoginHistory?: boolean | UserCountOutputTypeCountLoginHistoryArgs
    TwoFactor?: boolean | UserCountOutputTypeCountTwoFactorArgs
    UserAcademyCEO?: boolean | UserCountOutputTypeCountUserAcademyCEOArgs
    SalaryPayment?: boolean | UserCountOutputTypeCountSalaryPaymentArgs
    MeetingParticipant?: boolean | UserCountOutputTypeCountMeetingParticipantArgs
    LegalCase?: boolean | UserCountOutputTypeCountLegalCaseArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInstructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLiveRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiveRoomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLoginHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTwoFactorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserAcademyCEOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAcademyCEOWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalaryPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMeetingParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLegalCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LegalCaseWhereInput
  }


  /**
   * Count Type AcademyCountOutputType
   */

  export type AcademyCountOutputType = {
    users: number
    ceos: number
    courses: number
    instructors: number
    events: number
    AccountingEntry: number
    PublicRelationsRecord: number
    Meeting: number
    LegalCase: number
  }

  export type AcademyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AcademyCountOutputTypeCountUsersArgs
    ceos?: boolean | AcademyCountOutputTypeCountCeosArgs
    courses?: boolean | AcademyCountOutputTypeCountCoursesArgs
    instructors?: boolean | AcademyCountOutputTypeCountInstructorsArgs
    events?: boolean | AcademyCountOutputTypeCountEventsArgs
    AccountingEntry?: boolean | AcademyCountOutputTypeCountAccountingEntryArgs
    PublicRelationsRecord?: boolean | AcademyCountOutputTypeCountPublicRelationsRecordArgs
    Meeting?: boolean | AcademyCountOutputTypeCountMeetingArgs
    LegalCase?: boolean | AcademyCountOutputTypeCountLegalCaseArgs
  }

  // Custom InputTypes
  /**
   * AcademyCountOutputType without action
   */
  export type AcademyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademyCountOutputType
     */
    select?: AcademyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademyCountOutputType without action
   */
  export type AcademyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * AcademyCountOutputType without action
   */
  export type AcademyCountOutputTypeCountCeosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAcademyCEOWhereInput
  }

  /**
   * AcademyCountOutputType without action
   */
  export type AcademyCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * AcademyCountOutputType without action
   */
  export type AcademyCountOutputTypeCountInstructorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorWhereInput
  }

  /**
   * AcademyCountOutputType without action
   */
  export type AcademyCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * AcademyCountOutputType without action
   */
  export type AcademyCountOutputTypeCountAccountingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountingEntryWhereInput
  }

  /**
   * AcademyCountOutputType without action
   */
  export type AcademyCountOutputTypeCountPublicRelationsRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicRelationsRecordWhereInput
  }

  /**
   * AcademyCountOutputType without action
   */
  export type AcademyCountOutputTypeCountMeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * AcademyCountOutputType without action
   */
  export type AcademyCountOutputTypeCountLegalCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LegalCaseWhereInput
  }


  /**
   * Count Type InstructorCountOutputType
   */

  export type InstructorCountOutputType = {
    courses: number
  }

  export type InstructorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | InstructorCountOutputTypeCountCoursesArgs
  }

  // Custom InputTypes
  /**
   * InstructorCountOutputType without action
   */
  export type InstructorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorCountOutputType
     */
    select?: InstructorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstructorCountOutputType without action
   */
  export type InstructorCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    lessons: number
    enrollments: number
    quizzes: number
    instructors: number
    liveRoom: number
    Path: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | CourseCountOutputTypeCountLessonsArgs
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
    quizzes?: boolean | CourseCountOutputTypeCountQuizzesArgs
    instructors?: boolean | CourseCountOutputTypeCountInstructorsArgs
    liveRoom?: boolean | CourseCountOutputTypeCountLiveRoomArgs
    Path?: boolean | CourseCountOutputTypeCountPathArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountInstructorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLiveRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiveRoomWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountPathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathWhereInput
  }


  /**
   * Count Type PathCountOutputType
   */

  export type PathCountOutputType = {
    milestones: number
    courses: number
    peers: number
  }

  export type PathCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestones?: boolean | PathCountOutputTypeCountMilestonesArgs
    courses?: boolean | PathCountOutputTypeCountCoursesArgs
    peers?: boolean | PathCountOutputTypeCountPeersArgs
  }

  // Custom InputTypes
  /**
   * PathCountOutputType without action
   */
  export type PathCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PathCountOutputType
     */
    select?: PathCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PathCountOutputType without action
   */
  export type PathCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }

  /**
   * PathCountOutputType without action
   */
  export type PathCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * PathCountOutputType without action
   */
  export type PathCountOutputTypeCountPeersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    files: number
    quizzes: number
    completedBy: number
    Attendance: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | LessonCountOutputTypeCountFilesArgs
    quizzes?: boolean | LessonCountOutputTypeCountQuizzesArgs
    completedBy?: boolean | LessonCountOutputTypeCountCompletedByArgs
    Attendance?: boolean | LessonCountOutputTypeCountAttendanceArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountCompletedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    questions: number
    submissions: number
    Course: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuizCountOutputTypeCountQuestionsArgs
    submissions?: boolean | QuizCountOutputTypeCountSubmissionsArgs
    Course?: boolean | QuizCountOutputTypeCountCourseArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    options: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | QuestionCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    Channel: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Channel?: boolean | MessageCountOutputTypeCountChannelArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
    Group: number
    Community: number
    Discussion: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    Group?: boolean | PostCountOutputTypeCountGroupArgs
    Community?: boolean | PostCountOutputTypeCountCommunityArgs
    Discussion?: boolean | PostCountOutputTypeCountDiscussionArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountDiscussionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscussionWhereInput
  }


  /**
   * Count Type GroupCountOutputType
   */

  export type GroupCountOutputType = {
    members: number
    posts: number
    Community: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | GroupCountOutputTypeCountMembersArgs
    posts?: boolean | GroupCountOutputTypeCountPostsArgs
    Community?: boolean | GroupCountOutputTypeCountCommunityArgs
  }

  // Custom InputTypes
  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountCommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    Group: number
    accountingEntries: number
    prRecords: number
    prResponses: number
    meetings: number
    assignments: number
    legalCases: number
    AdminRole: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Group?: boolean | AdminCountOutputTypeCountGroupArgs
    accountingEntries?: boolean | AdminCountOutputTypeCountAccountingEntriesArgs
    prRecords?: boolean | AdminCountOutputTypeCountPrRecordsArgs
    prResponses?: boolean | AdminCountOutputTypeCountPrResponsesArgs
    meetings?: boolean | AdminCountOutputTypeCountMeetingsArgs
    assignments?: boolean | AdminCountOutputTypeCountAssignmentsArgs
    legalCases?: boolean | AdminCountOutputTypeCountLegalCasesArgs
    AdminRole?: boolean | AdminCountOutputTypeCountAdminRoleArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAccountingEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountingEntryWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountPrRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicRelationsRecordWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountPrResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRResponseWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAssignmentWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountLegalCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LegalCaseWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountAdminRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRoleWhereInput
  }


  /**
   * Count Type ChannelCountOutputType
   */

  export type ChannelCountOutputType = {
    members: number
    messages: number
  }

  export type ChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ChannelCountOutputTypeCountMembersArgs
    messages?: boolean | ChannelCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCountOutputType
     */
    select?: ChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ChannelCountOutputType without action
   */
  export type ChannelCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type OwnerCountOutputType
   */

  export type OwnerCountOutputType = {
    Channel: number
  }

  export type OwnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Channel?: boolean | OwnerCountOutputTypeCountChannelArgs
  }

  // Custom InputTypes
  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnerCountOutputType
     */
    select?: OwnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OwnerCountOutputType without action
   */
  export type OwnerCountOutputTypeCountChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }


  /**
   * Count Type CommunityCountOutputType
   */

  export type CommunityCountOutputType = {
    groups: number
    liveRoom: number
    participants: number
    posts: number
    discussions: number
  }

  export type CommunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | CommunityCountOutputTypeCountGroupsArgs
    liveRoom?: boolean | CommunityCountOutputTypeCountLiveRoomArgs
    participants?: boolean | CommunityCountOutputTypeCountParticipantsArgs
    posts?: boolean | CommunityCountOutputTypeCountPostsArgs
    discussions?: boolean | CommunityCountOutputTypeCountDiscussionsArgs
  }

  // Custom InputTypes
  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCountOutputType
     */
    select?: CommunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountLiveRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiveRoomWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountDiscussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscussionWhereInput
  }


  /**
   * Count Type LiveRoomCountOutputType
   */

  export type LiveRoomCountOutputType = {
    User: number
  }

  export type LiveRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | LiveRoomCountOutputTypeCountUserArgs
  }

  // Custom InputTypes
  /**
   * LiveRoomCountOutputType without action
   */
  export type LiveRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoomCountOutputType
     */
    select?: LiveRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LiveRoomCountOutputType without action
   */
  export type LiveRoomCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type AccountingEntryCountOutputType
   */

  export type AccountingEntryCountOutputType = {
    files: number
    reports: number
  }

  export type AccountingEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | AccountingEntryCountOutputTypeCountFilesArgs
    reports?: boolean | AccountingEntryCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * AccountingEntryCountOutputType without action
   */
  export type AccountingEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntryCountOutputType
     */
    select?: AccountingEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountingEntryCountOutputType without action
   */
  export type AccountingEntryCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * AccountingEntryCountOutputType without action
   */
  export type AccountingEntryCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type PublicRelationsRecordCountOutputType
   */

  export type PublicRelationsRecordCountOutputType = {
    responses: number
    events: number
    posts: number
    files: number
    channels: number
  }

  export type PublicRelationsRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | PublicRelationsRecordCountOutputTypeCountResponsesArgs
    events?: boolean | PublicRelationsRecordCountOutputTypeCountEventsArgs
    posts?: boolean | PublicRelationsRecordCountOutputTypeCountPostsArgs
    files?: boolean | PublicRelationsRecordCountOutputTypeCountFilesArgs
    channels?: boolean | PublicRelationsRecordCountOutputTypeCountChannelsArgs
  }

  // Custom InputTypes
  /**
   * PublicRelationsRecordCountOutputType without action
   */
  export type PublicRelationsRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecordCountOutputType
     */
    select?: PublicRelationsRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PublicRelationsRecordCountOutputType without action
   */
  export type PublicRelationsRecordCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRResponseWhereInput
  }

  /**
   * PublicRelationsRecordCountOutputType without action
   */
  export type PublicRelationsRecordCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * PublicRelationsRecordCountOutputType without action
   */
  export type PublicRelationsRecordCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * PublicRelationsRecordCountOutputType without action
   */
  export type PublicRelationsRecordCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * PublicRelationsRecordCountOutputType without action
   */
  export type PublicRelationsRecordCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }


  /**
   * Count Type MeetingCountOutputType
   */

  export type MeetingCountOutputType = {
    participants: number
    files: number
    reports: number
    channels: number
  }

  export type MeetingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | MeetingCountOutputTypeCountParticipantsArgs
    files?: boolean | MeetingCountOutputTypeCountFilesArgs
    reports?: boolean | MeetingCountOutputTypeCountReportsArgs
    channels?: boolean | MeetingCountOutputTypeCountChannelsArgs
  }

  // Custom InputTypes
  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingCountOutputType
     */
    select?: MeetingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingParticipantWhereInput
  }

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    AdminRole: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdminRole?: boolean | PermissionCountOutputTypeCountAdminRoleArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountAdminRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRoleWhereInput
  }


  /**
   * Count Type AdminRoleCountOutputType
   */

  export type AdminRoleCountOutputType = {
    assignments: number
    permissions: number
    reports: number
    files: number
    events: number
    channels: number
  }

  export type AdminRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | AdminRoleCountOutputTypeCountAssignmentsArgs
    permissions?: boolean | AdminRoleCountOutputTypeCountPermissionsArgs
    reports?: boolean | AdminRoleCountOutputTypeCountReportsArgs
    files?: boolean | AdminRoleCountOutputTypeCountFilesArgs
    events?: boolean | AdminRoleCountOutputTypeCountEventsArgs
    channels?: boolean | AdminRoleCountOutputTypeCountChannelsArgs
  }

  // Custom InputTypes
  /**
   * AdminRoleCountOutputType without action
   */
  export type AdminRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRoleCountOutputType
     */
    select?: AdminRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminRoleCountOutputType without action
   */
  export type AdminRoleCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAssignmentWhereInput
  }

  /**
   * AdminRoleCountOutputType without action
   */
  export type AdminRoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }

  /**
   * AdminRoleCountOutputType without action
   */
  export type AdminRoleCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * AdminRoleCountOutputType without action
   */
  export type AdminRoleCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * AdminRoleCountOutputType without action
   */
  export type AdminRoleCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * AdminRoleCountOutputType without action
   */
  export type AdminRoleCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }


  /**
   * Count Type LegalCaseCountOutputType
   */

  export type LegalCaseCountOutputType = {
    files: number
    reports: number
    events: number
    channels: number
    payments: number
  }

  export type LegalCaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | LegalCaseCountOutputTypeCountFilesArgs
    reports?: boolean | LegalCaseCountOutputTypeCountReportsArgs
    events?: boolean | LegalCaseCountOutputTypeCountEventsArgs
    channels?: boolean | LegalCaseCountOutputTypeCountChannelsArgs
    payments?: boolean | LegalCaseCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * LegalCaseCountOutputType without action
   */
  export type LegalCaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCaseCountOutputType
     */
    select?: LegalCaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LegalCaseCountOutputType without action
   */
  export type LegalCaseCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * LegalCaseCountOutputType without action
   */
  export type LegalCaseCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * LegalCaseCountOutputType without action
   */
  export type LegalCaseCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * LegalCaseCountOutputType without action
   */
  export type LegalCaseCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
  }

  /**
   * LegalCaseCountOutputType without action
   */
  export type LegalCaseCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    age: number | null
  }

  export type UserSumAggregateOutputType = {
    age: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    subRole: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academyId: string | null
    isOnline: boolean | null
    isVerified: boolean | null
    age: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    phone: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    subRole: string | null
    avatar: string | null
    createdAt: Date | null
    updatedAt: Date | null
    academyId: string | null
    isOnline: boolean | null
    isVerified: boolean | null
    age: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    phone: number
    firstName: number
    lastName: number
    role: number
    subRole: number
    avatar: number
    createdAt: number
    updatedAt: number
    academyId: number
    isOnline: number
    isVerified: number
    age: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    age?: true
  }

  export type UserSumAggregateInputType = {
    age?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    phone?: true
    firstName?: true
    lastName?: true
    role?: true
    subRole?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    academyId?: true
    isOnline?: true
    isVerified?: true
    age?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    phone?: true
    firstName?: true
    lastName?: true
    role?: true
    subRole?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    academyId?: true
    isOnline?: true
    isVerified?: true
    age?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    phone?: true
    firstName?: true
    lastName?: true
    role?: true
    subRole?: true
    avatar?: true
    createdAt?: true
    updatedAt?: true
    academyId?: true
    isOnline?: true
    isVerified?: true
    age?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    phone: string | null
    firstName: string
    lastName: string
    role: $Enums.UserRole
    subRole: string | null
    avatar: string | null
    createdAt: Date
    updatedAt: Date
    academyId: string | null
    isOnline: boolean
    isVerified: boolean
    age: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    subRole?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academyId?: boolean
    isOnline?: boolean
    isVerified?: boolean
    age?: boolean
    academy?: boolean | User$academyArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    channels?: boolean | User$channelsArgs<ExtArgs>
    bookmarks?: boolean | User$bookmarksArgs<ExtArgs>
    Submission?: boolean | User$SubmissionArgs<ExtArgs>
    Attendance?: boolean | User$AttendanceArgs<ExtArgs>
    Instructor?: boolean | User$InstructorArgs<ExtArgs>
    Owner?: boolean | User$OwnerArgs<ExtArgs>
    Admin?: boolean | User$AdminArgs<ExtArgs>
    Lesson?: boolean | User$LessonArgs<ExtArgs>
    Payment?: boolean | User$PaymentArgs<ExtArgs>
    Report?: boolean | User$ReportArgs<ExtArgs>
    Badge?: boolean | User$BadgeArgs<ExtArgs>
    Certificate?: boolean | User$CertificateArgs<ExtArgs>
    Community?: boolean | User$CommunityArgs<ExtArgs>
    LiveRoom?: boolean | User$LiveRoomArgs<ExtArgs>
    NotificationSettings?: boolean | User$NotificationSettingsArgs<ExtArgs>
    Path?: boolean | User$PathArgs<ExtArgs>
    LoginHistory?: boolean | User$LoginHistoryArgs<ExtArgs>
    TwoFactor?: boolean | User$TwoFactorArgs<ExtArgs>
    UserAcademyCEO?: boolean | User$UserAcademyCEOArgs<ExtArgs>
    SalaryPayment?: boolean | User$SalaryPaymentArgs<ExtArgs>
    MeetingParticipant?: boolean | User$MeetingParticipantArgs<ExtArgs>
    LegalCase?: boolean | User$LegalCaseArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    subRole?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academyId?: boolean
    isOnline?: boolean
    isVerified?: boolean
    age?: boolean
    academy?: boolean | User$academyArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    subRole?: boolean
    avatar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academyId?: boolean
    isOnline?: boolean
    isVerified?: boolean
    age?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academy?: boolean | User$academyArgs<ExtArgs>
    profile?: boolean | User$profileArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    groups?: boolean | User$groupsArgs<ExtArgs>
    channels?: boolean | User$channelsArgs<ExtArgs>
    bookmarks?: boolean | User$bookmarksArgs<ExtArgs>
    Submission?: boolean | User$SubmissionArgs<ExtArgs>
    Attendance?: boolean | User$AttendanceArgs<ExtArgs>
    Instructor?: boolean | User$InstructorArgs<ExtArgs>
    Owner?: boolean | User$OwnerArgs<ExtArgs>
    Admin?: boolean | User$AdminArgs<ExtArgs>
    Lesson?: boolean | User$LessonArgs<ExtArgs>
    Payment?: boolean | User$PaymentArgs<ExtArgs>
    Report?: boolean | User$ReportArgs<ExtArgs>
    Badge?: boolean | User$BadgeArgs<ExtArgs>
    Certificate?: boolean | User$CertificateArgs<ExtArgs>
    Community?: boolean | User$CommunityArgs<ExtArgs>
    LiveRoom?: boolean | User$LiveRoomArgs<ExtArgs>
    NotificationSettings?: boolean | User$NotificationSettingsArgs<ExtArgs>
    Path?: boolean | User$PathArgs<ExtArgs>
    LoginHistory?: boolean | User$LoginHistoryArgs<ExtArgs>
    TwoFactor?: boolean | User$TwoFactorArgs<ExtArgs>
    UserAcademyCEO?: boolean | User$UserAcademyCEOArgs<ExtArgs>
    SalaryPayment?: boolean | User$SalaryPaymentArgs<ExtArgs>
    MeetingParticipant?: boolean | User$MeetingParticipantArgs<ExtArgs>
    LegalCase?: boolean | User$LegalCaseArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academy?: boolean | User$academyArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      academy: Prisma.$AcademyPayload<ExtArgs> | null
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      achievements: Prisma.$AchievementPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      groups: Prisma.$GroupPayload<ExtArgs>[]
      channels: Prisma.$ChannelPayload<ExtArgs>[]
      bookmarks: Prisma.$BookmarkPayload<ExtArgs>[]
      Submission: Prisma.$SubmissionPayload<ExtArgs>[]
      Attendance: Prisma.$AttendancePayload<ExtArgs>[]
      Instructor: Prisma.$InstructorPayload<ExtArgs>[]
      Owner: Prisma.$OwnerPayload<ExtArgs>[]
      Admin: Prisma.$AdminPayload<ExtArgs>[]
      Lesson: Prisma.$LessonPayload<ExtArgs>[]
      Payment: Prisma.$PaymentPayload<ExtArgs>[]
      Report: Prisma.$ReportPayload<ExtArgs>[]
      Badge: Prisma.$BadgePayload<ExtArgs>[]
      Certificate: Prisma.$CertificatePayload<ExtArgs>[]
      Community: Prisma.$CommunityPayload<ExtArgs>[]
      LiveRoom: Prisma.$LiveRoomPayload<ExtArgs>[]
      NotificationSettings: Prisma.$NotificationSettingsPayload<ExtArgs>[]
      Path: Prisma.$PathPayload<ExtArgs>[]
      LoginHistory: Prisma.$LoginHistoryPayload<ExtArgs>[]
      TwoFactor: Prisma.$TwoFactorPayload<ExtArgs>[]
      UserAcademyCEO: Prisma.$UserAcademyCEOPayload<ExtArgs>[]
      SalaryPayment: Prisma.$SalaryPaymentPayload<ExtArgs>[]
      MeetingParticipant: Prisma.$MeetingParticipantPayload<ExtArgs>[]
      LegalCase: Prisma.$LegalCasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      phone: string | null
      firstName: string
      lastName: string
      role: $Enums.UserRole
      subRole: string | null
      avatar: string | null
      createdAt: Date
      updatedAt: Date
      academyId: string | null
      isOnline: boolean
      isVerified: boolean
      age: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academy<T extends User$academyArgs<ExtArgs> = {}>(args?: Subset<T, User$academyArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    enrollments<T extends User$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    groups<T extends User$groupsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany"> | Null>
    channels<T extends User$channelsArgs<ExtArgs> = {}>(args?: Subset<T, User$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    bookmarks<T extends User$bookmarksArgs<ExtArgs> = {}>(args?: Subset<T, User$bookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany"> | Null>
    Submission<T extends User$SubmissionArgs<ExtArgs> = {}>(args?: Subset<T, User$SubmissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    Attendance<T extends User$AttendanceArgs<ExtArgs> = {}>(args?: Subset<T, User$AttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany"> | Null>
    Instructor<T extends User$InstructorArgs<ExtArgs> = {}>(args?: Subset<T, User$InstructorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findMany"> | Null>
    Owner<T extends User$OwnerArgs<ExtArgs> = {}>(args?: Subset<T, User$OwnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findMany"> | Null>
    Admin<T extends User$AdminArgs<ExtArgs> = {}>(args?: Subset<T, User$AdminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany"> | Null>
    Lesson<T extends User$LessonArgs<ExtArgs> = {}>(args?: Subset<T, User$LessonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany"> | Null>
    Payment<T extends User$PaymentArgs<ExtArgs> = {}>(args?: Subset<T, User$PaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    Report<T extends User$ReportArgs<ExtArgs> = {}>(args?: Subset<T, User$ReportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    Badge<T extends User$BadgeArgs<ExtArgs> = {}>(args?: Subset<T, User$BadgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany"> | Null>
    Certificate<T extends User$CertificateArgs<ExtArgs> = {}>(args?: Subset<T, User$CertificateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    Community<T extends User$CommunityArgs<ExtArgs> = {}>(args?: Subset<T, User$CommunityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findMany"> | Null>
    LiveRoom<T extends User$LiveRoomArgs<ExtArgs> = {}>(args?: Subset<T, User$LiveRoomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "findMany"> | Null>
    NotificationSettings<T extends User$NotificationSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany"> | Null>
    Path<T extends User$PathArgs<ExtArgs> = {}>(args?: Subset<T, User$PathArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findMany"> | Null>
    LoginHistory<T extends User$LoginHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$LoginHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    TwoFactor<T extends User$TwoFactorArgs<ExtArgs> = {}>(args?: Subset<T, User$TwoFactorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findMany"> | Null>
    UserAcademyCEO<T extends User$UserAcademyCEOArgs<ExtArgs> = {}>(args?: Subset<T, User$UserAcademyCEOArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "findMany"> | Null>
    SalaryPayment<T extends User$SalaryPaymentArgs<ExtArgs> = {}>(args?: Subset<T, User$SalaryPaymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findMany"> | Null>
    MeetingParticipant<T extends User$MeetingParticipantArgs<ExtArgs> = {}>(args?: Subset<T, User$MeetingParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    LegalCase<T extends User$LegalCaseArgs<ExtArgs> = {}>(args?: Subset<T, User$LegalCaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly subRole: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly academyId: FieldRef<"User", 'String'>
    readonly isOnline: FieldRef<"User", 'Boolean'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly age: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.academy
   */
  export type User$academyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
    where?: AcademyWhereInput
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.enrollments
   */
  export type User$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.groups
   */
  export type User$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * User.channels
   */
  export type User$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * User.bookmarks
   */
  export type User$bookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    cursor?: BookmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * User.Submission
   */
  export type User$SubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    cursor?: SubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * User.Attendance
   */
  export type User$AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.Instructor
   */
  export type User$InstructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    where?: InstructorWhereInput
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    cursor?: InstructorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * User.Owner
   */
  export type User$OwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    cursor?: OwnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * User.Admin
   */
  export type User$AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * User.Lesson
   */
  export type User$LessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * User.Payment
   */
  export type User$PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.Report
   */
  export type User$ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.Badge
   */
  export type User$BadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    cursor?: BadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * User.Certificate
   */
  export type User$CertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * User.Community
   */
  export type User$CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    cursor?: CommunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * User.LiveRoom
   */
  export type User$LiveRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    where?: LiveRoomWhereInput
    orderBy?: LiveRoomOrderByWithRelationInput | LiveRoomOrderByWithRelationInput[]
    cursor?: LiveRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiveRoomScalarFieldEnum | LiveRoomScalarFieldEnum[]
  }

  /**
   * User.NotificationSettings
   */
  export type User$NotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    cursor?: NotificationSettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * User.Path
   */
  export type User$PathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    where?: PathWhereInput
    orderBy?: PathOrderByWithRelationInput | PathOrderByWithRelationInput[]
    cursor?: PathWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathScalarFieldEnum | PathScalarFieldEnum[]
  }

  /**
   * User.LoginHistory
   */
  export type User$LoginHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    where?: LoginHistoryWhereInput
    orderBy?: LoginHistoryOrderByWithRelationInput | LoginHistoryOrderByWithRelationInput[]
    cursor?: LoginHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoginHistoryScalarFieldEnum | LoginHistoryScalarFieldEnum[]
  }

  /**
   * User.TwoFactor
   */
  export type User$TwoFactorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    where?: TwoFactorWhereInput
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    cursor?: TwoFactorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * User.UserAcademyCEO
   */
  export type User$UserAcademyCEOArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    where?: UserAcademyCEOWhereInput
    orderBy?: UserAcademyCEOOrderByWithRelationInput | UserAcademyCEOOrderByWithRelationInput[]
    cursor?: UserAcademyCEOWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAcademyCEOScalarFieldEnum | UserAcademyCEOScalarFieldEnum[]
  }

  /**
   * User.SalaryPayment
   */
  export type User$SalaryPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    where?: SalaryPaymentWhereInput
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    cursor?: SalaryPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * User.MeetingParticipant
   */
  export type User$MeetingParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    where?: MeetingParticipantWhereInput
    orderBy?: MeetingParticipantOrderByWithRelationInput | MeetingParticipantOrderByWithRelationInput[]
    cursor?: MeetingParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingParticipantScalarFieldEnum | MeetingParticipantScalarFieldEnum[]
  }

  /**
   * User.LegalCase
   */
  export type User$LegalCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    where?: LegalCaseWhereInput
    orderBy?: LegalCaseOrderByWithRelationInput | LegalCaseOrderByWithRelationInput[]
    cursor?: LegalCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LegalCaseScalarFieldEnum | LegalCaseScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model LoginHistory
   */

  export type AggregateLoginHistory = {
    _count: LoginHistoryCountAggregateOutputType | null
    _min: LoginHistoryMinAggregateOutputType | null
    _max: LoginHistoryMaxAggregateOutputType | null
  }

  export type LoginHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    success: boolean | null
    ip: string | null
    device: $Enums.LoginDevice | null
    location: string | null
    browser: string | null
    os: string | null
    createdAt: Date | null
  }

  export type LoginHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    success: boolean | null
    ip: string | null
    device: $Enums.LoginDevice | null
    location: string | null
    browser: string | null
    os: string | null
    createdAt: Date | null
  }

  export type LoginHistoryCountAggregateOutputType = {
    id: number
    userId: number
    success: number
    ip: number
    device: number
    location: number
    browser: number
    os: number
    createdAt: number
    _all: number
  }


  export type LoginHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    success?: true
    ip?: true
    device?: true
    location?: true
    browser?: true
    os?: true
    createdAt?: true
  }

  export type LoginHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    success?: true
    ip?: true
    device?: true
    location?: true
    browser?: true
    os?: true
    createdAt?: true
  }

  export type LoginHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    success?: true
    ip?: true
    device?: true
    location?: true
    browser?: true
    os?: true
    createdAt?: true
    _all?: true
  }

  export type LoginHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginHistory to aggregate.
     */
    where?: LoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginHistories to fetch.
     */
    orderBy?: LoginHistoryOrderByWithRelationInput | LoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoginHistories
    **/
    _count?: true | LoginHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginHistoryMaxAggregateInputType
  }

  export type GetLoginHistoryAggregateType<T extends LoginHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLoginHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoginHistory[P]>
      : GetScalarType<T[P], AggregateLoginHistory[P]>
  }




  export type LoginHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginHistoryWhereInput
    orderBy?: LoginHistoryOrderByWithAggregationInput | LoginHistoryOrderByWithAggregationInput[]
    by: LoginHistoryScalarFieldEnum[] | LoginHistoryScalarFieldEnum
    having?: LoginHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginHistoryCountAggregateInputType | true
    _min?: LoginHistoryMinAggregateInputType
    _max?: LoginHistoryMaxAggregateInputType
  }

  export type LoginHistoryGroupByOutputType = {
    id: string
    userId: string
    success: boolean
    ip: string | null
    device: $Enums.LoginDevice | null
    location: string | null
    browser: string | null
    os: string | null
    createdAt: Date
    _count: LoginHistoryCountAggregateOutputType | null
    _min: LoginHistoryMinAggregateOutputType | null
    _max: LoginHistoryMaxAggregateOutputType | null
  }

  type GetLoginHistoryGroupByPayload<T extends LoginHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LoginHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LoginHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    success?: boolean
    ip?: boolean
    device?: boolean
    location?: boolean
    browser?: boolean
    os?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginHistory"]>

  export type LoginHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    success?: boolean
    ip?: boolean
    device?: boolean
    location?: boolean
    browser?: boolean
    os?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginHistory"]>

  export type LoginHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    success?: boolean
    ip?: boolean
    device?: boolean
    location?: boolean
    browser?: boolean
    os?: boolean
    createdAt?: boolean
  }

  export type LoginHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type LoginHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LoginHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoginHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      success: boolean
      ip: string | null
      device: $Enums.LoginDevice | null
      location: string | null
      browser: string | null
      os: string | null
      createdAt: Date
    }, ExtArgs["result"]["loginHistory"]>
    composites: {}
  }

  type LoginHistoryGetPayload<S extends boolean | null | undefined | LoginHistoryDefaultArgs> = $Result.GetResult<Prisma.$LoginHistoryPayload, S>

  type LoginHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoginHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoginHistoryCountAggregateInputType | true
    }

  export interface LoginHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoginHistory'], meta: { name: 'LoginHistory' } }
    /**
     * Find zero or one LoginHistory that matches the filter.
     * @param {LoginHistoryFindUniqueArgs} args - Arguments to find a LoginHistory
     * @example
     * // Get one LoginHistory
     * const loginHistory = await prisma.loginHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginHistoryFindUniqueArgs>(args: SelectSubset<T, LoginHistoryFindUniqueArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LoginHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoginHistoryFindUniqueOrThrowArgs} args - Arguments to find a LoginHistory
     * @example
     * // Get one LoginHistory
     * const loginHistory = await prisma.loginHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LoginHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryFindFirstArgs} args - Arguments to find a LoginHistory
     * @example
     * // Get one LoginHistory
     * const loginHistory = await prisma.loginHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginHistoryFindFirstArgs>(args?: SelectSubset<T, LoginHistoryFindFirstArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LoginHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryFindFirstOrThrowArgs} args - Arguments to find a LoginHistory
     * @example
     * // Get one LoginHistory
     * const loginHistory = await prisma.loginHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LoginHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoginHistories
     * const loginHistories = await prisma.loginHistory.findMany()
     * 
     * // Get first 10 LoginHistories
     * const loginHistories = await prisma.loginHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginHistoryWithIdOnly = await prisma.loginHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginHistoryFindManyArgs>(args?: SelectSubset<T, LoginHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LoginHistory.
     * @param {LoginHistoryCreateArgs} args - Arguments to create a LoginHistory.
     * @example
     * // Create one LoginHistory
     * const LoginHistory = await prisma.loginHistory.create({
     *   data: {
     *     // ... data to create a LoginHistory
     *   }
     * })
     * 
     */
    create<T extends LoginHistoryCreateArgs>(args: SelectSubset<T, LoginHistoryCreateArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LoginHistories.
     * @param {LoginHistoryCreateManyArgs} args - Arguments to create many LoginHistories.
     * @example
     * // Create many LoginHistories
     * const loginHistory = await prisma.loginHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginHistoryCreateManyArgs>(args?: SelectSubset<T, LoginHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoginHistories and returns the data saved in the database.
     * @param {LoginHistoryCreateManyAndReturnArgs} args - Arguments to create many LoginHistories.
     * @example
     * // Create many LoginHistories
     * const loginHistory = await prisma.loginHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoginHistories and only return the `id`
     * const loginHistoryWithIdOnly = await prisma.loginHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoginHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, LoginHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LoginHistory.
     * @param {LoginHistoryDeleteArgs} args - Arguments to delete one LoginHistory.
     * @example
     * // Delete one LoginHistory
     * const LoginHistory = await prisma.loginHistory.delete({
     *   where: {
     *     // ... filter to delete one LoginHistory
     *   }
     * })
     * 
     */
    delete<T extends LoginHistoryDeleteArgs>(args: SelectSubset<T, LoginHistoryDeleteArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LoginHistory.
     * @param {LoginHistoryUpdateArgs} args - Arguments to update one LoginHistory.
     * @example
     * // Update one LoginHistory
     * const loginHistory = await prisma.loginHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginHistoryUpdateArgs>(args: SelectSubset<T, LoginHistoryUpdateArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LoginHistories.
     * @param {LoginHistoryDeleteManyArgs} args - Arguments to filter LoginHistories to delete.
     * @example
     * // Delete a few LoginHistories
     * const { count } = await prisma.loginHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginHistoryDeleteManyArgs>(args?: SelectSubset<T, LoginHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoginHistories
     * const loginHistory = await prisma.loginHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginHistoryUpdateManyArgs>(args: SelectSubset<T, LoginHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoginHistory.
     * @param {LoginHistoryUpsertArgs} args - Arguments to update or create a LoginHistory.
     * @example
     * // Update or create a LoginHistory
     * const loginHistory = await prisma.loginHistory.upsert({
     *   create: {
     *     // ... data to create a LoginHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoginHistory we want to update
     *   }
     * })
     */
    upsert<T extends LoginHistoryUpsertArgs>(args: SelectSubset<T, LoginHistoryUpsertArgs<ExtArgs>>): Prisma__LoginHistoryClient<$Result.GetResult<Prisma.$LoginHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LoginHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryCountArgs} args - Arguments to filter LoginHistories to count.
     * @example
     * // Count the number of LoginHistories
     * const count = await prisma.loginHistory.count({
     *   where: {
     *     // ... the filter for the LoginHistories we want to count
     *   }
     * })
    **/
    count<T extends LoginHistoryCountArgs>(
      args?: Subset<T, LoginHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoginHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginHistoryAggregateArgs>(args: Subset<T, LoginHistoryAggregateArgs>): Prisma.PrismaPromise<GetLoginHistoryAggregateType<T>>

    /**
     * Group by LoginHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LoginHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoginHistory model
   */
  readonly fields: LoginHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoginHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoginHistory model
   */ 
  interface LoginHistoryFieldRefs {
    readonly id: FieldRef<"LoginHistory", 'String'>
    readonly userId: FieldRef<"LoginHistory", 'String'>
    readonly success: FieldRef<"LoginHistory", 'Boolean'>
    readonly ip: FieldRef<"LoginHistory", 'String'>
    readonly device: FieldRef<"LoginHistory", 'LoginDevice'>
    readonly location: FieldRef<"LoginHistory", 'String'>
    readonly browser: FieldRef<"LoginHistory", 'String'>
    readonly os: FieldRef<"LoginHistory", 'String'>
    readonly createdAt: FieldRef<"LoginHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoginHistory findUnique
   */
  export type LoginHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LoginHistory to fetch.
     */
    where: LoginHistoryWhereUniqueInput
  }

  /**
   * LoginHistory findUniqueOrThrow
   */
  export type LoginHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LoginHistory to fetch.
     */
    where: LoginHistoryWhereUniqueInput
  }

  /**
   * LoginHistory findFirst
   */
  export type LoginHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LoginHistory to fetch.
     */
    where?: LoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginHistories to fetch.
     */
    orderBy?: LoginHistoryOrderByWithRelationInput | LoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginHistories.
     */
    cursor?: LoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginHistories.
     */
    distinct?: LoginHistoryScalarFieldEnum | LoginHistoryScalarFieldEnum[]
  }

  /**
   * LoginHistory findFirstOrThrow
   */
  export type LoginHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LoginHistory to fetch.
     */
    where?: LoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginHistories to fetch.
     */
    orderBy?: LoginHistoryOrderByWithRelationInput | LoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginHistories.
     */
    cursor?: LoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginHistories.
     */
    distinct?: LoginHistoryScalarFieldEnum | LoginHistoryScalarFieldEnum[]
  }

  /**
   * LoginHistory findMany
   */
  export type LoginHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LoginHistories to fetch.
     */
    where?: LoginHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginHistories to fetch.
     */
    orderBy?: LoginHistoryOrderByWithRelationInput | LoginHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoginHistories.
     */
    cursor?: LoginHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginHistories.
     */
    skip?: number
    distinct?: LoginHistoryScalarFieldEnum | LoginHistoryScalarFieldEnum[]
  }

  /**
   * LoginHistory create
   */
  export type LoginHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a LoginHistory.
     */
    data: XOR<LoginHistoryCreateInput, LoginHistoryUncheckedCreateInput>
  }

  /**
   * LoginHistory createMany
   */
  export type LoginHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoginHistories.
     */
    data: LoginHistoryCreateManyInput | LoginHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoginHistory createManyAndReturn
   */
  export type LoginHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LoginHistories.
     */
    data: LoginHistoryCreateManyInput | LoginHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginHistory update
   */
  export type LoginHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a LoginHistory.
     */
    data: XOR<LoginHistoryUpdateInput, LoginHistoryUncheckedUpdateInput>
    /**
     * Choose, which LoginHistory to update.
     */
    where: LoginHistoryWhereUniqueInput
  }

  /**
   * LoginHistory updateMany
   */
  export type LoginHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoginHistories.
     */
    data: XOR<LoginHistoryUpdateManyMutationInput, LoginHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LoginHistories to update
     */
    where?: LoginHistoryWhereInput
  }

  /**
   * LoginHistory upsert
   */
  export type LoginHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the LoginHistory to update in case it exists.
     */
    where: LoginHistoryWhereUniqueInput
    /**
     * In case the LoginHistory found by the `where` argument doesn't exist, create a new LoginHistory with this data.
     */
    create: XOR<LoginHistoryCreateInput, LoginHistoryUncheckedCreateInput>
    /**
     * In case the LoginHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginHistoryUpdateInput, LoginHistoryUncheckedUpdateInput>
  }

  /**
   * LoginHistory delete
   */
  export type LoginHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
    /**
     * Filter which LoginHistory to delete.
     */
    where: LoginHistoryWhereUniqueInput
  }

  /**
   * LoginHistory deleteMany
   */
  export type LoginHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginHistories to delete
     */
    where?: LoginHistoryWhereInput
  }

  /**
   * LoginHistory without action
   */
  export type LoginHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginHistory
     */
    select?: LoginHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginHistoryInclude<ExtArgs> | null
  }


  /**
   * Model TwoFactor
   */

  export type AggregateTwoFactor = {
    _count: TwoFactorCountAggregateOutputType | null
    _min: TwoFactorMinAggregateOutputType | null
    _max: TwoFactorMaxAggregateOutputType | null
  }

  export type TwoFactorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: boolean | null
    sms: boolean | null
    authenticator: boolean | null
    secret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: boolean | null
    sms: boolean | null
    authenticator: boolean | null
    secret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TwoFactorCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    sms: number
    authenticator: number
    secret: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TwoFactorMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    sms?: true
    authenticator?: true
    secret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    sms?: true
    authenticator?: true
    secret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TwoFactorCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    sms?: true
    authenticator?: true
    secret?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TwoFactorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactor to aggregate.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwoFactors
    **/
    _count?: true | TwoFactorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwoFactorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwoFactorMaxAggregateInputType
  }

  export type GetTwoFactorAggregateType<T extends TwoFactorAggregateArgs> = {
        [P in keyof T & keyof AggregateTwoFactor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwoFactor[P]>
      : GetScalarType<T[P], AggregateTwoFactor[P]>
  }




  export type TwoFactorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwoFactorWhereInput
    orderBy?: TwoFactorOrderByWithAggregationInput | TwoFactorOrderByWithAggregationInput[]
    by: TwoFactorScalarFieldEnum[] | TwoFactorScalarFieldEnum
    having?: TwoFactorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwoFactorCountAggregateInputType | true
    _min?: TwoFactorMinAggregateInputType
    _max?: TwoFactorMaxAggregateInputType
  }

  export type TwoFactorGroupByOutputType = {
    id: string
    userId: string
    email: boolean
    sms: boolean
    authenticator: boolean
    secret: string | null
    createdAt: Date
    updatedAt: Date
    _count: TwoFactorCountAggregateOutputType | null
    _min: TwoFactorMinAggregateOutputType | null
    _max: TwoFactorMaxAggregateOutputType | null
  }

  type GetTwoFactorGroupByPayload<T extends TwoFactorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwoFactorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwoFactorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwoFactorGroupByOutputType[P]>
            : GetScalarType<T[P], TwoFactorGroupByOutputType[P]>
        }
      >
    >


  export type TwoFactorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    sms?: boolean
    authenticator?: boolean
    secret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactor"]>

  export type TwoFactorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    sms?: boolean
    authenticator?: boolean
    secret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twoFactor"]>

  export type TwoFactorSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    sms?: boolean
    authenticator?: boolean
    secret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TwoFactorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TwoFactorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TwoFactorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwoFactor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      email: boolean
      sms: boolean
      authenticator: boolean
      secret: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["twoFactor"]>
    composites: {}
  }

  type TwoFactorGetPayload<S extends boolean | null | undefined | TwoFactorDefaultArgs> = $Result.GetResult<Prisma.$TwoFactorPayload, S>

  type TwoFactorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TwoFactorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TwoFactorCountAggregateInputType | true
    }

  export interface TwoFactorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwoFactor'], meta: { name: 'TwoFactor' } }
    /**
     * Find zero or one TwoFactor that matches the filter.
     * @param {TwoFactorFindUniqueArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwoFactorFindUniqueArgs>(args: SelectSubset<T, TwoFactorFindUniqueArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TwoFactor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TwoFactorFindUniqueOrThrowArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwoFactorFindUniqueOrThrowArgs>(args: SelectSubset<T, TwoFactorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TwoFactor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorFindFirstArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwoFactorFindFirstArgs>(args?: SelectSubset<T, TwoFactorFindFirstArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TwoFactor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorFindFirstOrThrowArgs} args - Arguments to find a TwoFactor
     * @example
     * // Get one TwoFactor
     * const twoFactor = await prisma.twoFactor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwoFactorFindFirstOrThrowArgs>(args?: SelectSubset<T, TwoFactorFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TwoFactors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwoFactors
     * const twoFactors = await prisma.twoFactor.findMany()
     * 
     * // Get first 10 TwoFactors
     * const twoFactors = await prisma.twoFactor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twoFactorWithIdOnly = await prisma.twoFactor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwoFactorFindManyArgs>(args?: SelectSubset<T, TwoFactorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TwoFactor.
     * @param {TwoFactorCreateArgs} args - Arguments to create a TwoFactor.
     * @example
     * // Create one TwoFactor
     * const TwoFactor = await prisma.twoFactor.create({
     *   data: {
     *     // ... data to create a TwoFactor
     *   }
     * })
     * 
     */
    create<T extends TwoFactorCreateArgs>(args: SelectSubset<T, TwoFactorCreateArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TwoFactors.
     * @param {TwoFactorCreateManyArgs} args - Arguments to create many TwoFactors.
     * @example
     * // Create many TwoFactors
     * const twoFactor = await prisma.twoFactor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwoFactorCreateManyArgs>(args?: SelectSubset<T, TwoFactorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwoFactors and returns the data saved in the database.
     * @param {TwoFactorCreateManyAndReturnArgs} args - Arguments to create many TwoFactors.
     * @example
     * // Create many TwoFactors
     * const twoFactor = await prisma.twoFactor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwoFactors and only return the `id`
     * const twoFactorWithIdOnly = await prisma.twoFactor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwoFactorCreateManyAndReturnArgs>(args?: SelectSubset<T, TwoFactorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TwoFactor.
     * @param {TwoFactorDeleteArgs} args - Arguments to delete one TwoFactor.
     * @example
     * // Delete one TwoFactor
     * const TwoFactor = await prisma.twoFactor.delete({
     *   where: {
     *     // ... filter to delete one TwoFactor
     *   }
     * })
     * 
     */
    delete<T extends TwoFactorDeleteArgs>(args: SelectSubset<T, TwoFactorDeleteArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TwoFactor.
     * @param {TwoFactorUpdateArgs} args - Arguments to update one TwoFactor.
     * @example
     * // Update one TwoFactor
     * const twoFactor = await prisma.twoFactor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwoFactorUpdateArgs>(args: SelectSubset<T, TwoFactorUpdateArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TwoFactors.
     * @param {TwoFactorDeleteManyArgs} args - Arguments to filter TwoFactors to delete.
     * @example
     * // Delete a few TwoFactors
     * const { count } = await prisma.twoFactor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwoFactorDeleteManyArgs>(args?: SelectSubset<T, TwoFactorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwoFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwoFactors
     * const twoFactor = await prisma.twoFactor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwoFactorUpdateManyArgs>(args: SelectSubset<T, TwoFactorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TwoFactor.
     * @param {TwoFactorUpsertArgs} args - Arguments to update or create a TwoFactor.
     * @example
     * // Update or create a TwoFactor
     * const twoFactor = await prisma.twoFactor.upsert({
     *   create: {
     *     // ... data to create a TwoFactor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwoFactor we want to update
     *   }
     * })
     */
    upsert<T extends TwoFactorUpsertArgs>(args: SelectSubset<T, TwoFactorUpsertArgs<ExtArgs>>): Prisma__TwoFactorClient<$Result.GetResult<Prisma.$TwoFactorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TwoFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorCountArgs} args - Arguments to filter TwoFactors to count.
     * @example
     * // Count the number of TwoFactors
     * const count = await prisma.twoFactor.count({
     *   where: {
     *     // ... the filter for the TwoFactors we want to count
     *   }
     * })
    **/
    count<T extends TwoFactorCountArgs>(
      args?: Subset<T, TwoFactorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwoFactorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwoFactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwoFactorAggregateArgs>(args: Subset<T, TwoFactorAggregateArgs>): Prisma.PrismaPromise<GetTwoFactorAggregateType<T>>

    /**
     * Group by TwoFactor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwoFactorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwoFactorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwoFactorGroupByArgs['orderBy'] }
        : { orderBy?: TwoFactorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwoFactorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwoFactorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwoFactor model
   */
  readonly fields: TwoFactorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwoFactor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwoFactorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwoFactor model
   */ 
  interface TwoFactorFieldRefs {
    readonly id: FieldRef<"TwoFactor", 'String'>
    readonly userId: FieldRef<"TwoFactor", 'String'>
    readonly email: FieldRef<"TwoFactor", 'Boolean'>
    readonly sms: FieldRef<"TwoFactor", 'Boolean'>
    readonly authenticator: FieldRef<"TwoFactor", 'Boolean'>
    readonly secret: FieldRef<"TwoFactor", 'String'>
    readonly createdAt: FieldRef<"TwoFactor", 'DateTime'>
    readonly updatedAt: FieldRef<"TwoFactor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwoFactor findUnique
   */
  export type TwoFactorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor findUniqueOrThrow
   */
  export type TwoFactorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor findFirst
   */
  export type TwoFactorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactors.
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactors.
     */
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * TwoFactor findFirstOrThrow
   */
  export type TwoFactorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactor to fetch.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwoFactors.
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwoFactors.
     */
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * TwoFactor findMany
   */
  export type TwoFactorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter, which TwoFactors to fetch.
     */
    where?: TwoFactorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwoFactors to fetch.
     */
    orderBy?: TwoFactorOrderByWithRelationInput | TwoFactorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwoFactors.
     */
    cursor?: TwoFactorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwoFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwoFactors.
     */
    skip?: number
    distinct?: TwoFactorScalarFieldEnum | TwoFactorScalarFieldEnum[]
  }

  /**
   * TwoFactor create
   */
  export type TwoFactorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * The data needed to create a TwoFactor.
     */
    data: XOR<TwoFactorCreateInput, TwoFactorUncheckedCreateInput>
  }

  /**
   * TwoFactor createMany
   */
  export type TwoFactorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwoFactors.
     */
    data: TwoFactorCreateManyInput | TwoFactorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwoFactor createManyAndReturn
   */
  export type TwoFactorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TwoFactors.
     */
    data: TwoFactorCreateManyInput | TwoFactorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwoFactor update
   */
  export type TwoFactorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * The data needed to update a TwoFactor.
     */
    data: XOR<TwoFactorUpdateInput, TwoFactorUncheckedUpdateInput>
    /**
     * Choose, which TwoFactor to update.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor updateMany
   */
  export type TwoFactorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwoFactors.
     */
    data: XOR<TwoFactorUpdateManyMutationInput, TwoFactorUncheckedUpdateManyInput>
    /**
     * Filter which TwoFactors to update
     */
    where?: TwoFactorWhereInput
  }

  /**
   * TwoFactor upsert
   */
  export type TwoFactorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * The filter to search for the TwoFactor to update in case it exists.
     */
    where: TwoFactorWhereUniqueInput
    /**
     * In case the TwoFactor found by the `where` argument doesn't exist, create a new TwoFactor with this data.
     */
    create: XOR<TwoFactorCreateInput, TwoFactorUncheckedCreateInput>
    /**
     * In case the TwoFactor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwoFactorUpdateInput, TwoFactorUncheckedUpdateInput>
  }

  /**
   * TwoFactor delete
   */
  export type TwoFactorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
    /**
     * Filter which TwoFactor to delete.
     */
    where: TwoFactorWhereUniqueInput
  }

  /**
   * TwoFactor deleteMany
   */
  export type TwoFactorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwoFactors to delete
     */
    where?: TwoFactorWhereInput
  }

  /**
   * TwoFactor without action
   */
  export type TwoFactorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwoFactor
     */
    select?: TwoFactorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwoFactorInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    phone: string | null
    address: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    phone: string | null
    address: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    bio: number
    phone: number
    address: number
    preferences: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    phone?: true
    address?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    phone?: true
    address?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    phone?: true
    address?: true
    preferences?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    bio: string | null
    phone: string | null
    address: string | null
    preferences: JsonValue | null
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    phone?: boolean
    address?: boolean
    preferences?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    phone?: boolean
    address?: boolean
    preferences?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    bio?: boolean
    phone?: boolean
    address?: boolean
    preferences?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bio: string | null
      phone: string | null
      address: string | null
      preferences: Prisma.JsonValue | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly phone: FieldRef<"Profile", 'String'>
    readonly address: FieldRef<"Profile", 'String'>
    readonly preferences: FieldRef<"Profile", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserAcademyCEO
   */

  export type AggregateUserAcademyCEO = {
    _count: UserAcademyCEOCountAggregateOutputType | null
    _min: UserAcademyCEOMinAggregateOutputType | null
    _max: UserAcademyCEOMaxAggregateOutputType | null
  }

  export type UserAcademyCEOMinAggregateOutputType = {
    id: string | null
    userId: string | null
    academyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAcademyCEOMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    academyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAcademyCEOCountAggregateOutputType = {
    id: number
    userId: number
    academyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAcademyCEOMinAggregateInputType = {
    id?: true
    userId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAcademyCEOMaxAggregateInputType = {
    id?: true
    userId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAcademyCEOCountAggregateInputType = {
    id?: true
    userId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAcademyCEOAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAcademyCEO to aggregate.
     */
    where?: UserAcademyCEOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAcademyCEOS to fetch.
     */
    orderBy?: UserAcademyCEOOrderByWithRelationInput | UserAcademyCEOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAcademyCEOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAcademyCEOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAcademyCEOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAcademyCEOS
    **/
    _count?: true | UserAcademyCEOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAcademyCEOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAcademyCEOMaxAggregateInputType
  }

  export type GetUserAcademyCEOAggregateType<T extends UserAcademyCEOAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAcademyCEO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAcademyCEO[P]>
      : GetScalarType<T[P], AggregateUserAcademyCEO[P]>
  }




  export type UserAcademyCEOGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAcademyCEOWhereInput
    orderBy?: UserAcademyCEOOrderByWithAggregationInput | UserAcademyCEOOrderByWithAggregationInput[]
    by: UserAcademyCEOScalarFieldEnum[] | UserAcademyCEOScalarFieldEnum
    having?: UserAcademyCEOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAcademyCEOCountAggregateInputType | true
    _min?: UserAcademyCEOMinAggregateInputType
    _max?: UserAcademyCEOMaxAggregateInputType
  }

  export type UserAcademyCEOGroupByOutputType = {
    id: string
    userId: string
    academyId: string
    createdAt: Date
    updatedAt: Date
    _count: UserAcademyCEOCountAggregateOutputType | null
    _min: UserAcademyCEOMinAggregateOutputType | null
    _max: UserAcademyCEOMaxAggregateOutputType | null
  }

  type GetUserAcademyCEOGroupByPayload<T extends UserAcademyCEOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAcademyCEOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAcademyCEOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAcademyCEOGroupByOutputType[P]>
            : GetScalarType<T[P], UserAcademyCEOGroupByOutputType[P]>
        }
      >
    >


  export type UserAcademyCEOSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAcademyCEO"]>

  export type UserAcademyCEOSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAcademyCEO"]>

  export type UserAcademyCEOSelectScalar = {
    id?: boolean
    userId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserAcademyCEOInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }
  export type UserAcademyCEOIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }

  export type $UserAcademyCEOPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAcademyCEO"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      academy: Prisma.$AcademyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      academyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAcademyCEO"]>
    composites: {}
  }

  type UserAcademyCEOGetPayload<S extends boolean | null | undefined | UserAcademyCEODefaultArgs> = $Result.GetResult<Prisma.$UserAcademyCEOPayload, S>

  type UserAcademyCEOCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAcademyCEOFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAcademyCEOCountAggregateInputType | true
    }

  export interface UserAcademyCEODelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAcademyCEO'], meta: { name: 'UserAcademyCEO' } }
    /**
     * Find zero or one UserAcademyCEO that matches the filter.
     * @param {UserAcademyCEOFindUniqueArgs} args - Arguments to find a UserAcademyCEO
     * @example
     * // Get one UserAcademyCEO
     * const userAcademyCEO = await prisma.userAcademyCEO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAcademyCEOFindUniqueArgs>(args: SelectSubset<T, UserAcademyCEOFindUniqueArgs<ExtArgs>>): Prisma__UserAcademyCEOClient<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAcademyCEO that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAcademyCEOFindUniqueOrThrowArgs} args - Arguments to find a UserAcademyCEO
     * @example
     * // Get one UserAcademyCEO
     * const userAcademyCEO = await prisma.userAcademyCEO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAcademyCEOFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAcademyCEOFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAcademyCEOClient<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAcademyCEO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademyCEOFindFirstArgs} args - Arguments to find a UserAcademyCEO
     * @example
     * // Get one UserAcademyCEO
     * const userAcademyCEO = await prisma.userAcademyCEO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAcademyCEOFindFirstArgs>(args?: SelectSubset<T, UserAcademyCEOFindFirstArgs<ExtArgs>>): Prisma__UserAcademyCEOClient<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAcademyCEO that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademyCEOFindFirstOrThrowArgs} args - Arguments to find a UserAcademyCEO
     * @example
     * // Get one UserAcademyCEO
     * const userAcademyCEO = await prisma.userAcademyCEO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAcademyCEOFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAcademyCEOFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAcademyCEOClient<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAcademyCEOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademyCEOFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAcademyCEOS
     * const userAcademyCEOS = await prisma.userAcademyCEO.findMany()
     * 
     * // Get first 10 UserAcademyCEOS
     * const userAcademyCEOS = await prisma.userAcademyCEO.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAcademyCEOWithIdOnly = await prisma.userAcademyCEO.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAcademyCEOFindManyArgs>(args?: SelectSubset<T, UserAcademyCEOFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAcademyCEO.
     * @param {UserAcademyCEOCreateArgs} args - Arguments to create a UserAcademyCEO.
     * @example
     * // Create one UserAcademyCEO
     * const UserAcademyCEO = await prisma.userAcademyCEO.create({
     *   data: {
     *     // ... data to create a UserAcademyCEO
     *   }
     * })
     * 
     */
    create<T extends UserAcademyCEOCreateArgs>(args: SelectSubset<T, UserAcademyCEOCreateArgs<ExtArgs>>): Prisma__UserAcademyCEOClient<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAcademyCEOS.
     * @param {UserAcademyCEOCreateManyArgs} args - Arguments to create many UserAcademyCEOS.
     * @example
     * // Create many UserAcademyCEOS
     * const userAcademyCEO = await prisma.userAcademyCEO.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAcademyCEOCreateManyArgs>(args?: SelectSubset<T, UserAcademyCEOCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAcademyCEOS and returns the data saved in the database.
     * @param {UserAcademyCEOCreateManyAndReturnArgs} args - Arguments to create many UserAcademyCEOS.
     * @example
     * // Create many UserAcademyCEOS
     * const userAcademyCEO = await prisma.userAcademyCEO.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAcademyCEOS and only return the `id`
     * const userAcademyCEOWithIdOnly = await prisma.userAcademyCEO.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAcademyCEOCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAcademyCEOCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAcademyCEO.
     * @param {UserAcademyCEODeleteArgs} args - Arguments to delete one UserAcademyCEO.
     * @example
     * // Delete one UserAcademyCEO
     * const UserAcademyCEO = await prisma.userAcademyCEO.delete({
     *   where: {
     *     // ... filter to delete one UserAcademyCEO
     *   }
     * })
     * 
     */
    delete<T extends UserAcademyCEODeleteArgs>(args: SelectSubset<T, UserAcademyCEODeleteArgs<ExtArgs>>): Prisma__UserAcademyCEOClient<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAcademyCEO.
     * @param {UserAcademyCEOUpdateArgs} args - Arguments to update one UserAcademyCEO.
     * @example
     * // Update one UserAcademyCEO
     * const userAcademyCEO = await prisma.userAcademyCEO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAcademyCEOUpdateArgs>(args: SelectSubset<T, UserAcademyCEOUpdateArgs<ExtArgs>>): Prisma__UserAcademyCEOClient<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAcademyCEOS.
     * @param {UserAcademyCEODeleteManyArgs} args - Arguments to filter UserAcademyCEOS to delete.
     * @example
     * // Delete a few UserAcademyCEOS
     * const { count } = await prisma.userAcademyCEO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAcademyCEODeleteManyArgs>(args?: SelectSubset<T, UserAcademyCEODeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAcademyCEOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademyCEOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAcademyCEOS
     * const userAcademyCEO = await prisma.userAcademyCEO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAcademyCEOUpdateManyArgs>(args: SelectSubset<T, UserAcademyCEOUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAcademyCEO.
     * @param {UserAcademyCEOUpsertArgs} args - Arguments to update or create a UserAcademyCEO.
     * @example
     * // Update or create a UserAcademyCEO
     * const userAcademyCEO = await prisma.userAcademyCEO.upsert({
     *   create: {
     *     // ... data to create a UserAcademyCEO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAcademyCEO we want to update
     *   }
     * })
     */
    upsert<T extends UserAcademyCEOUpsertArgs>(args: SelectSubset<T, UserAcademyCEOUpsertArgs<ExtArgs>>): Prisma__UserAcademyCEOClient<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAcademyCEOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademyCEOCountArgs} args - Arguments to filter UserAcademyCEOS to count.
     * @example
     * // Count the number of UserAcademyCEOS
     * const count = await prisma.userAcademyCEO.count({
     *   where: {
     *     // ... the filter for the UserAcademyCEOS we want to count
     *   }
     * })
    **/
    count<T extends UserAcademyCEOCountArgs>(
      args?: Subset<T, UserAcademyCEOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAcademyCEOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAcademyCEO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademyCEOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAcademyCEOAggregateArgs>(args: Subset<T, UserAcademyCEOAggregateArgs>): Prisma.PrismaPromise<GetUserAcademyCEOAggregateType<T>>

    /**
     * Group by UserAcademyCEO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAcademyCEOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAcademyCEOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAcademyCEOGroupByArgs['orderBy'] }
        : { orderBy?: UserAcademyCEOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAcademyCEOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAcademyCEOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAcademyCEO model
   */
  readonly fields: UserAcademyCEOFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAcademyCEO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAcademyCEOClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academy<T extends AcademyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademyDefaultArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAcademyCEO model
   */ 
  interface UserAcademyCEOFieldRefs {
    readonly id: FieldRef<"UserAcademyCEO", 'String'>
    readonly userId: FieldRef<"UserAcademyCEO", 'String'>
    readonly academyId: FieldRef<"UserAcademyCEO", 'String'>
    readonly createdAt: FieldRef<"UserAcademyCEO", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAcademyCEO", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAcademyCEO findUnique
   */
  export type UserAcademyCEOFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    /**
     * Filter, which UserAcademyCEO to fetch.
     */
    where: UserAcademyCEOWhereUniqueInput
  }

  /**
   * UserAcademyCEO findUniqueOrThrow
   */
  export type UserAcademyCEOFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    /**
     * Filter, which UserAcademyCEO to fetch.
     */
    where: UserAcademyCEOWhereUniqueInput
  }

  /**
   * UserAcademyCEO findFirst
   */
  export type UserAcademyCEOFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    /**
     * Filter, which UserAcademyCEO to fetch.
     */
    where?: UserAcademyCEOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAcademyCEOS to fetch.
     */
    orderBy?: UserAcademyCEOOrderByWithRelationInput | UserAcademyCEOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAcademyCEOS.
     */
    cursor?: UserAcademyCEOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAcademyCEOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAcademyCEOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAcademyCEOS.
     */
    distinct?: UserAcademyCEOScalarFieldEnum | UserAcademyCEOScalarFieldEnum[]
  }

  /**
   * UserAcademyCEO findFirstOrThrow
   */
  export type UserAcademyCEOFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    /**
     * Filter, which UserAcademyCEO to fetch.
     */
    where?: UserAcademyCEOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAcademyCEOS to fetch.
     */
    orderBy?: UserAcademyCEOOrderByWithRelationInput | UserAcademyCEOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAcademyCEOS.
     */
    cursor?: UserAcademyCEOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAcademyCEOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAcademyCEOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAcademyCEOS.
     */
    distinct?: UserAcademyCEOScalarFieldEnum | UserAcademyCEOScalarFieldEnum[]
  }

  /**
   * UserAcademyCEO findMany
   */
  export type UserAcademyCEOFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    /**
     * Filter, which UserAcademyCEOS to fetch.
     */
    where?: UserAcademyCEOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAcademyCEOS to fetch.
     */
    orderBy?: UserAcademyCEOOrderByWithRelationInput | UserAcademyCEOOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAcademyCEOS.
     */
    cursor?: UserAcademyCEOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAcademyCEOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAcademyCEOS.
     */
    skip?: number
    distinct?: UserAcademyCEOScalarFieldEnum | UserAcademyCEOScalarFieldEnum[]
  }

  /**
   * UserAcademyCEO create
   */
  export type UserAcademyCEOCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAcademyCEO.
     */
    data: XOR<UserAcademyCEOCreateInput, UserAcademyCEOUncheckedCreateInput>
  }

  /**
   * UserAcademyCEO createMany
   */
  export type UserAcademyCEOCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAcademyCEOS.
     */
    data: UserAcademyCEOCreateManyInput | UserAcademyCEOCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAcademyCEO createManyAndReturn
   */
  export type UserAcademyCEOCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAcademyCEOS.
     */
    data: UserAcademyCEOCreateManyInput | UserAcademyCEOCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAcademyCEO update
   */
  export type UserAcademyCEOUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAcademyCEO.
     */
    data: XOR<UserAcademyCEOUpdateInput, UserAcademyCEOUncheckedUpdateInput>
    /**
     * Choose, which UserAcademyCEO to update.
     */
    where: UserAcademyCEOWhereUniqueInput
  }

  /**
   * UserAcademyCEO updateMany
   */
  export type UserAcademyCEOUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAcademyCEOS.
     */
    data: XOR<UserAcademyCEOUpdateManyMutationInput, UserAcademyCEOUncheckedUpdateManyInput>
    /**
     * Filter which UserAcademyCEOS to update
     */
    where?: UserAcademyCEOWhereInput
  }

  /**
   * UserAcademyCEO upsert
   */
  export type UserAcademyCEOUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAcademyCEO to update in case it exists.
     */
    where: UserAcademyCEOWhereUniqueInput
    /**
     * In case the UserAcademyCEO found by the `where` argument doesn't exist, create a new UserAcademyCEO with this data.
     */
    create: XOR<UserAcademyCEOCreateInput, UserAcademyCEOUncheckedCreateInput>
    /**
     * In case the UserAcademyCEO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAcademyCEOUpdateInput, UserAcademyCEOUncheckedUpdateInput>
  }

  /**
   * UserAcademyCEO delete
   */
  export type UserAcademyCEODeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    /**
     * Filter which UserAcademyCEO to delete.
     */
    where: UserAcademyCEOWhereUniqueInput
  }

  /**
   * UserAcademyCEO deleteMany
   */
  export type UserAcademyCEODeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAcademyCEOS to delete
     */
    where?: UserAcademyCEOWhereInput
  }

  /**
   * UserAcademyCEO without action
   */
  export type UserAcademyCEODefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
  }


  /**
   * Model Academy
   */

  export type AggregateAcademy = {
    _count: AcademyCountAggregateOutputType | null
    _min: AcademyMinAggregateOutputType | null
    _max: AcademyMaxAggregateOutputType | null
  }

  export type AcademyMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    logo: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    logo?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Academy to aggregate.
     */
    where?: AcademyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Academies to fetch.
     */
    orderBy?: AcademyOrderByWithRelationInput | AcademyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Academies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Academies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Academies
    **/
    _count?: true | AcademyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademyMaxAggregateInputType
  }

  export type GetAcademyAggregateType<T extends AcademyAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademy[P]>
      : GetScalarType<T[P], AggregateAcademy[P]>
  }




  export type AcademyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademyWhereInput
    orderBy?: AcademyOrderByWithAggregationInput | AcademyOrderByWithAggregationInput[]
    by: AcademyScalarFieldEnum[] | AcademyScalarFieldEnum
    having?: AcademyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademyCountAggregateInputType | true
    _min?: AcademyMinAggregateInputType
    _max?: AcademyMaxAggregateInputType
  }

  export type AcademyGroupByOutputType = {
    id: string
    name: string
    description: string | null
    logo: string | null
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AcademyCountAggregateOutputType | null
    _min: AcademyMinAggregateOutputType | null
    _max: AcademyMaxAggregateOutputType | null
  }

  type GetAcademyGroupByPayload<T extends AcademyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademyGroupByOutputType[P]>
            : GetScalarType<T[P], AcademyGroupByOutputType[P]>
        }
      >
    >


  export type AcademySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Academy$usersArgs<ExtArgs>
    ceos?: boolean | Academy$ceosArgs<ExtArgs>
    courses?: boolean | Academy$coursesArgs<ExtArgs>
    instructors?: boolean | Academy$instructorsArgs<ExtArgs>
    events?: boolean | Academy$eventsArgs<ExtArgs>
    AccountingEntry?: boolean | Academy$AccountingEntryArgs<ExtArgs>
    PublicRelationsRecord?: boolean | Academy$PublicRelationsRecordArgs<ExtArgs>
    Meeting?: boolean | Academy$MeetingArgs<ExtArgs>
    LegalCase?: boolean | Academy$LegalCaseArgs<ExtArgs>
    _count?: boolean | AcademyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academy"]>

  export type AcademySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["academy"]>

  export type AcademySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    logo?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AcademyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Academy$usersArgs<ExtArgs>
    ceos?: boolean | Academy$ceosArgs<ExtArgs>
    courses?: boolean | Academy$coursesArgs<ExtArgs>
    instructors?: boolean | Academy$instructorsArgs<ExtArgs>
    events?: boolean | Academy$eventsArgs<ExtArgs>
    AccountingEntry?: boolean | Academy$AccountingEntryArgs<ExtArgs>
    PublicRelationsRecord?: boolean | Academy$PublicRelationsRecordArgs<ExtArgs>
    Meeting?: boolean | Academy$MeetingArgs<ExtArgs>
    LegalCase?: boolean | Academy$LegalCaseArgs<ExtArgs>
    _count?: boolean | AcademyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AcademyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Academy"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      ceos: Prisma.$UserAcademyCEOPayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      instructors: Prisma.$InstructorPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      AccountingEntry: Prisma.$AccountingEntryPayload<ExtArgs>[]
      PublicRelationsRecord: Prisma.$PublicRelationsRecordPayload<ExtArgs>[]
      Meeting: Prisma.$MeetingPayload<ExtArgs>[]
      LegalCase: Prisma.$LegalCasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      logo: string | null
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academy"]>
    composites: {}
  }

  type AcademyGetPayload<S extends boolean | null | undefined | AcademyDefaultArgs> = $Result.GetResult<Prisma.$AcademyPayload, S>

  type AcademyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcademyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcademyCountAggregateInputType | true
    }

  export interface AcademyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Academy'], meta: { name: 'Academy' } }
    /**
     * Find zero or one Academy that matches the filter.
     * @param {AcademyFindUniqueArgs} args - Arguments to find a Academy
     * @example
     * // Get one Academy
     * const academy = await prisma.academy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademyFindUniqueArgs>(args: SelectSubset<T, AcademyFindUniqueArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Academy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcademyFindUniqueOrThrowArgs} args - Arguments to find a Academy
     * @example
     * // Get one Academy
     * const academy = await prisma.academy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademyFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Academy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademyFindFirstArgs} args - Arguments to find a Academy
     * @example
     * // Get one Academy
     * const academy = await prisma.academy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademyFindFirstArgs>(args?: SelectSubset<T, AcademyFindFirstArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Academy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademyFindFirstOrThrowArgs} args - Arguments to find a Academy
     * @example
     * // Get one Academy
     * const academy = await prisma.academy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademyFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Academies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Academies
     * const academies = await prisma.academy.findMany()
     * 
     * // Get first 10 Academies
     * const academies = await prisma.academy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academyWithIdOnly = await prisma.academy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademyFindManyArgs>(args?: SelectSubset<T, AcademyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Academy.
     * @param {AcademyCreateArgs} args - Arguments to create a Academy.
     * @example
     * // Create one Academy
     * const Academy = await prisma.academy.create({
     *   data: {
     *     // ... data to create a Academy
     *   }
     * })
     * 
     */
    create<T extends AcademyCreateArgs>(args: SelectSubset<T, AcademyCreateArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Academies.
     * @param {AcademyCreateManyArgs} args - Arguments to create many Academies.
     * @example
     * // Create many Academies
     * const academy = await prisma.academy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademyCreateManyArgs>(args?: SelectSubset<T, AcademyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Academies and returns the data saved in the database.
     * @param {AcademyCreateManyAndReturnArgs} args - Arguments to create many Academies.
     * @example
     * // Create many Academies
     * const academy = await prisma.academy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Academies and only return the `id`
     * const academyWithIdOnly = await prisma.academy.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademyCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Academy.
     * @param {AcademyDeleteArgs} args - Arguments to delete one Academy.
     * @example
     * // Delete one Academy
     * const Academy = await prisma.academy.delete({
     *   where: {
     *     // ... filter to delete one Academy
     *   }
     * })
     * 
     */
    delete<T extends AcademyDeleteArgs>(args: SelectSubset<T, AcademyDeleteArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Academy.
     * @param {AcademyUpdateArgs} args - Arguments to update one Academy.
     * @example
     * // Update one Academy
     * const academy = await prisma.academy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademyUpdateArgs>(args: SelectSubset<T, AcademyUpdateArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Academies.
     * @param {AcademyDeleteManyArgs} args - Arguments to filter Academies to delete.
     * @example
     * // Delete a few Academies
     * const { count } = await prisma.academy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademyDeleteManyArgs>(args?: SelectSubset<T, AcademyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Academies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Academies
     * const academy = await prisma.academy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademyUpdateManyArgs>(args: SelectSubset<T, AcademyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Academy.
     * @param {AcademyUpsertArgs} args - Arguments to update or create a Academy.
     * @example
     * // Update or create a Academy
     * const academy = await prisma.academy.upsert({
     *   create: {
     *     // ... data to create a Academy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Academy we want to update
     *   }
     * })
     */
    upsert<T extends AcademyUpsertArgs>(args: SelectSubset<T, AcademyUpsertArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Academies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademyCountArgs} args - Arguments to filter Academies to count.
     * @example
     * // Count the number of Academies
     * const count = await prisma.academy.count({
     *   where: {
     *     // ... the filter for the Academies we want to count
     *   }
     * })
    **/
    count<T extends AcademyCountArgs>(
      args?: Subset<T, AcademyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Academy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademyAggregateArgs>(args: Subset<T, AcademyAggregateArgs>): Prisma.PrismaPromise<GetAcademyAggregateType<T>>

    /**
     * Group by Academy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademyGroupByArgs['orderBy'] }
        : { orderBy?: AcademyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Academy model
   */
  readonly fields: AcademyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Academy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Academy$usersArgs<ExtArgs> = {}>(args?: Subset<T, Academy$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    ceos<T extends Academy$ceosArgs<ExtArgs> = {}>(args?: Subset<T, Academy$ceosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAcademyCEOPayload<ExtArgs>, T, "findMany"> | Null>
    courses<T extends Academy$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Academy$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    instructors<T extends Academy$instructorsArgs<ExtArgs> = {}>(args?: Subset<T, Academy$instructorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends Academy$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Academy$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    AccountingEntry<T extends Academy$AccountingEntryArgs<ExtArgs> = {}>(args?: Subset<T, Academy$AccountingEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findMany"> | Null>
    PublicRelationsRecord<T extends Academy$PublicRelationsRecordArgs<ExtArgs> = {}>(args?: Subset<T, Academy$PublicRelationsRecordArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findMany"> | Null>
    Meeting<T extends Academy$MeetingArgs<ExtArgs> = {}>(args?: Subset<T, Academy$MeetingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany"> | Null>
    LegalCase<T extends Academy$LegalCaseArgs<ExtArgs> = {}>(args?: Subset<T, Academy$LegalCaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Academy model
   */ 
  interface AcademyFieldRefs {
    readonly id: FieldRef<"Academy", 'String'>
    readonly name: FieldRef<"Academy", 'String'>
    readonly description: FieldRef<"Academy", 'String'>
    readonly logo: FieldRef<"Academy", 'String'>
    readonly settings: FieldRef<"Academy", 'Json'>
    readonly createdAt: FieldRef<"Academy", 'DateTime'>
    readonly updatedAt: FieldRef<"Academy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Academy findUnique
   */
  export type AcademyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
    /**
     * Filter, which Academy to fetch.
     */
    where: AcademyWhereUniqueInput
  }

  /**
   * Academy findUniqueOrThrow
   */
  export type AcademyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
    /**
     * Filter, which Academy to fetch.
     */
    where: AcademyWhereUniqueInput
  }

  /**
   * Academy findFirst
   */
  export type AcademyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
    /**
     * Filter, which Academy to fetch.
     */
    where?: AcademyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Academies to fetch.
     */
    orderBy?: AcademyOrderByWithRelationInput | AcademyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Academies.
     */
    cursor?: AcademyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Academies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Academies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Academies.
     */
    distinct?: AcademyScalarFieldEnum | AcademyScalarFieldEnum[]
  }

  /**
   * Academy findFirstOrThrow
   */
  export type AcademyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
    /**
     * Filter, which Academy to fetch.
     */
    where?: AcademyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Academies to fetch.
     */
    orderBy?: AcademyOrderByWithRelationInput | AcademyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Academies.
     */
    cursor?: AcademyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Academies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Academies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Academies.
     */
    distinct?: AcademyScalarFieldEnum | AcademyScalarFieldEnum[]
  }

  /**
   * Academy findMany
   */
  export type AcademyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
    /**
     * Filter, which Academies to fetch.
     */
    where?: AcademyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Academies to fetch.
     */
    orderBy?: AcademyOrderByWithRelationInput | AcademyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Academies.
     */
    cursor?: AcademyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Academies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Academies.
     */
    skip?: number
    distinct?: AcademyScalarFieldEnum | AcademyScalarFieldEnum[]
  }

  /**
   * Academy create
   */
  export type AcademyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
    /**
     * The data needed to create a Academy.
     */
    data: XOR<AcademyCreateInput, AcademyUncheckedCreateInput>
  }

  /**
   * Academy createMany
   */
  export type AcademyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Academies.
     */
    data: AcademyCreateManyInput | AcademyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Academy createManyAndReturn
   */
  export type AcademyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Academies.
     */
    data: AcademyCreateManyInput | AcademyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Academy update
   */
  export type AcademyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
    /**
     * The data needed to update a Academy.
     */
    data: XOR<AcademyUpdateInput, AcademyUncheckedUpdateInput>
    /**
     * Choose, which Academy to update.
     */
    where: AcademyWhereUniqueInput
  }

  /**
   * Academy updateMany
   */
  export type AcademyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Academies.
     */
    data: XOR<AcademyUpdateManyMutationInput, AcademyUncheckedUpdateManyInput>
    /**
     * Filter which Academies to update
     */
    where?: AcademyWhereInput
  }

  /**
   * Academy upsert
   */
  export type AcademyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
    /**
     * The filter to search for the Academy to update in case it exists.
     */
    where: AcademyWhereUniqueInput
    /**
     * In case the Academy found by the `where` argument doesn't exist, create a new Academy with this data.
     */
    create: XOR<AcademyCreateInput, AcademyUncheckedCreateInput>
    /**
     * In case the Academy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademyUpdateInput, AcademyUncheckedUpdateInput>
  }

  /**
   * Academy delete
   */
  export type AcademyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
    /**
     * Filter which Academy to delete.
     */
    where: AcademyWhereUniqueInput
  }

  /**
   * Academy deleteMany
   */
  export type AcademyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Academies to delete
     */
    where?: AcademyWhereInput
  }

  /**
   * Academy.users
   */
  export type Academy$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Academy.ceos
   */
  export type Academy$ceosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAcademyCEO
     */
    select?: UserAcademyCEOSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAcademyCEOInclude<ExtArgs> | null
    where?: UserAcademyCEOWhereInput
    orderBy?: UserAcademyCEOOrderByWithRelationInput | UserAcademyCEOOrderByWithRelationInput[]
    cursor?: UserAcademyCEOWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAcademyCEOScalarFieldEnum | UserAcademyCEOScalarFieldEnum[]
  }

  /**
   * Academy.courses
   */
  export type Academy$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Academy.instructors
   */
  export type Academy$instructorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    where?: InstructorWhereInput
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    cursor?: InstructorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Academy.events
   */
  export type Academy$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Academy.AccountingEntry
   */
  export type Academy$AccountingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    where?: AccountingEntryWhereInput
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    cursor?: AccountingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountingEntryScalarFieldEnum | AccountingEntryScalarFieldEnum[]
  }

  /**
   * Academy.PublicRelationsRecord
   */
  export type Academy$PublicRelationsRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    where?: PublicRelationsRecordWhereInput
    orderBy?: PublicRelationsRecordOrderByWithRelationInput | PublicRelationsRecordOrderByWithRelationInput[]
    cursor?: PublicRelationsRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicRelationsRecordScalarFieldEnum | PublicRelationsRecordScalarFieldEnum[]
  }

  /**
   * Academy.Meeting
   */
  export type Academy$MeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Academy.LegalCase
   */
  export type Academy$LegalCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    where?: LegalCaseWhereInput
    orderBy?: LegalCaseOrderByWithRelationInput | LegalCaseOrderByWithRelationInput[]
    cursor?: LegalCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LegalCaseScalarFieldEnum | LegalCaseScalarFieldEnum[]
  }

  /**
   * Academy without action
   */
  export type AcademyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Academy
     */
    select?: AcademySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademyInclude<ExtArgs> | null
  }


  /**
   * Model Instructor
   */

  export type AggregateInstructor = {
    _count: InstructorCountAggregateOutputType | null
    _min: InstructorMinAggregateOutputType | null
    _max: InstructorMaxAggregateOutputType | null
  }

  export type InstructorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    academyId: string | null
  }

  export type InstructorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    academyId: string | null
  }

  export type InstructorCountAggregateOutputType = {
    id: number
    userId: number
    academyId: number
    _all: number
  }


  export type InstructorMinAggregateInputType = {
    id?: true
    userId?: true
    academyId?: true
  }

  export type InstructorMaxAggregateInputType = {
    id?: true
    userId?: true
    academyId?: true
  }

  export type InstructorCountAggregateInputType = {
    id?: true
    userId?: true
    academyId?: true
    _all?: true
  }

  export type InstructorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instructor to aggregate.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instructors
    **/
    _count?: true | InstructorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstructorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstructorMaxAggregateInputType
  }

  export type GetInstructorAggregateType<T extends InstructorAggregateArgs> = {
        [P in keyof T & keyof AggregateInstructor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstructor[P]>
      : GetScalarType<T[P], AggregateInstructor[P]>
  }




  export type InstructorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorWhereInput
    orderBy?: InstructorOrderByWithAggregationInput | InstructorOrderByWithAggregationInput[]
    by: InstructorScalarFieldEnum[] | InstructorScalarFieldEnum
    having?: InstructorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstructorCountAggregateInputType | true
    _min?: InstructorMinAggregateInputType
    _max?: InstructorMaxAggregateInputType
  }

  export type InstructorGroupByOutputType = {
    id: string
    userId: string
    academyId: string
    _count: InstructorCountAggregateOutputType | null
    _min: InstructorMinAggregateOutputType | null
    _max: InstructorMaxAggregateOutputType | null
  }

  type GetInstructorGroupByPayload<T extends InstructorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstructorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstructorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstructorGroupByOutputType[P]>
            : GetScalarType<T[P], InstructorGroupByOutputType[P]>
        }
      >
    >


  export type InstructorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    academyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    courses?: boolean | Instructor$coursesArgs<ExtArgs>
    _count?: boolean | InstructorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructor"]>

  export type InstructorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    academyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructor"]>

  export type InstructorSelectScalar = {
    id?: boolean
    userId?: boolean
    academyId?: boolean
  }

  export type InstructorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    courses?: boolean | Instructor$coursesArgs<ExtArgs>
    _count?: boolean | InstructorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstructorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }

  export type $InstructorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instructor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      academy: Prisma.$AcademyPayload<ExtArgs>
      courses: Prisma.$CoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      academyId: string
    }, ExtArgs["result"]["instructor"]>
    composites: {}
  }

  type InstructorGetPayload<S extends boolean | null | undefined | InstructorDefaultArgs> = $Result.GetResult<Prisma.$InstructorPayload, S>

  type InstructorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstructorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstructorCountAggregateInputType | true
    }

  export interface InstructorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instructor'], meta: { name: 'Instructor' } }
    /**
     * Find zero or one Instructor that matches the filter.
     * @param {InstructorFindUniqueArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstructorFindUniqueArgs>(args: SelectSubset<T, InstructorFindUniqueArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Instructor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InstructorFindUniqueOrThrowArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstructorFindUniqueOrThrowArgs>(args: SelectSubset<T, InstructorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Instructor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorFindFirstArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstructorFindFirstArgs>(args?: SelectSubset<T, InstructorFindFirstArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Instructor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorFindFirstOrThrowArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstructorFindFirstOrThrowArgs>(args?: SelectSubset<T, InstructorFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Instructors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instructors
     * const instructors = await prisma.instructor.findMany()
     * 
     * // Get first 10 Instructors
     * const instructors = await prisma.instructor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instructorWithIdOnly = await prisma.instructor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstructorFindManyArgs>(args?: SelectSubset<T, InstructorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Instructor.
     * @param {InstructorCreateArgs} args - Arguments to create a Instructor.
     * @example
     * // Create one Instructor
     * const Instructor = await prisma.instructor.create({
     *   data: {
     *     // ... data to create a Instructor
     *   }
     * })
     * 
     */
    create<T extends InstructorCreateArgs>(args: SelectSubset<T, InstructorCreateArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Instructors.
     * @param {InstructorCreateManyArgs} args - Arguments to create many Instructors.
     * @example
     * // Create many Instructors
     * const instructor = await prisma.instructor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstructorCreateManyArgs>(args?: SelectSubset<T, InstructorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instructors and returns the data saved in the database.
     * @param {InstructorCreateManyAndReturnArgs} args - Arguments to create many Instructors.
     * @example
     * // Create many Instructors
     * const instructor = await prisma.instructor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instructors and only return the `id`
     * const instructorWithIdOnly = await prisma.instructor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstructorCreateManyAndReturnArgs>(args?: SelectSubset<T, InstructorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Instructor.
     * @param {InstructorDeleteArgs} args - Arguments to delete one Instructor.
     * @example
     * // Delete one Instructor
     * const Instructor = await prisma.instructor.delete({
     *   where: {
     *     // ... filter to delete one Instructor
     *   }
     * })
     * 
     */
    delete<T extends InstructorDeleteArgs>(args: SelectSubset<T, InstructorDeleteArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Instructor.
     * @param {InstructorUpdateArgs} args - Arguments to update one Instructor.
     * @example
     * // Update one Instructor
     * const instructor = await prisma.instructor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstructorUpdateArgs>(args: SelectSubset<T, InstructorUpdateArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Instructors.
     * @param {InstructorDeleteManyArgs} args - Arguments to filter Instructors to delete.
     * @example
     * // Delete a few Instructors
     * const { count } = await prisma.instructor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstructorDeleteManyArgs>(args?: SelectSubset<T, InstructorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instructors
     * const instructor = await prisma.instructor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstructorUpdateManyArgs>(args: SelectSubset<T, InstructorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instructor.
     * @param {InstructorUpsertArgs} args - Arguments to update or create a Instructor.
     * @example
     * // Update or create a Instructor
     * const instructor = await prisma.instructor.upsert({
     *   create: {
     *     // ... data to create a Instructor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instructor we want to update
     *   }
     * })
     */
    upsert<T extends InstructorUpsertArgs>(args: SelectSubset<T, InstructorUpsertArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Instructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorCountArgs} args - Arguments to filter Instructors to count.
     * @example
     * // Count the number of Instructors
     * const count = await prisma.instructor.count({
     *   where: {
     *     // ... the filter for the Instructors we want to count
     *   }
     * })
    **/
    count<T extends InstructorCountArgs>(
      args?: Subset<T, InstructorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstructorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstructorAggregateArgs>(args: Subset<T, InstructorAggregateArgs>): Prisma.PrismaPromise<GetInstructorAggregateType<T>>

    /**
     * Group by Instructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstructorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstructorGroupByArgs['orderBy'] }
        : { orderBy?: InstructorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstructorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instructor model
   */
  readonly fields: InstructorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instructor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstructorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academy<T extends AcademyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademyDefaultArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    courses<T extends Instructor$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Instructor$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instructor model
   */ 
  interface InstructorFieldRefs {
    readonly id: FieldRef<"Instructor", 'String'>
    readonly userId: FieldRef<"Instructor", 'String'>
    readonly academyId: FieldRef<"Instructor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Instructor findUnique
   */
  export type InstructorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor findUniqueOrThrow
   */
  export type InstructorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor findFirst
   */
  export type InstructorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instructors.
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instructors.
     */
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Instructor findFirstOrThrow
   */
  export type InstructorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instructors.
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instructors.
     */
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Instructor findMany
   */
  export type InstructorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructors to fetch.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instructors.
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Instructor create
   */
  export type InstructorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * The data needed to create a Instructor.
     */
    data: XOR<InstructorCreateInput, InstructorUncheckedCreateInput>
  }

  /**
   * Instructor createMany
   */
  export type InstructorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instructors.
     */
    data: InstructorCreateManyInput | InstructorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instructor createManyAndReturn
   */
  export type InstructorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Instructors.
     */
    data: InstructorCreateManyInput | InstructorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instructor update
   */
  export type InstructorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * The data needed to update a Instructor.
     */
    data: XOR<InstructorUpdateInput, InstructorUncheckedUpdateInput>
    /**
     * Choose, which Instructor to update.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor updateMany
   */
  export type InstructorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instructors.
     */
    data: XOR<InstructorUpdateManyMutationInput, InstructorUncheckedUpdateManyInput>
    /**
     * Filter which Instructors to update
     */
    where?: InstructorWhereInput
  }

  /**
   * Instructor upsert
   */
  export type InstructorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * The filter to search for the Instructor to update in case it exists.
     */
    where: InstructorWhereUniqueInput
    /**
     * In case the Instructor found by the `where` argument doesn't exist, create a new Instructor with this data.
     */
    create: XOR<InstructorCreateInput, InstructorUncheckedCreateInput>
    /**
     * In case the Instructor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstructorUpdateInput, InstructorUncheckedUpdateInput>
  }

  /**
   * Instructor delete
   */
  export type InstructorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter which Instructor to delete.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor deleteMany
   */
  export type InstructorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instructors to delete
     */
    where?: InstructorWhereInput
  }

  /**
   * Instructor.courses
   */
  export type Instructor$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Instructor without action
   */
  export type InstructorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    academyId: string | null
    image: string | null
    level: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.CourseStatus | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    academyId: string | null
    image: string | null
    level: string | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.CourseStatus | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    academyId: number
    image: number
    level: number
    createdAt: number
    updatedAt: number
    status: number
    _all: number
  }


  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academyId?: true
    image?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academyId?: true
    image?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    status?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    academyId?: true
    image?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    description: string
    academyId: string
    image: string | null
    level: string
    createdAt: Date
    updatedAt: Date
    status: $Enums.CourseStatus
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    academyId?: boolean
    image?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    lessons?: boolean | Course$lessonsArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    quizzes?: boolean | Course$quizzesArgs<ExtArgs>
    instructors?: boolean | Course$instructorsArgs<ExtArgs>
    liveRoom?: boolean | Course$liveRoomArgs<ExtArgs>
    Path?: boolean | Course$PathArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    academyId?: boolean
    image?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    academyId?: boolean
    image?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    lessons?: boolean | Course$lessonsArgs<ExtArgs>
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    quizzes?: boolean | Course$quizzesArgs<ExtArgs>
    instructors?: boolean | Course$instructorsArgs<ExtArgs>
    liveRoom?: boolean | Course$liveRoomArgs<ExtArgs>
    Path?: boolean | Course$PathArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      academy: Prisma.$AcademyPayload<ExtArgs>
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      instructors: Prisma.$InstructorPayload<ExtArgs>[]
      liveRoom: Prisma.$LiveRoomPayload<ExtArgs>[]
      Path: Prisma.$PathPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      academyId: string
      image: string | null
      level: string
      createdAt: Date
      updatedAt: Date
      status: $Enums.CourseStatus
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academy<T extends AcademyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademyDefaultArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lessons<T extends Course$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Course$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany"> | Null>
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    quizzes<T extends Course$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Course$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany"> | Null>
    instructors<T extends Course$instructorsArgs<ExtArgs> = {}>(args?: Subset<T, Course$instructorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findMany"> | Null>
    liveRoom<T extends Course$liveRoomArgs<ExtArgs> = {}>(args?: Subset<T, Course$liveRoomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "findMany"> | Null>
    Path<T extends Course$PathArgs<ExtArgs> = {}>(args?: Subset<T, Course$PathArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly academyId: FieldRef<"Course", 'String'>
    readonly image: FieldRef<"Course", 'String'>
    readonly level: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
    readonly status: FieldRef<"Course", 'CourseStatus'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.lessons
   */
  export type Course$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Course.quizzes
   */
  export type Course$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Course.instructors
   */
  export type Course$instructorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    where?: InstructorWhereInput
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    cursor?: InstructorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Course.liveRoom
   */
  export type Course$liveRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    where?: LiveRoomWhereInput
    orderBy?: LiveRoomOrderByWithRelationInput | LiveRoomOrderByWithRelationInput[]
    cursor?: LiveRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiveRoomScalarFieldEnum | LiveRoomScalarFieldEnum[]
  }

  /**
   * Course.Path
   */
  export type Course$PathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    where?: PathWhereInput
    orderBy?: PathOrderByWithRelationInput | PathOrderByWithRelationInput[]
    cursor?: PathWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PathScalarFieldEnum | PathScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Path
   */

  export type AggregatePath = {
    _count: PathCountAggregateOutputType | null
    _avg: PathAvgAggregateOutputType | null
    _sum: PathSumAggregateOutputType | null
    _min: PathMinAggregateOutputType | null
    _max: PathMaxAggregateOutputType | null
  }

  export type PathAvgAggregateOutputType = {
    completedTasks: number | null
    remainingTime: number | null
    studyTime: number | null
    totalTasks: number | null
    progress: number | null
    engagement: number | null
  }

  export type PathSumAggregateOutputType = {
    completedTasks: number | null
    remainingTime: number | null
    studyTime: number | null
    totalTasks: number | null
    progress: number | null
    engagement: number | null
  }

  export type PathMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    level: string | null
    completedTasks: number | null
    remainingTime: number | null
    studyTime: number | null
    totalTasks: number | null
    progress: number | null
    engagement: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PathMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    level: string | null
    completedTasks: number | null
    remainingTime: number | null
    studyTime: number | null
    totalTasks: number | null
    progress: number | null
    engagement: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PathCountAggregateOutputType = {
    id: number
    title: number
    description: number
    level: number
    completedTasks: number
    remainingTime: number
    studyTime: number
    totalTasks: number
    progress: number
    engagement: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PathAvgAggregateInputType = {
    completedTasks?: true
    remainingTime?: true
    studyTime?: true
    totalTasks?: true
    progress?: true
    engagement?: true
  }

  export type PathSumAggregateInputType = {
    completedTasks?: true
    remainingTime?: true
    studyTime?: true
    totalTasks?: true
    progress?: true
    engagement?: true
  }

  export type PathMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    completedTasks?: true
    remainingTime?: true
    studyTime?: true
    totalTasks?: true
    progress?: true
    engagement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PathMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    completedTasks?: true
    remainingTime?: true
    studyTime?: true
    totalTasks?: true
    progress?: true
    engagement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PathCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    completedTasks?: true
    remainingTime?: true
    studyTime?: true
    totalTasks?: true
    progress?: true
    engagement?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PathAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Path to aggregate.
     */
    where?: PathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paths to fetch.
     */
    orderBy?: PathOrderByWithRelationInput | PathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Paths
    **/
    _count?: true | PathCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PathAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PathSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PathMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PathMaxAggregateInputType
  }

  export type GetPathAggregateType<T extends PathAggregateArgs> = {
        [P in keyof T & keyof AggregatePath]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePath[P]>
      : GetScalarType<T[P], AggregatePath[P]>
  }




  export type PathGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PathWhereInput
    orderBy?: PathOrderByWithAggregationInput | PathOrderByWithAggregationInput[]
    by: PathScalarFieldEnum[] | PathScalarFieldEnum
    having?: PathScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PathCountAggregateInputType | true
    _avg?: PathAvgAggregateInputType
    _sum?: PathSumAggregateInputType
    _min?: PathMinAggregateInputType
    _max?: PathMaxAggregateInputType
  }

  export type PathGroupByOutputType = {
    id: string
    title: string
    description: string | null
    level: string
    completedTasks: number
    remainingTime: number
    studyTime: number
    totalTasks: number
    progress: number
    engagement: number
    createdAt: Date
    updatedAt: Date
    _count: PathCountAggregateOutputType | null
    _avg: PathAvgAggregateOutputType | null
    _sum: PathSumAggregateOutputType | null
    _min: PathMinAggregateOutputType | null
    _max: PathMaxAggregateOutputType | null
  }

  type GetPathGroupByPayload<T extends PathGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PathGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PathGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PathGroupByOutputType[P]>
            : GetScalarType<T[P], PathGroupByOutputType[P]>
        }
      >
    >


  export type PathSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    completedTasks?: boolean
    remainingTime?: boolean
    studyTime?: boolean
    totalTasks?: boolean
    progress?: boolean
    engagement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestones?: boolean | Path$milestonesArgs<ExtArgs>
    courses?: boolean | Path$coursesArgs<ExtArgs>
    peers?: boolean | Path$peersArgs<ExtArgs>
    _count?: boolean | PathCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["path"]>

  export type PathSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    completedTasks?: boolean
    remainingTime?: boolean
    studyTime?: boolean
    totalTasks?: boolean
    progress?: boolean
    engagement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["path"]>

  export type PathSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    completedTasks?: boolean
    remainingTime?: boolean
    studyTime?: boolean
    totalTasks?: boolean
    progress?: boolean
    engagement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PathInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestones?: boolean | Path$milestonesArgs<ExtArgs>
    courses?: boolean | Path$coursesArgs<ExtArgs>
    peers?: boolean | Path$peersArgs<ExtArgs>
    _count?: boolean | PathCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PathIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PathPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Path"
    objects: {
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      peers: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      level: string
      completedTasks: number
      remainingTime: number
      studyTime: number
      totalTasks: number
      progress: number
      engagement: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["path"]>
    composites: {}
  }

  type PathGetPayload<S extends boolean | null | undefined | PathDefaultArgs> = $Result.GetResult<Prisma.$PathPayload, S>

  type PathCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PathFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PathCountAggregateInputType | true
    }

  export interface PathDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Path'], meta: { name: 'Path' } }
    /**
     * Find zero or one Path that matches the filter.
     * @param {PathFindUniqueArgs} args - Arguments to find a Path
     * @example
     * // Get one Path
     * const path = await prisma.path.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PathFindUniqueArgs>(args: SelectSubset<T, PathFindUniqueArgs<ExtArgs>>): Prisma__PathClient<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Path that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PathFindUniqueOrThrowArgs} args - Arguments to find a Path
     * @example
     * // Get one Path
     * const path = await prisma.path.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PathFindUniqueOrThrowArgs>(args: SelectSubset<T, PathFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PathClient<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Path that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathFindFirstArgs} args - Arguments to find a Path
     * @example
     * // Get one Path
     * const path = await prisma.path.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PathFindFirstArgs>(args?: SelectSubset<T, PathFindFirstArgs<ExtArgs>>): Prisma__PathClient<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Path that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathFindFirstOrThrowArgs} args - Arguments to find a Path
     * @example
     * // Get one Path
     * const path = await prisma.path.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PathFindFirstOrThrowArgs>(args?: SelectSubset<T, PathFindFirstOrThrowArgs<ExtArgs>>): Prisma__PathClient<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Paths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paths
     * const paths = await prisma.path.findMany()
     * 
     * // Get first 10 Paths
     * const paths = await prisma.path.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pathWithIdOnly = await prisma.path.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PathFindManyArgs>(args?: SelectSubset<T, PathFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Path.
     * @param {PathCreateArgs} args - Arguments to create a Path.
     * @example
     * // Create one Path
     * const Path = await prisma.path.create({
     *   data: {
     *     // ... data to create a Path
     *   }
     * })
     * 
     */
    create<T extends PathCreateArgs>(args: SelectSubset<T, PathCreateArgs<ExtArgs>>): Prisma__PathClient<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Paths.
     * @param {PathCreateManyArgs} args - Arguments to create many Paths.
     * @example
     * // Create many Paths
     * const path = await prisma.path.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PathCreateManyArgs>(args?: SelectSubset<T, PathCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paths and returns the data saved in the database.
     * @param {PathCreateManyAndReturnArgs} args - Arguments to create many Paths.
     * @example
     * // Create many Paths
     * const path = await prisma.path.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paths and only return the `id`
     * const pathWithIdOnly = await prisma.path.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PathCreateManyAndReturnArgs>(args?: SelectSubset<T, PathCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Path.
     * @param {PathDeleteArgs} args - Arguments to delete one Path.
     * @example
     * // Delete one Path
     * const Path = await prisma.path.delete({
     *   where: {
     *     // ... filter to delete one Path
     *   }
     * })
     * 
     */
    delete<T extends PathDeleteArgs>(args: SelectSubset<T, PathDeleteArgs<ExtArgs>>): Prisma__PathClient<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Path.
     * @param {PathUpdateArgs} args - Arguments to update one Path.
     * @example
     * // Update one Path
     * const path = await prisma.path.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PathUpdateArgs>(args: SelectSubset<T, PathUpdateArgs<ExtArgs>>): Prisma__PathClient<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Paths.
     * @param {PathDeleteManyArgs} args - Arguments to filter Paths to delete.
     * @example
     * // Delete a few Paths
     * const { count } = await prisma.path.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PathDeleteManyArgs>(args?: SelectSubset<T, PathDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paths
     * const path = await prisma.path.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PathUpdateManyArgs>(args: SelectSubset<T, PathUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Path.
     * @param {PathUpsertArgs} args - Arguments to update or create a Path.
     * @example
     * // Update or create a Path
     * const path = await prisma.path.upsert({
     *   create: {
     *     // ... data to create a Path
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Path we want to update
     *   }
     * })
     */
    upsert<T extends PathUpsertArgs>(args: SelectSubset<T, PathUpsertArgs<ExtArgs>>): Prisma__PathClient<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Paths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathCountArgs} args - Arguments to filter Paths to count.
     * @example
     * // Count the number of Paths
     * const count = await prisma.path.count({
     *   where: {
     *     // ... the filter for the Paths we want to count
     *   }
     * })
    **/
    count<T extends PathCountArgs>(
      args?: Subset<T, PathCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PathCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Path.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PathAggregateArgs>(args: Subset<T, PathAggregateArgs>): Prisma.PrismaPromise<GetPathAggregateType<T>>

    /**
     * Group by Path.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PathGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PathGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PathGroupByArgs['orderBy'] }
        : { orderBy?: PathGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PathGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPathGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Path model
   */
  readonly fields: PathFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Path.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PathClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    milestones<T extends Path$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Path$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany"> | Null>
    courses<T extends Path$coursesArgs<ExtArgs> = {}>(args?: Subset<T, Path$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    peers<T extends Path$peersArgs<ExtArgs> = {}>(args?: Subset<T, Path$peersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Path model
   */ 
  interface PathFieldRefs {
    readonly id: FieldRef<"Path", 'String'>
    readonly title: FieldRef<"Path", 'String'>
    readonly description: FieldRef<"Path", 'String'>
    readonly level: FieldRef<"Path", 'String'>
    readonly completedTasks: FieldRef<"Path", 'Int'>
    readonly remainingTime: FieldRef<"Path", 'Int'>
    readonly studyTime: FieldRef<"Path", 'Int'>
    readonly totalTasks: FieldRef<"Path", 'Int'>
    readonly progress: FieldRef<"Path", 'Float'>
    readonly engagement: FieldRef<"Path", 'Float'>
    readonly createdAt: FieldRef<"Path", 'DateTime'>
    readonly updatedAt: FieldRef<"Path", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Path findUnique
   */
  export type PathFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    /**
     * Filter, which Path to fetch.
     */
    where: PathWhereUniqueInput
  }

  /**
   * Path findUniqueOrThrow
   */
  export type PathFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    /**
     * Filter, which Path to fetch.
     */
    where: PathWhereUniqueInput
  }

  /**
   * Path findFirst
   */
  export type PathFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    /**
     * Filter, which Path to fetch.
     */
    where?: PathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paths to fetch.
     */
    orderBy?: PathOrderByWithRelationInput | PathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paths.
     */
    cursor?: PathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paths.
     */
    distinct?: PathScalarFieldEnum | PathScalarFieldEnum[]
  }

  /**
   * Path findFirstOrThrow
   */
  export type PathFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    /**
     * Filter, which Path to fetch.
     */
    where?: PathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paths to fetch.
     */
    orderBy?: PathOrderByWithRelationInput | PathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paths.
     */
    cursor?: PathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paths.
     */
    distinct?: PathScalarFieldEnum | PathScalarFieldEnum[]
  }

  /**
   * Path findMany
   */
  export type PathFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    /**
     * Filter, which Paths to fetch.
     */
    where?: PathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paths to fetch.
     */
    orderBy?: PathOrderByWithRelationInput | PathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Paths.
     */
    cursor?: PathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paths.
     */
    skip?: number
    distinct?: PathScalarFieldEnum | PathScalarFieldEnum[]
  }

  /**
   * Path create
   */
  export type PathCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    /**
     * The data needed to create a Path.
     */
    data: XOR<PathCreateInput, PathUncheckedCreateInput>
  }

  /**
   * Path createMany
   */
  export type PathCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Paths.
     */
    data: PathCreateManyInput | PathCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Path createManyAndReturn
   */
  export type PathCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Paths.
     */
    data: PathCreateManyInput | PathCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Path update
   */
  export type PathUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    /**
     * The data needed to update a Path.
     */
    data: XOR<PathUpdateInput, PathUncheckedUpdateInput>
    /**
     * Choose, which Path to update.
     */
    where: PathWhereUniqueInput
  }

  /**
   * Path updateMany
   */
  export type PathUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Paths.
     */
    data: XOR<PathUpdateManyMutationInput, PathUncheckedUpdateManyInput>
    /**
     * Filter which Paths to update
     */
    where?: PathWhereInput
  }

  /**
   * Path upsert
   */
  export type PathUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    /**
     * The filter to search for the Path to update in case it exists.
     */
    where: PathWhereUniqueInput
    /**
     * In case the Path found by the `where` argument doesn't exist, create a new Path with this data.
     */
    create: XOR<PathCreateInput, PathUncheckedCreateInput>
    /**
     * In case the Path was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PathUpdateInput, PathUncheckedUpdateInput>
  }

  /**
   * Path delete
   */
  export type PathDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
    /**
     * Filter which Path to delete.
     */
    where: PathWhereUniqueInput
  }

  /**
   * Path deleteMany
   */
  export type PathDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paths to delete
     */
    where?: PathWhereInput
  }

  /**
   * Path.milestones
   */
  export type Path$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Path.courses
   */
  export type Path$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Path.peers
   */
  export type Path$peersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Path without action
   */
  export type PathDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Path
     */
    select?: PathSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PathInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.MilestoneStatus | null
    pathId: string | null
    createdAt: Date | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.MilestoneStatus | null
    pathId: string | null
    createdAt: Date | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    pathId: number
    createdAt: number
    _all: number
  }


  export type MilestoneMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    pathId?: true
    createdAt?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    pathId?: true
    createdAt?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    pathId?: true
    createdAt?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.MilestoneStatus
    pathId: string
    createdAt: Date
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    pathId?: boolean
    createdAt?: boolean
    path?: boolean | PathDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    pathId?: boolean
    createdAt?: boolean
    path?: boolean | PathDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    pathId?: boolean
    createdAt?: boolean
  }

  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    path?: boolean | PathDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    path?: boolean | PathDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      path: Prisma.$PathPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.MilestoneStatus
      pathId: string
      createdAt: Date
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Milestones and returns the data saved in the database.
     * @param {MilestoneCreateManyAndReturnArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, MilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    path<T extends PathDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PathDefaultArgs<ExtArgs>>): Prisma__PathClient<$Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */ 
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly title: FieldRef<"Milestone", 'String'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly status: FieldRef<"Milestone", 'MilestoneStatus'>
    readonly pathId: FieldRef<"Milestone", 'String'>
    readonly createdAt: FieldRef<"Milestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Milestone createManyAndReturn
   */
  export type MilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    courseId: string | null
    status: $Enums.LessonStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    courseId: string | null
    status: $Enums.LessonStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    title: number
    content: number
    courseId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LessonMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    courseId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    courseId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    courseId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    title: string
    content: string
    courseId: string
    status: $Enums.LessonStatus
    createdAt: Date
    updatedAt: Date
    _count: LessonCountAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    courseId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    files?: boolean | Lesson$filesArgs<ExtArgs>
    quizzes?: boolean | Lesson$quizzesArgs<ExtArgs>
    completedBy?: boolean | Lesson$completedByArgs<ExtArgs>
    Attendance?: boolean | Lesson$AttendanceArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    courseId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    courseId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    files?: boolean | Lesson$filesArgs<ExtArgs>
    quizzes?: boolean | Lesson$quizzesArgs<ExtArgs>
    completedBy?: boolean | Lesson$completedByArgs<ExtArgs>
    Attendance?: boolean | Lesson$AttendanceArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      files: Prisma.$FilePayload<ExtArgs>[]
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      completedBy: Prisma.$UserPayload<ExtArgs>[]
      Attendance: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      courseId: string
      status: $Enums.LessonStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    files<T extends Lesson$filesArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    quizzes<T extends Lesson$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany"> | Null>
    completedBy<T extends Lesson$completedByArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$completedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    Attendance<T extends Lesson$AttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$AttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */ 
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly content: FieldRef<"Lesson", 'String'>
    readonly courseId: FieldRef<"Lesson", 'String'>
    readonly status: FieldRef<"Lesson", 'LessonStatus'>
    readonly createdAt: FieldRef<"Lesson", 'DateTime'>
    readonly updatedAt: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
  }

  /**
   * Lesson.files
   */
  export type Lesson$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Lesson.quizzes
   */
  export type Lesson$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Lesson.completedBy
   */
  export type Lesson$completedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Lesson.Attendance
   */
  export type Lesson$AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    type: $Enums.FileType | null
    lessonId: string | null
    accountingEntryId: string | null
    prRecordId: string | null
    meetingId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    type: $Enums.FileType | null
    lessonId: string | null
    accountingEntryId: string | null
    prRecordId: string | null
    meetingId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    name: number
    url: number
    type: number
    lessonId: number
    accountingEntryId: number
    prRecordId: number
    meetingId: number
    adminRoleId: number
    legalCaseId: number
    createdAt: number
    _all: number
  }


  export type FileMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    lessonId?: true
    accountingEntryId?: true
    prRecordId?: true
    meetingId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    lessonId?: true
    accountingEntryId?: true
    prRecordId?: true
    meetingId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    type?: true
    lessonId?: true
    accountingEntryId?: true
    prRecordId?: true
    meetingId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId: string | null
    accountingEntryId: string | null
    prRecordId: string | null
    meetingId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date
    _count: FileCountAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    lessonId?: boolean
    accountingEntryId?: boolean
    prRecordId?: boolean
    meetingId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    lesson?: boolean | File$lessonArgs<ExtArgs>
    accountingEntry?: boolean | File$accountingEntryArgs<ExtArgs>
    prRecord?: boolean | File$prRecordArgs<ExtArgs>
    meeting?: boolean | File$meetingArgs<ExtArgs>
    adminRole?: boolean | File$adminRoleArgs<ExtArgs>
    legalCase?: boolean | File$legalCaseArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    lessonId?: boolean
    accountingEntryId?: boolean
    prRecordId?: boolean
    meetingId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    lesson?: boolean | File$lessonArgs<ExtArgs>
    accountingEntry?: boolean | File$accountingEntryArgs<ExtArgs>
    prRecord?: boolean | File$prRecordArgs<ExtArgs>
    meeting?: boolean | File$meetingArgs<ExtArgs>
    adminRole?: boolean | File$adminRoleArgs<ExtArgs>
    legalCase?: boolean | File$legalCaseArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    type?: boolean
    lessonId?: boolean
    accountingEntryId?: boolean
    prRecordId?: boolean
    meetingId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
  }

  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | File$lessonArgs<ExtArgs>
    accountingEntry?: boolean | File$accountingEntryArgs<ExtArgs>
    prRecord?: boolean | File$prRecordArgs<ExtArgs>
    meeting?: boolean | File$meetingArgs<ExtArgs>
    adminRole?: boolean | File$adminRoleArgs<ExtArgs>
    legalCase?: boolean | File$legalCaseArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | File$lessonArgs<ExtArgs>
    accountingEntry?: boolean | File$accountingEntryArgs<ExtArgs>
    prRecord?: boolean | File$prRecordArgs<ExtArgs>
    meeting?: boolean | File$meetingArgs<ExtArgs>
    adminRole?: boolean | File$adminRoleArgs<ExtArgs>
    legalCase?: boolean | File$legalCaseArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs> | null
      accountingEntry: Prisma.$AccountingEntryPayload<ExtArgs> | null
      prRecord: Prisma.$PublicRelationsRecordPayload<ExtArgs> | null
      meeting: Prisma.$MeetingPayload<ExtArgs> | null
      adminRole: Prisma.$AdminRolePayload<ExtArgs> | null
      legalCase: Prisma.$LegalCasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      type: $Enums.FileType
      lessonId: string | null
      accountingEntryId: string | null
      prRecordId: string | null
      meetingId: string | null
      adminRoleId: string | null
      legalCaseId: string | null
      createdAt: Date
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends File$lessonArgs<ExtArgs> = {}>(args?: Subset<T, File$lessonArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    accountingEntry<T extends File$accountingEntryArgs<ExtArgs> = {}>(args?: Subset<T, File$accountingEntryArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    prRecord<T extends File$prRecordArgs<ExtArgs> = {}>(args?: Subset<T, File$prRecordArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    meeting<T extends File$meetingArgs<ExtArgs> = {}>(args?: Subset<T, File$meetingArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    adminRole<T extends File$adminRoleArgs<ExtArgs> = {}>(args?: Subset<T, File$adminRoleArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    legalCase<T extends File$legalCaseArgs<ExtArgs> = {}>(args?: Subset<T, File$legalCaseArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */ 
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly name: FieldRef<"File", 'String'>
    readonly url: FieldRef<"File", 'String'>
    readonly type: FieldRef<"File", 'FileType'>
    readonly lessonId: FieldRef<"File", 'String'>
    readonly accountingEntryId: FieldRef<"File", 'String'>
    readonly prRecordId: FieldRef<"File", 'String'>
    readonly meetingId: FieldRef<"File", 'String'>
    readonly adminRoleId: FieldRef<"File", 'String'>
    readonly legalCaseId: FieldRef<"File", 'String'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
  }

  /**
   * File.lesson
   */
  export type File$lessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
  }

  /**
   * File.accountingEntry
   */
  export type File$accountingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    where?: AccountingEntryWhereInput
  }

  /**
   * File.prRecord
   */
  export type File$prRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    where?: PublicRelationsRecordWhereInput
  }

  /**
   * File.meeting
   */
  export type File$meetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
  }

  /**
   * File.adminRole
   */
  export type File$adminRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    where?: AdminRoleWhereInput
  }

  /**
   * File.legalCase
   */
  export type File$legalCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    where?: LegalCaseWhereInput
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentAvgAggregateOutputType = {
    progress: number | null
  }

  export type EnrollmentSumAggregateOutputType = {
    progress: number | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    progress: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    progress: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    progress: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EnrollmentAvgAggregateInputType = {
    progress?: true
  }

  export type EnrollmentSumAggregateInputType = {
    progress?: true
  }

  export type EnrollmentMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    progress?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _avg?: EnrollmentAvgAggregateInputType
    _sum?: EnrollmentSumAggregateInputType
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    progress: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    progress?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      progress: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {EnrollmentCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */ 
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'String'>
    readonly userId: FieldRef<"Enrollment", 'String'>
    readonly courseId: FieldRef<"Enrollment", 'String'>
    readonly progress: FieldRef<"Enrollment", 'Float'>
    readonly status: FieldRef<"Enrollment", 'String'>
    readonly createdAt: FieldRef<"Enrollment", 'DateTime'>
    readonly updatedAt: FieldRef<"Enrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment createManyAndReturn
   */
  export type EnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    timeLimit: number | null
    passingScore: number | null
  }

  export type QuizSumAggregateOutputType = {
    timeLimit: number | null
    passingScore: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    lessonId: string | null
    timeLimit: number | null
    passingScore: number | null
    upComing: boolean | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    lessonId: string | null
    timeLimit: number | null
    passingScore: number | null
    upComing: boolean | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    title: number
    description: number
    lessonId: number
    timeLimit: number
    passingScore: number
    upComing: number
    isCompleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    timeLimit?: true
    passingScore?: true
  }

  export type QuizSumAggregateInputType = {
    timeLimit?: true
    passingScore?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    lessonId?: true
    timeLimit?: true
    passingScore?: true
    upComing?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    lessonId?: true
    timeLimit?: true
    passingScore?: true
    upComing?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    lessonId?: true
    timeLimit?: true
    passingScore?: true
    upComing?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: string
    title: string
    description: string | null
    lessonId: string
    timeLimit: number | null
    passingScore: number | null
    upComing: boolean
    isCompleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    lessonId?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    submissions?: boolean | Quiz$submissionsArgs<ExtArgs>
    Course?: boolean | Quiz$CourseArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    lessonId?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    lessonId?: boolean
    timeLimit?: boolean
    passingScore?: boolean
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    submissions?: boolean | Quiz$submissionsArgs<ExtArgs>
    Course?: boolean | Quiz$CourseArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      submissions: Prisma.$SubmissionPayload<ExtArgs>[]
      Course: Prisma.$CoursePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      lessonId: string
      timeLimit: number | null
      passingScore: number | null
      upComing: boolean
      isCompleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    questions<T extends Quiz$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany"> | Null>
    submissions<T extends Quiz$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    Course<T extends Quiz$CourseArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$CourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */ 
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'String'>
    readonly title: FieldRef<"Quiz", 'String'>
    readonly description: FieldRef<"Quiz", 'String'>
    readonly lessonId: FieldRef<"Quiz", 'String'>
    readonly timeLimit: FieldRef<"Quiz", 'Int'>
    readonly passingScore: FieldRef<"Quiz", 'Int'>
    readonly upComing: FieldRef<"Quiz", 'Boolean'>
    readonly isCompleted: FieldRef<"Quiz", 'Boolean'>
    readonly createdAt: FieldRef<"Quiz", 'DateTime'>
    readonly updatedAt: FieldRef<"Quiz", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
  }

  /**
   * Quiz.questions
   */
  export type Quiz$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Quiz.submissions
   */
  export type Quiz$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    cursor?: SubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Quiz.Course
   */
  export type Quiz$CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    points: number | null
  }

  export type QuestionSumAggregateOutputType = {
    points: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    text: string | null
    type: string | null
    isMultiple: boolean | null
    points: number | null
    isAnswered: boolean | null
    quizId: string | null
    createdAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    text: string | null
    type: string | null
    isMultiple: boolean | null
    points: number | null
    isAnswered: boolean | null
    quizId: string | null
    createdAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    text: number
    type: number
    isMultiple: number
    points: number
    isAnswered: number
    quizId: number
    createdAt: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    points?: true
  }

  export type QuestionSumAggregateInputType = {
    points?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    text?: true
    type?: true
    isMultiple?: true
    points?: true
    isAnswered?: true
    quizId?: true
    createdAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    text?: true
    type?: true
    isMultiple?: true
    points?: true
    isAnswered?: true
    quizId?: true
    createdAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    text?: true
    type?: true
    isMultiple?: true
    points?: true
    isAnswered?: true
    quizId?: true
    createdAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    text: string
    type: string
    isMultiple: boolean
    points: number
    isAnswered: boolean
    quizId: string
    createdAt: Date
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    type?: boolean
    isMultiple?: boolean
    points?: boolean
    isAnswered?: boolean
    quizId?: boolean
    createdAt?: boolean
    options?: boolean | Question$optionsArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    type?: boolean
    isMultiple?: boolean
    points?: boolean
    isAnswered?: boolean
    quizId?: boolean
    createdAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    text?: boolean
    type?: boolean
    isMultiple?: boolean
    points?: boolean
    isAnswered?: boolean
    quizId?: boolean
    createdAt?: boolean
  }

  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | Question$optionsArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      options: Prisma.$OptionPayload<ExtArgs>[]
      quiz: Prisma.$QuizPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      type: string
      isMultiple: boolean
      points: number
      isAnswered: boolean
      quizId: string
      createdAt: Date
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    options<T extends Question$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Question$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findMany"> | Null>
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */ 
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly text: FieldRef<"Question", 'String'>
    readonly type: FieldRef<"Question", 'String'>
    readonly isMultiple: FieldRef<"Question", 'Boolean'>
    readonly points: FieldRef<"Question", 'Int'>
    readonly isAnswered: FieldRef<"Question", 'Boolean'>
    readonly quizId: FieldRef<"Question", 'String'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
  }

  /**
   * Question.options
   */
  export type Question$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    where?: OptionWhereInput
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    cursor?: OptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model Option
   */

  export type AggregateOption = {
    _count: OptionCountAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  export type OptionMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    text: string | null
    isCorrect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OptionMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    text: string | null
    isCorrect: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OptionCountAggregateOutputType = {
    id: number
    questionId: number
    text: number
    isCorrect: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OptionMinAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OptionMaxAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OptionCountAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Option to aggregate.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Options
    **/
    _count?: true | OptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionMaxAggregateInputType
  }

  export type GetOptionAggregateType<T extends OptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOption[P]>
      : GetScalarType<T[P], AggregateOption[P]>
  }




  export type OptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OptionWhereInput
    orderBy?: OptionOrderByWithAggregationInput | OptionOrderByWithAggregationInput[]
    by: OptionScalarFieldEnum[] | OptionScalarFieldEnum
    having?: OptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionCountAggregateInputType | true
    _min?: OptionMinAggregateInputType
    _max?: OptionMaxAggregateInputType
  }

  export type OptionGroupByOutputType = {
    id: string
    questionId: string
    text: string
    isCorrect: boolean
    createdAt: Date
    updatedAt: Date
    _count: OptionCountAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  type GetOptionGroupByPayload<T extends OptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionGroupByOutputType[P]>
            : GetScalarType<T[P], OptionGroupByOutputType[P]>
        }
      >
    >


  export type OptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type OptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["option"]>

  export type OptionSelectScalar = {
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type OptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $OptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Option"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      text: string
      isCorrect: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["option"]>
    composites: {}
  }

  type OptionGetPayload<S extends boolean | null | undefined | OptionDefaultArgs> = $Result.GetResult<Prisma.$OptionPayload, S>

  type OptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OptionCountAggregateInputType | true
    }

  export interface OptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Option'], meta: { name: 'Option' } }
    /**
     * Find zero or one Option that matches the filter.
     * @param {OptionFindUniqueArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OptionFindUniqueArgs>(args: SelectSubset<T, OptionFindUniqueArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Option that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OptionFindUniqueOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OptionFindUniqueOrThrowArgs>(args: SelectSubset<T, OptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Option that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OptionFindFirstArgs>(args?: SelectSubset<T, OptionFindFirstArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Option that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OptionFindFirstOrThrowArgs>(args?: SelectSubset<T, OptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Options
     * const options = await prisma.option.findMany()
     * 
     * // Get first 10 Options
     * const options = await prisma.option.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionWithIdOnly = await prisma.option.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OptionFindManyArgs>(args?: SelectSubset<T, OptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Option.
     * @param {OptionCreateArgs} args - Arguments to create a Option.
     * @example
     * // Create one Option
     * const Option = await prisma.option.create({
     *   data: {
     *     // ... data to create a Option
     *   }
     * })
     * 
     */
    create<T extends OptionCreateArgs>(args: SelectSubset<T, OptionCreateArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Options.
     * @param {OptionCreateManyArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OptionCreateManyArgs>(args?: SelectSubset<T, OptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Options and returns the data saved in the database.
     * @param {OptionCreateManyAndReturnArgs} args - Arguments to create many Options.
     * @example
     * // Create many Options
     * const option = await prisma.option.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Options and only return the `id`
     * const optionWithIdOnly = await prisma.option.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OptionCreateManyAndReturnArgs>(args?: SelectSubset<T, OptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Option.
     * @param {OptionDeleteArgs} args - Arguments to delete one Option.
     * @example
     * // Delete one Option
     * const Option = await prisma.option.delete({
     *   where: {
     *     // ... filter to delete one Option
     *   }
     * })
     * 
     */
    delete<T extends OptionDeleteArgs>(args: SelectSubset<T, OptionDeleteArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Option.
     * @param {OptionUpdateArgs} args - Arguments to update one Option.
     * @example
     * // Update one Option
     * const option = await prisma.option.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OptionUpdateArgs>(args: SelectSubset<T, OptionUpdateArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Options.
     * @param {OptionDeleteManyArgs} args - Arguments to filter Options to delete.
     * @example
     * // Delete a few Options
     * const { count } = await prisma.option.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OptionDeleteManyArgs>(args?: SelectSubset<T, OptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OptionUpdateManyArgs>(args: SelectSubset<T, OptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Option.
     * @param {OptionUpsertArgs} args - Arguments to update or create a Option.
     * @example
     * // Update or create a Option
     * const option = await prisma.option.upsert({
     *   create: {
     *     // ... data to create a Option
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Option we want to update
     *   }
     * })
     */
    upsert<T extends OptionUpsertArgs>(args: SelectSubset<T, OptionUpsertArgs<ExtArgs>>): Prisma__OptionClient<$Result.GetResult<Prisma.$OptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionCountArgs} args - Arguments to filter Options to count.
     * @example
     * // Count the number of Options
     * const count = await prisma.option.count({
     *   where: {
     *     // ... the filter for the Options we want to count
     *   }
     * })
    **/
    count<T extends OptionCountArgs>(
      args?: Subset<T, OptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionAggregateArgs>(args: Subset<T, OptionAggregateArgs>): Prisma.PrismaPromise<GetOptionAggregateType<T>>

    /**
     * Group by Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionGroupByArgs['orderBy'] }
        : { orderBy?: OptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Option model
   */
  readonly fields: OptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Option.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Option model
   */ 
  interface OptionFieldRefs {
    readonly id: FieldRef<"Option", 'String'>
    readonly questionId: FieldRef<"Option", 'String'>
    readonly text: FieldRef<"Option", 'String'>
    readonly isCorrect: FieldRef<"Option", 'Boolean'>
    readonly createdAt: FieldRef<"Option", 'DateTime'>
    readonly updatedAt: FieldRef<"Option", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Option findUnique
   */
  export type OptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option findUniqueOrThrow
   */
  export type OptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option findFirst
   */
  export type OptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option findFirstOrThrow
   */
  export type OptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Option to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     */
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option findMany
   */
  export type OptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter, which Options to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: OptionOrderByWithRelationInput | OptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    distinct?: OptionScalarFieldEnum | OptionScalarFieldEnum[]
  }

  /**
   * Option create
   */
  export type OptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Option.
     */
    data: XOR<OptionCreateInput, OptionUncheckedCreateInput>
  }

  /**
   * Option createMany
   */
  export type OptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Options.
     */
    data: OptionCreateManyInput | OptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Option createManyAndReturn
   */
  export type OptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Options.
     */
    data: OptionCreateManyInput | OptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Option update
   */
  export type OptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Option.
     */
    data: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
    /**
     * Choose, which Option to update.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option updateMany
   */
  export type OptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Options.
     */
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyInput>
    /**
     * Filter which Options to update
     */
    where?: OptionWhereInput
  }

  /**
   * Option upsert
   */
  export type OptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Option to update in case it exists.
     */
    where: OptionWhereUniqueInput
    /**
     * In case the Option found by the `where` argument doesn't exist, create a new Option with this data.
     */
    create: XOR<OptionCreateInput, OptionUncheckedCreateInput>
    /**
     * In case the Option was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
  }

  /**
   * Option delete
   */
  export type OptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
    /**
     * Filter which Option to delete.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option deleteMany
   */
  export type OptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Options to delete
     */
    where?: OptionWhereInput
  }

  /**
   * Option without action
   */
  export type OptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OptionInclude<ExtArgs> | null
  }


  /**
   * Model Submission
   */

  export type AggregateSubmission = {
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  export type SubmissionAvgAggregateOutputType = {
    score: number | null
  }

  export type SubmissionSumAggregateOutputType = {
    score: number | null
  }

  export type SubmissionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    quizId: string | null
    score: number | null
    feedback: string | null
    passed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubmissionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    quizId: string | null
    score: number | null
    feedback: string | null
    passed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubmissionCountAggregateOutputType = {
    id: number
    userId: number
    quizId: number
    answers: number
    score: number
    feedback: number
    passed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubmissionAvgAggregateInputType = {
    score?: true
  }

  export type SubmissionSumAggregateInputType = {
    score?: true
  }

  export type SubmissionMinAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    score?: true
    feedback?: true
    passed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubmissionMaxAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    score?: true
    feedback?: true
    passed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubmissionCountAggregateInputType = {
    id?: true
    userId?: true
    quizId?: true
    answers?: true
    score?: true
    feedback?: true
    passed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submission to aggregate.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Submissions
    **/
    _count?: true | SubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionMaxAggregateInputType
  }

  export type GetSubmissionAggregateType<T extends SubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission[P]>
      : GetScalarType<T[P], AggregateSubmission[P]>
  }




  export type SubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithAggregationInput | SubmissionOrderByWithAggregationInput[]
    by: SubmissionScalarFieldEnum[] | SubmissionScalarFieldEnum
    having?: SubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionCountAggregateInputType | true
    _avg?: SubmissionAvgAggregateInputType
    _sum?: SubmissionSumAggregateInputType
    _min?: SubmissionMinAggregateInputType
    _max?: SubmissionMaxAggregateInputType
  }

  export type SubmissionGroupByOutputType = {
    id: string
    userId: string
    quizId: string
    answers: JsonValue[]
    score: number | null
    feedback: string | null
    passed: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  type GetSubmissionGroupByPayload<T extends SubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    quizId?: boolean
    answers?: boolean
    score?: boolean
    feedback?: boolean
    passed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>

  export type SubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    quizId?: boolean
    answers?: boolean
    score?: boolean
    feedback?: boolean
    passed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>

  export type SubmissionSelectScalar = {
    id?: boolean
    userId?: boolean
    quizId?: boolean
    answers?: boolean
    score?: boolean
    feedback?: boolean
    passed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type SubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $SubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Submission"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      quiz: Prisma.$QuizPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      quizId: string
      answers: Prisma.JsonValue[]
      score: number | null
      feedback: string | null
      passed: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["submission"]>
    composites: {}
  }

  type SubmissionGetPayload<S extends boolean | null | undefined | SubmissionDefaultArgs> = $Result.GetResult<Prisma.$SubmissionPayload, S>

  type SubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubmissionCountAggregateInputType | true
    }

  export interface SubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Submission'], meta: { name: 'Submission' } }
    /**
     * Find zero or one Submission that matches the filter.
     * @param {SubmissionFindUniqueArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionFindUniqueArgs>(args: SelectSubset<T, SubmissionFindUniqueArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Submission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubmissionFindUniqueOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionFindFirstArgs>(args?: SelectSubset<T, SubmissionFindFirstArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Submission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submission.findMany()
     * 
     * // Get first 10 Submissions
     * const submissions = await prisma.submission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionWithIdOnly = await prisma.submission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubmissionFindManyArgs>(args?: SelectSubset<T, SubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Submission.
     * @param {SubmissionCreateArgs} args - Arguments to create a Submission.
     * @example
     * // Create one Submission
     * const Submission = await prisma.submission.create({
     *   data: {
     *     // ... data to create a Submission
     *   }
     * })
     * 
     */
    create<T extends SubmissionCreateArgs>(args: SelectSubset<T, SubmissionCreateArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Submissions.
     * @param {SubmissionCreateManyArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubmissionCreateManyArgs>(args?: SelectSubset<T, SubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Submissions and returns the data saved in the database.
     * @param {SubmissionCreateManyAndReturnArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Submissions and only return the `id`
     * const submissionWithIdOnly = await prisma.submission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Submission.
     * @param {SubmissionDeleteArgs} args - Arguments to delete one Submission.
     * @example
     * // Delete one Submission
     * const Submission = await prisma.submission.delete({
     *   where: {
     *     // ... filter to delete one Submission
     *   }
     * })
     * 
     */
    delete<T extends SubmissionDeleteArgs>(args: SelectSubset<T, SubmissionDeleteArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Submission.
     * @param {SubmissionUpdateArgs} args - Arguments to update one Submission.
     * @example
     * // Update one Submission
     * const submission = await prisma.submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubmissionUpdateArgs>(args: SelectSubset<T, SubmissionUpdateArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Submissions.
     * @param {SubmissionDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubmissionDeleteManyArgs>(args?: SelectSubset<T, SubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubmissionUpdateManyArgs>(args: SelectSubset<T, SubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Submission.
     * @param {SubmissionUpsertArgs} args - Arguments to update or create a Submission.
     * @example
     * // Update or create a Submission
     * const submission = await prisma.submission.upsert({
     *   create: {
     *     // ... data to create a Submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionUpsertArgs>(args: SelectSubset<T, SubmissionUpsertArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submission.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
    **/
    count<T extends SubmissionCountArgs>(
      args?: Subset<T, SubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionAggregateArgs>(args: Subset<T, SubmissionAggregateArgs>): Prisma.PrismaPromise<GetSubmissionAggregateType<T>>

    /**
     * Group by Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Submission model
   */
  readonly fields: SubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Submission model
   */ 
  interface SubmissionFieldRefs {
    readonly id: FieldRef<"Submission", 'String'>
    readonly userId: FieldRef<"Submission", 'String'>
    readonly quizId: FieldRef<"Submission", 'String'>
    readonly answers: FieldRef<"Submission", 'Json[]'>
    readonly score: FieldRef<"Submission", 'Float'>
    readonly feedback: FieldRef<"Submission", 'String'>
    readonly passed: FieldRef<"Submission", 'Boolean'>
    readonly createdAt: FieldRef<"Submission", 'DateTime'>
    readonly updatedAt: FieldRef<"Submission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Submission findUnique
   */
  export type SubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findUniqueOrThrow
   */
  export type SubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findFirst
   */
  export type SubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission findFirstOrThrow
   */
  export type SubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission findMany
   */
  export type SubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submissions to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission create
   */
  export type SubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Submission.
     */
    data: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
  }

  /**
   * Submission createMany
   */
  export type SubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Submission createManyAndReturn
   */
  export type SubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Submission update
   */
  export type SubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Submission.
     */
    data: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
    /**
     * Choose, which Submission to update.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission updateMany
   */
  export type SubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Submissions.
     */
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyInput>
    /**
     * Filter which Submissions to update
     */
    where?: SubmissionWhereInput
  }

  /**
   * Submission upsert
   */
  export type SubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Submission to update in case it exists.
     */
    where: SubmissionWhereUniqueInput
    /**
     * In case the Submission found by the `where` argument doesn't exist, create a new Submission with this data.
     */
    create: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
    /**
     * In case the Submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
  }

  /**
   * Submission delete
   */
  export type SubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter which Submission to delete.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission deleteMany
   */
  export type SubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submissions to delete
     */
    where?: SubmissionWhereInput
  }

  /**
   * Submission without action
   */
  export type SubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    isNew: boolean | null
    createdAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    isNew: boolean | null
    createdAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    value: number
    isNew: number
    createdAt: number
    _all: number
  }


  export type AchievementMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    isNew?: true
    createdAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    isNew?: true
    createdAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    value?: true
    isNew?: true
    createdAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    userId: string
    type: string
    value: JsonValue
    isNew: boolean
    createdAt: Date
    _count: AchievementCountAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    isNew?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    isNew?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    value?: boolean
    isNew?: boolean
    createdAt?: boolean
  }

  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      value: Prisma.JsonValue
      isNew: boolean
      createdAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */ 
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly userId: FieldRef<"Achievement", 'String'>
    readonly type: FieldRef<"Achievement", 'String'>
    readonly value: FieldRef<"Achievement", 'Json'>
    readonly isNew: FieldRef<"Achievement", 'Boolean'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    message: string | null
    isImportant: boolean | null
    urgent: boolean | null
    title: string | null
    actionUrl: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    message: string | null
    isImportant: boolean | null
    urgent: boolean | null
    title: string | null
    actionUrl: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    message: number
    isImportant: number
    urgent: number
    title: number
    actionUrl: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    isImportant?: true
    urgent?: true
    title?: true
    actionUrl?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    isImportant?: true
    urgent?: true
    title?: true
    actionUrl?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    isImportant?: true
    urgent?: true
    title?: true
    actionUrl?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    message: string
    isImportant: boolean
    urgent: boolean
    title: string
    actionUrl: string | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    isImportant?: boolean
    urgent?: boolean
    title?: boolean
    actionUrl?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    isImportant?: boolean
    urgent?: boolean
    title?: boolean
    actionUrl?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    isImportant?: boolean
    urgent?: boolean
    title?: boolean
    actionUrl?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      message: string
      isImportant: boolean
      urgent: boolean
      title: string
      actionUrl: string | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isImportant: FieldRef<"Notification", 'Boolean'>
    readonly urgent: FieldRef<"Notification", 'Boolean'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSettings
   */

  export type AggregateNotificationSettings = {
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  export type NotificationSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    assignments: boolean | null
    grades: boolean | null
    messages: boolean | null
    achievements: boolean | null
    urgent: boolean | null
    email: boolean | null
    push: boolean | null
    createdAt: Date | null
  }

  export type NotificationSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    assignments: boolean | null
    grades: boolean | null
    messages: boolean | null
    achievements: boolean | null
    urgent: boolean | null
    email: boolean | null
    push: boolean | null
    createdAt: Date | null
  }

  export type NotificationSettingsCountAggregateOutputType = {
    id: number
    userId: number
    assignments: number
    grades: number
    messages: number
    achievements: number
    urgent: number
    email: number
    push: number
    createdAt: number
    _all: number
  }


  export type NotificationSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    assignments?: true
    grades?: true
    messages?: true
    achievements?: true
    urgent?: true
    email?: true
    push?: true
    createdAt?: true
  }

  export type NotificationSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    assignments?: true
    grades?: true
    messages?: true
    achievements?: true
    urgent?: true
    email?: true
    push?: true
    createdAt?: true
  }

  export type NotificationSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    assignments?: true
    grades?: true
    messages?: true
    achievements?: true
    urgent?: true
    email?: true
    push?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to aggregate.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type GetNotificationSettingsAggregateType<T extends NotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSettings[P]>
      : GetScalarType<T[P], AggregateNotificationSettings[P]>
  }




  export type NotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithAggregationInput | NotificationSettingsOrderByWithAggregationInput[]
    by: NotificationSettingsScalarFieldEnum[] | NotificationSettingsScalarFieldEnum
    having?: NotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingsCountAggregateInputType | true
    _min?: NotificationSettingsMinAggregateInputType
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type NotificationSettingsGroupByOutputType = {
    id: string
    userId: string
    assignments: boolean
    grades: boolean
    messages: boolean
    achievements: boolean
    urgent: boolean
    email: boolean
    push: boolean
    createdAt: Date
    _count: NotificationSettingsCountAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  type GetNotificationSettingsGroupByPayload<T extends NotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assignments?: boolean
    grades?: boolean
    messages?: boolean
    achievements?: boolean
    urgent?: boolean
    email?: boolean
    push?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    assignments?: boolean
    grades?: boolean
    messages?: boolean
    achievements?: boolean
    urgent?: boolean
    email?: boolean
    push?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    assignments?: boolean
    grades?: boolean
    messages?: boolean
    achievements?: boolean
    urgent?: boolean
    email?: boolean
    push?: boolean
    createdAt?: boolean
  }

  export type NotificationSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      assignments: boolean
      grades: boolean
      messages: boolean
      achievements: boolean
      urgent: boolean
      email: boolean
      push: boolean
      createdAt: Date
    }, ExtArgs["result"]["notificationSettings"]>
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>

  type NotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationSettingsCountAggregateInputType | true
    }

  export interface NotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSettings'], meta: { name: 'NotificationSettings' } }
    /**
     * Find zero or one NotificationSettings that matches the filter.
     * @param {NotificationSettingsFindUniqueArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingsFindUniqueArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingsFindFirstArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSettingsFindManyArgs>(args?: SelectSubset<T, NotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationSettings.
     * @param {NotificationSettingsCreateArgs} args - Arguments to create a NotificationSettings.
     * @example
     * // Create one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.create({
     *   data: {
     *     // ... data to create a NotificationSettings
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingsCreateArgs>(args: SelectSubset<T, NotificationSettingsCreateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingsCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingsCreateManyArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationSettings.
     * @param {NotificationSettingsDeleteArgs} args - Arguments to delete one NotificationSettings.
     * @example
     * // Delete one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.delete({
     *   where: {
     *     // ... filter to delete one NotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingsDeleteArgs>(args: SelectSubset<T, NotificationSettingsDeleteArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationSettings.
     * @param {NotificationSettingsUpdateArgs} args - Arguments to update one NotificationSettings.
     * @example
     * // Update one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingsUpdateArgs>(args: SelectSubset<T, NotificationSettingsUpdateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingsDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingsUpdateManyArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationSettings.
     * @param {NotificationSettingsUpsertArgs} args - Arguments to update or create a NotificationSettings.
     * @example
     * // Update or create a NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.upsert({
     *   create: {
     *     // ... data to create a NotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingsUpsertArgs>(args: SelectSubset<T, NotificationSettingsUpsertArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSettings.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingsCountArgs>(
      args?: Subset<T, NotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingsAggregateArgs>(args: Subset<T, NotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingsAggregateType<T>>

    /**
     * Group by NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSettings model
   */
  readonly fields: NotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSettings model
   */ 
  interface NotificationSettingsFieldRefs {
    readonly id: FieldRef<"NotificationSettings", 'String'>
    readonly userId: FieldRef<"NotificationSettings", 'String'>
    readonly assignments: FieldRef<"NotificationSettings", 'Boolean'>
    readonly grades: FieldRef<"NotificationSettings", 'Boolean'>
    readonly messages: FieldRef<"NotificationSettings", 'Boolean'>
    readonly achievements: FieldRef<"NotificationSettings", 'Boolean'>
    readonly urgent: FieldRef<"NotificationSettings", 'Boolean'>
    readonly email: FieldRef<"NotificationSettings", 'Boolean'>
    readonly push: FieldRef<"NotificationSettings", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings findUnique
   */
  export type NotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findUniqueOrThrow
   */
  export type NotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findFirst
   */
  export type NotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findFirstOrThrow
   */
  export type NotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findMany
   */
  export type NotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings create
   */
  export type NotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSettings.
     */
    data: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
  }

  /**
   * NotificationSettings createMany
   */
  export type NotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings createManyAndReturn
   */
  export type NotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings update
   */
  export type NotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which NotificationSettings to update.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings updateMany
   */
  export type NotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationSettings upsert
   */
  export type NotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSettings to update in case it exists.
     */
    where: NotificationSettingsWhereUniqueInput
    /**
     * In case the NotificationSettings found by the `where` argument doesn't exist, create a new NotificationSettings with this data.
     */
    create: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
    /**
     * In case the NotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
  }

  /**
   * NotificationSettings delete
   */
  export type NotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter which NotificationSettings to delete.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings deleteMany
   */
  export type NotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
    isRead: boolean | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    content: string | null
    createdAt: Date | null
    isRead: boolean | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    content: number
    createdAt: number
    isRead: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    content?: true
    createdAt?: true
    isRead?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    content?: true
    createdAt?: true
    isRead?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    content?: true
    createdAt?: true
    isRead?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    content: string
    createdAt: Date
    isRead: boolean
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    isRead?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    Channel?: boolean | Message$ChannelArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    isRead?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    content?: boolean
    createdAt?: boolean
    isRead?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    Channel?: boolean | Message$ChannelArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      Channel: Prisma.$ChannelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      content: string
      createdAt: Date
      isRead: boolean
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Channel<T extends Message$ChannelArgs<ExtArgs> = {}>(args?: Subset<T, Message$ChannelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.Channel
   */
  export type Message$ChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    likesCount: number | null
  }

  export type PostSumAggregateOutputType = {
    likesCount: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    title: string | null
    createdAt: Date | null
    likesCount: number | null
    publicRelationsRecordId: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    content: string | null
    title: string | null
    createdAt: Date | null
    likesCount: number | null
    publicRelationsRecordId: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    authorId: number
    content: number
    title: number
    createdAt: number
    likesCount: number
    publicRelationsRecordId: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    likesCount?: true
  }

  export type PostSumAggregateInputType = {
    likesCount?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    title?: true
    createdAt?: true
    likesCount?: true
    publicRelationsRecordId?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    title?: true
    createdAt?: true
    likesCount?: true
    publicRelationsRecordId?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    authorId?: true
    content?: true
    title?: true
    createdAt?: true
    likesCount?: true
    publicRelationsRecordId?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    authorId: string
    content: string
    title: string
    createdAt: Date
    likesCount: number
    publicRelationsRecordId: string | null
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    content?: boolean
    title?: boolean
    createdAt?: boolean
    likesCount?: boolean
    publicRelationsRecordId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    Group?: boolean | Post$GroupArgs<ExtArgs>
    Community?: boolean | Post$CommunityArgs<ExtArgs>
    Discussion?: boolean | Post$DiscussionArgs<ExtArgs>
    PublicRelationsRecord?: boolean | Post$PublicRelationsRecordArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    content?: boolean
    title?: boolean
    createdAt?: boolean
    likesCount?: boolean
    publicRelationsRecordId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    PublicRelationsRecord?: boolean | Post$PublicRelationsRecordArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    authorId?: boolean
    content?: boolean
    title?: boolean
    createdAt?: boolean
    likesCount?: boolean
    publicRelationsRecordId?: boolean
  }

  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    Group?: boolean | Post$GroupArgs<ExtArgs>
    Community?: boolean | Post$CommunityArgs<ExtArgs>
    Discussion?: boolean | Post$DiscussionArgs<ExtArgs>
    PublicRelationsRecord?: boolean | Post$PublicRelationsRecordArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    PublicRelationsRecord?: boolean | Post$PublicRelationsRecordArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      Group: Prisma.$GroupPayload<ExtArgs>[]
      Community: Prisma.$CommunityPayload<ExtArgs>[]
      Discussion: Prisma.$DiscussionPayload<ExtArgs>[]
      PublicRelationsRecord: Prisma.$PublicRelationsRecordPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      content: string
      title: string
      createdAt: Date
      likesCount: number
      publicRelationsRecordId: string | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    Group<T extends Post$GroupArgs<ExtArgs> = {}>(args?: Subset<T, Post$GroupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany"> | Null>
    Community<T extends Post$CommunityArgs<ExtArgs> = {}>(args?: Subset<T, Post$CommunityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findMany"> | Null>
    Discussion<T extends Post$DiscussionArgs<ExtArgs> = {}>(args?: Subset<T, Post$DiscussionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "findMany"> | Null>
    PublicRelationsRecord<T extends Post$PublicRelationsRecordArgs<ExtArgs> = {}>(args?: Subset<T, Post$PublicRelationsRecordArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */ 
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly title: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly likesCount: FieldRef<"Post", 'Int'>
    readonly publicRelationsRecordId: FieldRef<"Post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.Group
   */
  export type Post$GroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Post.Community
   */
  export type Post$CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    cursor?: CommunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Post.Discussion
   */
  export type Post$DiscussionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    where?: DiscussionWhereInput
    orderBy?: DiscussionOrderByWithRelationInput | DiscussionOrderByWithRelationInput[]
    cursor?: DiscussionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscussionScalarFieldEnum | DiscussionScalarFieldEnum[]
  }

  /**
   * Post.PublicRelationsRecord
   */
  export type Post$PublicRelationsRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    where?: PublicRelationsRecordWhereInput
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    content: number
    createdAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    createdAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    createdAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    content: string
    createdAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    content?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    content?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Group
   */

  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    image: string | null
    adminId: string | null
    createdAt: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subject: string | null
    image: string | null
    adminId: string | null
    createdAt: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    image: number
    adminId: number
    createdAt: number
    _all: number
  }


  export type GroupMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    image?: true
    adminId?: true
    createdAt?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    image?: true
    adminId?: true
    createdAt?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    image?: true
    adminId?: true
    createdAt?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Group to aggregate.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type GroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithAggregationInput | GroupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: GroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }

  export type GroupGroupByOutputType = {
    id: string
    name: string
    subject: string
    image: string | null
    adminId: string
    createdAt: Date
    _count: GroupCountAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends GroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type GroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    image?: boolean
    adminId?: boolean
    createdAt?: boolean
    members?: boolean | Group$membersArgs<ExtArgs>
    posts?: boolean | Group$postsArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    Community?: boolean | Group$CommunityArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    image?: boolean
    adminId?: boolean
    createdAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type GroupSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    image?: boolean
    adminId?: boolean
    createdAt?: boolean
  }

  export type GroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Group$membersArgs<ExtArgs>
    posts?: boolean | Group$postsArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    Community?: boolean | Group$CommunityArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $GroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Group"
    objects: {
      members: Prisma.$UserPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs>
      Community: Prisma.$CommunityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subject: string
      image: string | null
      adminId: string
      createdAt: Date
    }, ExtArgs["result"]["group"]>
    composites: {}
  }

  type GroupGetPayload<S extends boolean | null | undefined | GroupDefaultArgs> = $Result.GetResult<Prisma.$GroupPayload, S>

  type GroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface GroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Group'], meta: { name: 'Group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {GroupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupFindUniqueArgs>(args: SelectSubset<T, GroupFindUniqueArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Group that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupFindFirstArgs>(args?: SelectSubset<T, GroupFindFirstArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupFindManyArgs>(args?: SelectSubset<T, GroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Group.
     * @param {GroupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
     */
    create<T extends GroupCreateArgs>(args: SelectSubset<T, GroupCreateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groups.
     * @param {GroupCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupCreateManyArgs>(args?: SelectSubset<T, GroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {GroupCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const group = await prisma.group.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupWithIdOnly = await prisma.group.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Group.
     * @param {GroupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
     */
    delete<T extends GroupDeleteArgs>(args: SelectSubset<T, GroupDeleteArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Group.
     * @param {GroupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupUpdateArgs>(args: SelectSubset<T, GroupUpdateArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {GroupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupDeleteManyArgs>(args?: SelectSubset<T, GroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupUpdateManyArgs>(args: SelectSubset<T, GroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {GroupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
     */
    upsert<T extends GroupUpsertArgs>(args: SelectSubset<T, GroupUpsertArgs<ExtArgs>>): Prisma__GroupClient<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupCountArgs>(
      args?: Subset<T, GroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupGroupByArgs['orderBy'] }
        : { orderBy?: GroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Group model
   */
  readonly fields: GroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Group$membersArgs<ExtArgs> = {}>(args?: Subset<T, Group$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends Group$postsArgs<ExtArgs> = {}>(args?: Subset<T, Group$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Community<T extends Group$CommunityArgs<ExtArgs> = {}>(args?: Subset<T, Group$CommunityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Group model
   */ 
  interface GroupFieldRefs {
    readonly id: FieldRef<"Group", 'String'>
    readonly name: FieldRef<"Group", 'String'>
    readonly subject: FieldRef<"Group", 'String'>
    readonly image: FieldRef<"Group", 'String'>
    readonly adminId: FieldRef<"Group", 'String'>
    readonly createdAt: FieldRef<"Group", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Group findUnique
   */
  export type GroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findUniqueOrThrow
   */
  export type GroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group findFirst
   */
  export type GroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findFirstOrThrow
   */
  export type GroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Group to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group findMany
   */
  export type GroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Group create
   */
  export type GroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to create a Group.
     */
    data: XOR<GroupCreateInput, GroupUncheckedCreateInput>
  }

  /**
   * Group createMany
   */
  export type GroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Group createManyAndReturn
   */
  export type GroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Groups.
     */
    data: GroupCreateManyInput | GroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Group update
   */
  export type GroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The data needed to update a Group.
     */
    data: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
    /**
     * Choose, which Group to update.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group updateMany
   */
  export type GroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupWhereInput
  }

  /**
   * Group upsert
   */
  export type GroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * The filter to search for the Group to update in case it exists.
     */
    where: GroupWhereUniqueInput
    /**
     * In case the Group found by the `where` argument doesn't exist, create a new Group with this data.
     */
    create: XOR<GroupCreateInput, GroupUncheckedCreateInput>
    /**
     * In case the Group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupUpdateInput, GroupUncheckedUpdateInput>
  }

  /**
   * Group delete
   */
  export type GroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    /**
     * Filter which Group to delete.
     */
    where: GroupWhereUniqueInput
  }

  /**
   * Group deleteMany
   */
  export type GroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupWhereInput
  }

  /**
   * Group.members
   */
  export type Group$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Group.posts
   */
  export type Group$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Group.Community
   */
  export type Group$CommunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    cursor?: CommunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Group without action
   */
  export type GroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Group?: boolean | Admin$GroupArgs<ExtArgs>
    accountingEntries?: boolean | Admin$accountingEntriesArgs<ExtArgs>
    prRecords?: boolean | Admin$prRecordsArgs<ExtArgs>
    prResponses?: boolean | Admin$prResponsesArgs<ExtArgs>
    meetings?: boolean | Admin$meetingsArgs<ExtArgs>
    assignments?: boolean | Admin$assignmentsArgs<ExtArgs>
    legalCases?: boolean | Admin$legalCasesArgs<ExtArgs>
    AdminRole?: boolean | Admin$AdminRoleArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Group?: boolean | Admin$GroupArgs<ExtArgs>
    accountingEntries?: boolean | Admin$accountingEntriesArgs<ExtArgs>
    prRecords?: boolean | Admin$prRecordsArgs<ExtArgs>
    prResponses?: boolean | Admin$prResponsesArgs<ExtArgs>
    meetings?: boolean | Admin$meetingsArgs<ExtArgs>
    assignments?: boolean | Admin$assignmentsArgs<ExtArgs>
    legalCases?: boolean | Admin$legalCasesArgs<ExtArgs>
    AdminRole?: boolean | Admin$AdminRoleArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Group: Prisma.$GroupPayload<ExtArgs>[]
      accountingEntries: Prisma.$AccountingEntryPayload<ExtArgs>[]
      prRecords: Prisma.$PublicRelationsRecordPayload<ExtArgs>[]
      prResponses: Prisma.$PRResponsePayload<ExtArgs>[]
      meetings: Prisma.$MeetingPayload<ExtArgs>[]
      assignments: Prisma.$AdminAssignmentPayload<ExtArgs>[]
      legalCases: Prisma.$LegalCasePayload<ExtArgs>[]
      AdminRole: Prisma.$AdminRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Group<T extends Admin$GroupArgs<ExtArgs> = {}>(args?: Subset<T, Admin$GroupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany"> | Null>
    accountingEntries<T extends Admin$accountingEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$accountingEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findMany"> | Null>
    prRecords<T extends Admin$prRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$prRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findMany"> | Null>
    prResponses<T extends Admin$prResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$prResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "findMany"> | Null>
    meetings<T extends Admin$meetingsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$meetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends Admin$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    legalCases<T extends Admin$legalCasesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$legalCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findMany"> | Null>
    AdminRole<T extends Admin$AdminRoleArgs<ExtArgs> = {}>(args?: Subset<T, Admin$AdminRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }

  /**
   * Admin.Group
   */
  export type Admin$GroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Admin.accountingEntries
   */
  export type Admin$accountingEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    where?: AccountingEntryWhereInput
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    cursor?: AccountingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountingEntryScalarFieldEnum | AccountingEntryScalarFieldEnum[]
  }

  /**
   * Admin.prRecords
   */
  export type Admin$prRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    where?: PublicRelationsRecordWhereInput
    orderBy?: PublicRelationsRecordOrderByWithRelationInput | PublicRelationsRecordOrderByWithRelationInput[]
    cursor?: PublicRelationsRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicRelationsRecordScalarFieldEnum | PublicRelationsRecordScalarFieldEnum[]
  }

  /**
   * Admin.prResponses
   */
  export type Admin$prResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    where?: PRResponseWhereInput
    orderBy?: PRResponseOrderByWithRelationInput | PRResponseOrderByWithRelationInput[]
    cursor?: PRResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PRResponseScalarFieldEnum | PRResponseScalarFieldEnum[]
  }

  /**
   * Admin.meetings
   */
  export type Admin$meetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Admin.assignments
   */
  export type Admin$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    where?: AdminAssignmentWhereInput
    orderBy?: AdminAssignmentOrderByWithRelationInput | AdminAssignmentOrderByWithRelationInput[]
    cursor?: AdminAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAssignmentScalarFieldEnum | AdminAssignmentScalarFieldEnum[]
  }

  /**
   * Admin.legalCases
   */
  export type Admin$legalCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    where?: LegalCaseWhereInput
    orderBy?: LegalCaseOrderByWithRelationInput | LegalCaseOrderByWithRelationInput[]
    cursor?: LegalCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LegalCaseScalarFieldEnum | LegalCaseScalarFieldEnum[]
  }

  /**
   * Admin.AdminRole
   */
  export type Admin$AdminRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    where?: AdminRoleWhereInput
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    cursor?: AdminRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminRoleScalarFieldEnum | AdminRoleScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Channel
   */

  export type AggregateChannel = {
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  export type ChannelMinAggregateOutputType = {
    id: string | null
    name: string | null
    ownerId: string | null
    prRecordId: string | null
    meetingId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date | null
  }

  export type ChannelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    ownerId: string | null
    prRecordId: string | null
    meetingId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date | null
  }

  export type ChannelCountAggregateOutputType = {
    id: number
    name: number
    ownerId: number
    prRecordId: number
    meetingId: number
    adminRoleId: number
    legalCaseId: number
    createdAt: number
    _all: number
  }


  export type ChannelMinAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    prRecordId?: true
    meetingId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
  }

  export type ChannelMaxAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    prRecordId?: true
    meetingId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
  }

  export type ChannelCountAggregateInputType = {
    id?: true
    name?: true
    ownerId?: true
    prRecordId?: true
    meetingId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
    _all?: true
  }

  export type ChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channel to aggregate.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Channels
    **/
    _count?: true | ChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelMaxAggregateInputType
  }

  export type GetChannelAggregateType<T extends ChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannel[P]>
      : GetScalarType<T[P], AggregateChannel[P]>
  }




  export type ChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithAggregationInput | ChannelOrderByWithAggregationInput[]
    by: ChannelScalarFieldEnum[] | ChannelScalarFieldEnum
    having?: ChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCountAggregateInputType | true
    _min?: ChannelMinAggregateInputType
    _max?: ChannelMaxAggregateInputType
  }

  export type ChannelGroupByOutputType = {
    id: string
    name: string
    ownerId: string
    prRecordId: string | null
    meetingId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date
    _count: ChannelCountAggregateOutputType | null
    _min: ChannelMinAggregateOutputType | null
    _max: ChannelMaxAggregateOutputType | null
  }

  type GetChannelGroupByPayload<T extends ChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelGroupByOutputType[P]>
        }
      >
    >


  export type ChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerId?: boolean
    prRecordId?: boolean
    meetingId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    members?: boolean | Channel$membersArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    messages?: boolean | Channel$messagesArgs<ExtArgs>
    prRecord?: boolean | Channel$prRecordArgs<ExtArgs>
    meeting?: boolean | Channel$meetingArgs<ExtArgs>
    adminRole?: boolean | Channel$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Channel$legalCaseArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ownerId?: boolean
    prRecordId?: boolean
    meetingId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    prRecord?: boolean | Channel$prRecordArgs<ExtArgs>
    meeting?: boolean | Channel$meetingArgs<ExtArgs>
    adminRole?: boolean | Channel$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Channel$legalCaseArgs<ExtArgs>
  }, ExtArgs["result"]["channel"]>

  export type ChannelSelectScalar = {
    id?: boolean
    name?: boolean
    ownerId?: boolean
    prRecordId?: boolean
    meetingId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
  }

  export type ChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Channel$membersArgs<ExtArgs>
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    messages?: boolean | Channel$messagesArgs<ExtArgs>
    prRecord?: boolean | Channel$prRecordArgs<ExtArgs>
    meeting?: boolean | Channel$meetingArgs<ExtArgs>
    adminRole?: boolean | Channel$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Channel$legalCaseArgs<ExtArgs>
    _count?: boolean | ChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | OwnerDefaultArgs<ExtArgs>
    prRecord?: boolean | Channel$prRecordArgs<ExtArgs>
    meeting?: boolean | Channel$meetingArgs<ExtArgs>
    adminRole?: boolean | Channel$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Channel$legalCaseArgs<ExtArgs>
  }

  export type $ChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Channel"
    objects: {
      members: Prisma.$UserPayload<ExtArgs>[]
      owner: Prisma.$OwnerPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      prRecord: Prisma.$PublicRelationsRecordPayload<ExtArgs> | null
      meeting: Prisma.$MeetingPayload<ExtArgs> | null
      adminRole: Prisma.$AdminRolePayload<ExtArgs> | null
      legalCase: Prisma.$LegalCasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      ownerId: string
      prRecordId: string | null
      meetingId: string | null
      adminRoleId: string | null
      legalCaseId: string | null
      createdAt: Date
    }, ExtArgs["result"]["channel"]>
    composites: {}
  }

  type ChannelGetPayload<S extends boolean | null | undefined | ChannelDefaultArgs> = $Result.GetResult<Prisma.$ChannelPayload, S>

  type ChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChannelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChannelCountAggregateInputType | true
    }

  export interface ChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Channel'], meta: { name: 'Channel' } }
    /**
     * Find zero or one Channel that matches the filter.
     * @param {ChannelFindUniqueArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelFindUniqueArgs>(args: SelectSubset<T, ChannelFindUniqueArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Channel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChannelFindUniqueOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Channel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelFindFirstArgs>(args?: SelectSubset<T, ChannelFindFirstArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Channel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindFirstOrThrowArgs} args - Arguments to find a Channel
     * @example
     * // Get one Channel
     * const channel = await prisma.channel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Channels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Channels
     * const channels = await prisma.channel.findMany()
     * 
     * // Get first 10 Channels
     * const channels = await prisma.channel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelWithIdOnly = await prisma.channel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelFindManyArgs>(args?: SelectSubset<T, ChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Channel.
     * @param {ChannelCreateArgs} args - Arguments to create a Channel.
     * @example
     * // Create one Channel
     * const Channel = await prisma.channel.create({
     *   data: {
     *     // ... data to create a Channel
     *   }
     * })
     * 
     */
    create<T extends ChannelCreateArgs>(args: SelectSubset<T, ChannelCreateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Channels.
     * @param {ChannelCreateManyArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCreateManyArgs>(args?: SelectSubset<T, ChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Channels and returns the data saved in the database.
     * @param {ChannelCreateManyAndReturnArgs} args - Arguments to create many Channels.
     * @example
     * // Create many Channels
     * const channel = await prisma.channel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Channels and only return the `id`
     * const channelWithIdOnly = await prisma.channel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Channel.
     * @param {ChannelDeleteArgs} args - Arguments to delete one Channel.
     * @example
     * // Delete one Channel
     * const Channel = await prisma.channel.delete({
     *   where: {
     *     // ... filter to delete one Channel
     *   }
     * })
     * 
     */
    delete<T extends ChannelDeleteArgs>(args: SelectSubset<T, ChannelDeleteArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Channel.
     * @param {ChannelUpdateArgs} args - Arguments to update one Channel.
     * @example
     * // Update one Channel
     * const channel = await prisma.channel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelUpdateArgs>(args: SelectSubset<T, ChannelUpdateArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Channels.
     * @param {ChannelDeleteManyArgs} args - Arguments to filter Channels to delete.
     * @example
     * // Delete a few Channels
     * const { count } = await prisma.channel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDeleteManyArgs>(args?: SelectSubset<T, ChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Channels
     * const channel = await prisma.channel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelUpdateManyArgs>(args: SelectSubset<T, ChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Channel.
     * @param {ChannelUpsertArgs} args - Arguments to update or create a Channel.
     * @example
     * // Update or create a Channel
     * const channel = await prisma.channel.upsert({
     *   create: {
     *     // ... data to create a Channel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Channel we want to update
     *   }
     * })
     */
    upsert<T extends ChannelUpsertArgs>(args: SelectSubset<T, ChannelUpsertArgs<ExtArgs>>): Prisma__ChannelClient<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Channels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCountArgs} args - Arguments to filter Channels to count.
     * @example
     * // Count the number of Channels
     * const count = await prisma.channel.count({
     *   where: {
     *     // ... the filter for the Channels we want to count
     *   }
     * })
    **/
    count<T extends ChannelCountArgs>(
      args?: Subset<T, ChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelAggregateArgs>(args: Subset<T, ChannelAggregateArgs>): Prisma.PrismaPromise<GetChannelAggregateType<T>>

    /**
     * Group by Channel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelGroupByArgs['orderBy'] }
        : { orderBy?: ChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Channel model
   */
  readonly fields: ChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Channel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Channel$membersArgs<ExtArgs> = {}>(args?: Subset<T, Channel$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    owner<T extends OwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OwnerDefaultArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends Channel$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Channel$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    prRecord<T extends Channel$prRecordArgs<ExtArgs> = {}>(args?: Subset<T, Channel$prRecordArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    meeting<T extends Channel$meetingArgs<ExtArgs> = {}>(args?: Subset<T, Channel$meetingArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    adminRole<T extends Channel$adminRoleArgs<ExtArgs> = {}>(args?: Subset<T, Channel$adminRoleArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    legalCase<T extends Channel$legalCaseArgs<ExtArgs> = {}>(args?: Subset<T, Channel$legalCaseArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Channel model
   */ 
  interface ChannelFieldRefs {
    readonly id: FieldRef<"Channel", 'String'>
    readonly name: FieldRef<"Channel", 'String'>
    readonly ownerId: FieldRef<"Channel", 'String'>
    readonly prRecordId: FieldRef<"Channel", 'String'>
    readonly meetingId: FieldRef<"Channel", 'String'>
    readonly adminRoleId: FieldRef<"Channel", 'String'>
    readonly legalCaseId: FieldRef<"Channel", 'String'>
    readonly createdAt: FieldRef<"Channel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Channel findUnique
   */
  export type ChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findUniqueOrThrow
   */
  export type ChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel findFirst
   */
  export type ChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findFirstOrThrow
   */
  export type ChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channel to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Channels.
     */
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel findMany
   */
  export type ChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter, which Channels to fetch.
     */
    where?: ChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Channels to fetch.
     */
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Channels.
     */
    cursor?: ChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Channels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Channels.
     */
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Channel create
   */
  export type ChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a Channel.
     */
    data: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
  }

  /**
   * Channel createMany
   */
  export type ChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Channel createManyAndReturn
   */
  export type ChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Channels.
     */
    data: ChannelCreateManyInput | ChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Channel update
   */
  export type ChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a Channel.
     */
    data: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
    /**
     * Choose, which Channel to update.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel updateMany
   */
  export type ChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Channels.
     */
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyInput>
    /**
     * Filter which Channels to update
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel upsert
   */
  export type ChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the Channel to update in case it exists.
     */
    where: ChannelWhereUniqueInput
    /**
     * In case the Channel found by the `where` argument doesn't exist, create a new Channel with this data.
     */
    create: XOR<ChannelCreateInput, ChannelUncheckedCreateInput>
    /**
     * In case the Channel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelUpdateInput, ChannelUncheckedUpdateInput>
  }

  /**
   * Channel delete
   */
  export type ChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    /**
     * Filter which Channel to delete.
     */
    where: ChannelWhereUniqueInput
  }

  /**
   * Channel deleteMany
   */
  export type ChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Channels to delete
     */
    where?: ChannelWhereInput
  }

  /**
   * Channel.members
   */
  export type Channel$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Channel.messages
   */
  export type Channel$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Channel.prRecord
   */
  export type Channel$prRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    where?: PublicRelationsRecordWhereInput
  }

  /**
   * Channel.meeting
   */
  export type Channel$meetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
  }

  /**
   * Channel.adminRole
   */
  export type Channel$adminRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    where?: AdminRoleWhereInput
  }

  /**
   * Channel.legalCase
   */
  export type Channel$legalCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    where?: LegalCaseWhereInput
  }

  /**
   * Channel without action
   */
  export type ChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
  }


  /**
   * Model Owner
   */

  export type AggregateOwner = {
    _count: OwnerCountAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  export type OwnerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type OwnerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type OwnerCountAggregateOutputType = {
    id: number
    userId: number
    createdAt: number
    _all: number
  }


  export type OwnerMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
  }

  export type OwnerMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
  }

  export type OwnerCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type OwnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owner to aggregate.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Owners
    **/
    _count?: true | OwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnerMaxAggregateInputType
  }

  export type GetOwnerAggregateType<T extends OwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwner[P]>
      : GetScalarType<T[P], AggregateOwner[P]>
  }




  export type OwnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnerWhereInput
    orderBy?: OwnerOrderByWithAggregationInput | OwnerOrderByWithAggregationInput[]
    by: OwnerScalarFieldEnum[] | OwnerScalarFieldEnum
    having?: OwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnerCountAggregateInputType | true
    _min?: OwnerMinAggregateInputType
    _max?: OwnerMaxAggregateInputType
  }

  export type OwnerGroupByOutputType = {
    id: string
    userId: string
    createdAt: Date
    _count: OwnerCountAggregateOutputType | null
    _min: OwnerMinAggregateOutputType | null
    _max: OwnerMaxAggregateOutputType | null
  }

  type GetOwnerGroupByPayload<T extends OwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnerGroupByOutputType[P]>
            : GetScalarType<T[P], OwnerGroupByOutputType[P]>
        }
      >
    >


  export type OwnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Channel?: boolean | Owner$ChannelArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["owner"]>

  export type OwnerSelectScalar = {
    id?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type OwnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Channel?: boolean | Owner$ChannelArgs<ExtArgs>
    _count?: boolean | OwnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OwnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OwnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Owner"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Channel: Prisma.$ChannelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["owner"]>
    composites: {}
  }

  type OwnerGetPayload<S extends boolean | null | undefined | OwnerDefaultArgs> = $Result.GetResult<Prisma.$OwnerPayload, S>

  type OwnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OwnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OwnerCountAggregateInputType | true
    }

  export interface OwnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Owner'], meta: { name: 'Owner' } }
    /**
     * Find zero or one Owner that matches the filter.
     * @param {OwnerFindUniqueArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnerFindUniqueArgs>(args: SelectSubset<T, OwnerFindUniqueArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Owner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OwnerFindUniqueOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnerFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Owner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnerFindFirstArgs>(args?: SelectSubset<T, OwnerFindFirstArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Owner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindFirstOrThrowArgs} args - Arguments to find a Owner
     * @example
     * // Get one Owner
     * const owner = await prisma.owner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnerFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Owners
     * const owners = await prisma.owner.findMany()
     * 
     * // Get first 10 Owners
     * const owners = await prisma.owner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownerWithIdOnly = await prisma.owner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnerFindManyArgs>(args?: SelectSubset<T, OwnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Owner.
     * @param {OwnerCreateArgs} args - Arguments to create a Owner.
     * @example
     * // Create one Owner
     * const Owner = await prisma.owner.create({
     *   data: {
     *     // ... data to create a Owner
     *   }
     * })
     * 
     */
    create<T extends OwnerCreateArgs>(args: SelectSubset<T, OwnerCreateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Owners.
     * @param {OwnerCreateManyArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnerCreateManyArgs>(args?: SelectSubset<T, OwnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Owners and returns the data saved in the database.
     * @param {OwnerCreateManyAndReturnArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owner = await prisma.owner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Owners and only return the `id`
     * const ownerWithIdOnly = await prisma.owner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnerCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Owner.
     * @param {OwnerDeleteArgs} args - Arguments to delete one Owner.
     * @example
     * // Delete one Owner
     * const Owner = await prisma.owner.delete({
     *   where: {
     *     // ... filter to delete one Owner
     *   }
     * })
     * 
     */
    delete<T extends OwnerDeleteArgs>(args: SelectSubset<T, OwnerDeleteArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Owner.
     * @param {OwnerUpdateArgs} args - Arguments to update one Owner.
     * @example
     * // Update one Owner
     * const owner = await prisma.owner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnerUpdateArgs>(args: SelectSubset<T, OwnerUpdateArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Owners.
     * @param {OwnerDeleteManyArgs} args - Arguments to filter Owners to delete.
     * @example
     * // Delete a few Owners
     * const { count } = await prisma.owner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnerDeleteManyArgs>(args?: SelectSubset<T, OwnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Owners
     * const owner = await prisma.owner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnerUpdateManyArgs>(args: SelectSubset<T, OwnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Owner.
     * @param {OwnerUpsertArgs} args - Arguments to update or create a Owner.
     * @example
     * // Update or create a Owner
     * const owner = await prisma.owner.upsert({
     *   create: {
     *     // ... data to create a Owner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Owner we want to update
     *   }
     * })
     */
    upsert<T extends OwnerUpsertArgs>(args: SelectSubset<T, OwnerUpsertArgs<ExtArgs>>): Prisma__OwnerClient<$Result.GetResult<Prisma.$OwnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerCountArgs} args - Arguments to filter Owners to count.
     * @example
     * // Count the number of Owners
     * const count = await prisma.owner.count({
     *   where: {
     *     // ... the filter for the Owners we want to count
     *   }
     * })
    **/
    count<T extends OwnerCountArgs>(
      args?: Subset<T, OwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnerAggregateArgs>(args: Subset<T, OwnerAggregateArgs>): Prisma.PrismaPromise<GetOwnerAggregateType<T>>

    /**
     * Group by Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnerGroupByArgs['orderBy'] }
        : { orderBy?: OwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Owner model
   */
  readonly fields: OwnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Owner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Channel<T extends Owner$ChannelArgs<ExtArgs> = {}>(args?: Subset<T, Owner$ChannelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Owner model
   */ 
  interface OwnerFieldRefs {
    readonly id: FieldRef<"Owner", 'String'>
    readonly userId: FieldRef<"Owner", 'String'>
    readonly createdAt: FieldRef<"Owner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Owner findUnique
   */
  export type OwnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findUniqueOrThrow
   */
  export type OwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner findFirst
   */
  export type OwnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findFirstOrThrow
   */
  export type OwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owner to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Owners.
     */
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner findMany
   */
  export type OwnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter, which Owners to fetch.
     */
    where?: OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Owners to fetch.
     */
    orderBy?: OwnerOrderByWithRelationInput | OwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Owners.
     */
    cursor?: OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Owners.
     */
    skip?: number
    distinct?: OwnerScalarFieldEnum | OwnerScalarFieldEnum[]
  }

  /**
   * Owner create
   */
  export type OwnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Owner.
     */
    data: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
  }

  /**
   * Owner createMany
   */
  export type OwnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Owner createManyAndReturn
   */
  export type OwnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Owners.
     */
    data: OwnerCreateManyInput | OwnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Owner update
   */
  export type OwnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Owner.
     */
    data: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
    /**
     * Choose, which Owner to update.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner updateMany
   */
  export type OwnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Owners.
     */
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyInput>
    /**
     * Filter which Owners to update
     */
    where?: OwnerWhereInput
  }

  /**
   * Owner upsert
   */
  export type OwnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Owner to update in case it exists.
     */
    where: OwnerWhereUniqueInput
    /**
     * In case the Owner found by the `where` argument doesn't exist, create a new Owner with this data.
     */
    create: XOR<OwnerCreateInput, OwnerUncheckedCreateInput>
    /**
     * In case the Owner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnerUpdateInput, OwnerUncheckedUpdateInput>
  }

  /**
   * Owner delete
   */
  export type OwnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
    /**
     * Filter which Owner to delete.
     */
    where: OwnerWhereUniqueInput
  }

  /**
   * Owner deleteMany
   */
  export type OwnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Owners to delete
     */
    where?: OwnerWhereInput
  }

  /**
   * Owner.Channel
   */
  export type Owner$ChannelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Owner without action
   */
  export type OwnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Owner
     */
    select?: OwnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnerInclude<ExtArgs> | null
  }


  /**
   * Model Bookmark
   */

  export type AggregateBookmark = {
    _count: BookmarkCountAggregateOutputType | null
    _min: BookmarkMinAggregateOutputType | null
    _max: BookmarkMaxAggregateOutputType | null
  }

  export type BookmarkMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    itemId: string | null
    createdAt: Date | null
  }

  export type BookmarkMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    itemId: string | null
    createdAt: Date | null
  }

  export type BookmarkCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    itemId: number
    createdAt: number
    _all: number
  }


  export type BookmarkMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    itemId?: true
    createdAt?: true
  }

  export type BookmarkMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    itemId?: true
    createdAt?: true
  }

  export type BookmarkCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    itemId?: true
    createdAt?: true
    _all?: true
  }

  export type BookmarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmark to aggregate.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookmarks
    **/
    _count?: true | BookmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookmarkMaxAggregateInputType
  }

  export type GetBookmarkAggregateType<T extends BookmarkAggregateArgs> = {
        [P in keyof T & keyof AggregateBookmark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookmark[P]>
      : GetScalarType<T[P], AggregateBookmark[P]>
  }




  export type BookmarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithAggregationInput | BookmarkOrderByWithAggregationInput[]
    by: BookmarkScalarFieldEnum[] | BookmarkScalarFieldEnum
    having?: BookmarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookmarkCountAggregateInputType | true
    _min?: BookmarkMinAggregateInputType
    _max?: BookmarkMaxAggregateInputType
  }

  export type BookmarkGroupByOutputType = {
    id: string
    userId: string
    type: string
    itemId: string
    createdAt: Date
    _count: BookmarkCountAggregateOutputType | null
    _min: BookmarkMinAggregateOutputType | null
    _max: BookmarkMaxAggregateOutputType | null
  }

  type GetBookmarkGroupByPayload<T extends BookmarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookmarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookmarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookmarkGroupByOutputType[P]>
            : GetScalarType<T[P], BookmarkGroupByOutputType[P]>
        }
      >
    >


  export type BookmarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    itemId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmark"]>

  export type BookmarkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    itemId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmark"]>

  export type BookmarkSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    itemId?: boolean
    createdAt?: boolean
  }

  export type BookmarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookmarkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookmarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bookmark"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      itemId: string
      createdAt: Date
    }, ExtArgs["result"]["bookmark"]>
    composites: {}
  }

  type BookmarkGetPayload<S extends boolean | null | undefined | BookmarkDefaultArgs> = $Result.GetResult<Prisma.$BookmarkPayload, S>

  type BookmarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookmarkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookmarkCountAggregateInputType | true
    }

  export interface BookmarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bookmark'], meta: { name: 'Bookmark' } }
    /**
     * Find zero or one Bookmark that matches the filter.
     * @param {BookmarkFindUniqueArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookmarkFindUniqueArgs>(args: SelectSubset<T, BookmarkFindUniqueArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bookmark that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookmarkFindUniqueOrThrowArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookmarkFindUniqueOrThrowArgs>(args: SelectSubset<T, BookmarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bookmark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindFirstArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookmarkFindFirstArgs>(args?: SelectSubset<T, BookmarkFindFirstArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bookmark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindFirstOrThrowArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookmarkFindFirstOrThrowArgs>(args?: SelectSubset<T, BookmarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookmarks
     * const bookmarks = await prisma.bookmark.findMany()
     * 
     * // Get first 10 Bookmarks
     * const bookmarks = await prisma.bookmark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookmarkWithIdOnly = await prisma.bookmark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookmarkFindManyArgs>(args?: SelectSubset<T, BookmarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bookmark.
     * @param {BookmarkCreateArgs} args - Arguments to create a Bookmark.
     * @example
     * // Create one Bookmark
     * const Bookmark = await prisma.bookmark.create({
     *   data: {
     *     // ... data to create a Bookmark
     *   }
     * })
     * 
     */
    create<T extends BookmarkCreateArgs>(args: SelectSubset<T, BookmarkCreateArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookmarks.
     * @param {BookmarkCreateManyArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmark = await prisma.bookmark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookmarkCreateManyArgs>(args?: SelectSubset<T, BookmarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookmarks and returns the data saved in the database.
     * @param {BookmarkCreateManyAndReturnArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmark = await prisma.bookmark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookmarks and only return the `id`
     * const bookmarkWithIdOnly = await prisma.bookmark.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookmarkCreateManyAndReturnArgs>(args?: SelectSubset<T, BookmarkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bookmark.
     * @param {BookmarkDeleteArgs} args - Arguments to delete one Bookmark.
     * @example
     * // Delete one Bookmark
     * const Bookmark = await prisma.bookmark.delete({
     *   where: {
     *     // ... filter to delete one Bookmark
     *   }
     * })
     * 
     */
    delete<T extends BookmarkDeleteArgs>(args: SelectSubset<T, BookmarkDeleteArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bookmark.
     * @param {BookmarkUpdateArgs} args - Arguments to update one Bookmark.
     * @example
     * // Update one Bookmark
     * const bookmark = await prisma.bookmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookmarkUpdateArgs>(args: SelectSubset<T, BookmarkUpdateArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookmarks.
     * @param {BookmarkDeleteManyArgs} args - Arguments to filter Bookmarks to delete.
     * @example
     * // Delete a few Bookmarks
     * const { count } = await prisma.bookmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookmarkDeleteManyArgs>(args?: SelectSubset<T, BookmarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookmarks
     * const bookmark = await prisma.bookmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookmarkUpdateManyArgs>(args: SelectSubset<T, BookmarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bookmark.
     * @param {BookmarkUpsertArgs} args - Arguments to update or create a Bookmark.
     * @example
     * // Update or create a Bookmark
     * const bookmark = await prisma.bookmark.upsert({
     *   create: {
     *     // ... data to create a Bookmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookmark we want to update
     *   }
     * })
     */
    upsert<T extends BookmarkUpsertArgs>(args: SelectSubset<T, BookmarkUpsertArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCountArgs} args - Arguments to filter Bookmarks to count.
     * @example
     * // Count the number of Bookmarks
     * const count = await prisma.bookmark.count({
     *   where: {
     *     // ... the filter for the Bookmarks we want to count
     *   }
     * })
    **/
    count<T extends BookmarkCountArgs>(
      args?: Subset<T, BookmarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookmarkAggregateArgs>(args: Subset<T, BookmarkAggregateArgs>): Prisma.PrismaPromise<GetBookmarkAggregateType<T>>

    /**
     * Group by Bookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookmarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookmarkGroupByArgs['orderBy'] }
        : { orderBy?: BookmarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookmarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookmarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bookmark model
   */
  readonly fields: BookmarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bookmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookmarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bookmark model
   */ 
  interface BookmarkFieldRefs {
    readonly id: FieldRef<"Bookmark", 'String'>
    readonly userId: FieldRef<"Bookmark", 'String'>
    readonly type: FieldRef<"Bookmark", 'String'>
    readonly itemId: FieldRef<"Bookmark", 'String'>
    readonly createdAt: FieldRef<"Bookmark", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bookmark findUnique
   */
  export type BookmarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark findUniqueOrThrow
   */
  export type BookmarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark findFirst
   */
  export type BookmarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark findFirstOrThrow
   */
  export type BookmarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark findMany
   */
  export type BookmarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmarks to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark create
   */
  export type BookmarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The data needed to create a Bookmark.
     */
    data: XOR<BookmarkCreateInput, BookmarkUncheckedCreateInput>
  }

  /**
   * Bookmark createMany
   */
  export type BookmarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarkCreateManyInput | BookmarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bookmark createManyAndReturn
   */
  export type BookmarkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarkCreateManyInput | BookmarkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookmark update
   */
  export type BookmarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The data needed to update a Bookmark.
     */
    data: XOR<BookmarkUpdateInput, BookmarkUncheckedUpdateInput>
    /**
     * Choose, which Bookmark to update.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark updateMany
   */
  export type BookmarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookmarks.
     */
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyInput>
    /**
     * Filter which Bookmarks to update
     */
    where?: BookmarkWhereInput
  }

  /**
   * Bookmark upsert
   */
  export type BookmarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The filter to search for the Bookmark to update in case it exists.
     */
    where: BookmarkWhereUniqueInput
    /**
     * In case the Bookmark found by the `where` argument doesn't exist, create a new Bookmark with this data.
     */
    create: XOR<BookmarkCreateInput, BookmarkUncheckedCreateInput>
    /**
     * In case the Bookmark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookmarkUpdateInput, BookmarkUncheckedUpdateInput>
  }

  /**
   * Bookmark delete
   */
  export type BookmarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter which Bookmark to delete.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark deleteMany
   */
  export type BookmarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmarks to delete
     */
    where?: BookmarkWhereInput
  }

  /**
   * Bookmark without action
   */
  export type BookmarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    academyId: string | null
    prRecordId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startTime: Date | null
    endTime: Date | null
    academyId: string | null
    prRecordId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startTime: number
    endTime: number
    academyId: number
    prRecordId: number
    adminRoleId: number
    legalCaseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    academyId?: true
    prRecordId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    academyId?: true
    prRecordId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startTime?: true
    endTime?: true
    academyId?: true
    prRecordId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startTime: Date
    endTime: Date
    academyId: string
    prRecordId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    academyId?: boolean
    prRecordId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    prRecord?: boolean | Event$prRecordArgs<ExtArgs>
    adminRole?: boolean | Event$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Event$legalCaseArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    academyId?: boolean
    prRecordId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    prRecord?: boolean | Event$prRecordArgs<ExtArgs>
    adminRole?: boolean | Event$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Event$legalCaseArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    academyId?: boolean
    prRecordId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    prRecord?: boolean | Event$prRecordArgs<ExtArgs>
    adminRole?: boolean | Event$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Event$legalCaseArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    prRecord?: boolean | Event$prRecordArgs<ExtArgs>
    adminRole?: boolean | Event$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Event$legalCaseArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      academy: Prisma.$AcademyPayload<ExtArgs>
      prRecord: Prisma.$PublicRelationsRecordPayload<ExtArgs> | null
      adminRole: Prisma.$AdminRolePayload<ExtArgs> | null
      legalCase: Prisma.$LegalCasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startTime: Date
      endTime: Date
      academyId: string
      prRecordId: string | null
      adminRoleId: string | null
      legalCaseId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    academy<T extends AcademyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademyDefaultArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prRecord<T extends Event$prRecordArgs<ExtArgs> = {}>(args?: Subset<T, Event$prRecordArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    adminRole<T extends Event$adminRoleArgs<ExtArgs> = {}>(args?: Subset<T, Event$adminRoleArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    legalCase<T extends Event$legalCaseArgs<ExtArgs> = {}>(args?: Subset<T, Event$legalCaseArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly startTime: FieldRef<"Event", 'DateTime'>
    readonly endTime: FieldRef<"Event", 'DateTime'>
    readonly academyId: FieldRef<"Event", 'String'>
    readonly prRecordId: FieldRef<"Event", 'String'>
    readonly adminRoleId: FieldRef<"Event", 'String'>
    readonly legalCaseId: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.prRecord
   */
  export type Event$prRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    where?: PublicRelationsRecordWhereInput
  }

  /**
   * Event.adminRole
   */
  export type Event$adminRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    where?: AdminRoleWhereInput
  }

  /**
   * Event.legalCase
   */
  export type Event$legalCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    where?: LegalCaseWhereInput
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    lessonId: string | null
    status: string | null
    method: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    lessonId: string | null
    status: string | null
    method: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    studentId: number
    lessonId: number
    status: number
    method: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    studentId?: true
    lessonId?: true
    status?: true
    method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    studentId?: true
    lessonId?: true
    status?: true
    method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    studentId?: true
    lessonId?: true
    status?: true
    method?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    studentId: string
    lessonId: string
    status: string
    method: string
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    lessonId?: boolean
    status?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    lessonId?: boolean
    status?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    studentId?: boolean
    lessonId?: boolean
    status?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      student: Prisma.$UserPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      lessonId: string
      status: string
      method: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */ 
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly studentId: FieldRef<"Attendance", 'String'>
    readonly lessonId: FieldRef<"Attendance", 'String'>
    readonly status: FieldRef<"Attendance", 'String'>
    readonly method: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    legalCaseId: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    legalCaseId: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    legalCaseId: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    legalCaseId?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    legalCaseId?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    legalCaseId?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    amount: number
    legalCaseId: string | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    legalCase?: boolean | Payment$legalCaseArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    legalCase?: boolean | Payment$legalCaseArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    legalCase?: boolean | Payment$legalCaseArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    legalCase?: boolean | Payment$legalCaseArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      legalCase: Prisma.$LegalCasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      legalCaseId: string | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    legalCase<T extends Payment$legalCaseArgs<ExtArgs> = {}>(args?: Subset<T, Payment$legalCaseArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly legalCaseId: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.legalCase
   */
  export type Payment$legalCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    where?: LegalCaseWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountingEntryId: string | null
    meetingId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountingEntryId: string | null
    meetingId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    userId: number
    accountingEntryId: number
    meetingId: number
    adminRoleId: number
    legalCaseId: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    userId?: true
    accountingEntryId?: true
    meetingId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    userId?: true
    accountingEntryId?: true
    meetingId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    userId?: true
    accountingEntryId?: true
    meetingId?: true
    adminRoleId?: true
    legalCaseId?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    userId: string
    accountingEntryId: string | null
    meetingId: string | null
    adminRoleId: string | null
    legalCaseId: string | null
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountingEntryId?: boolean
    meetingId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountingEntry?: boolean | Report$accountingEntryArgs<ExtArgs>
    meeting?: boolean | Report$meetingArgs<ExtArgs>
    adminRole?: boolean | Report$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Report$legalCaseArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountingEntryId?: boolean
    meetingId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountingEntry?: boolean | Report$accountingEntryArgs<ExtArgs>
    meeting?: boolean | Report$meetingArgs<ExtArgs>
    adminRole?: boolean | Report$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Report$legalCaseArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    userId?: boolean
    accountingEntryId?: boolean
    meetingId?: boolean
    adminRoleId?: boolean
    legalCaseId?: boolean
    createdAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountingEntry?: boolean | Report$accountingEntryArgs<ExtArgs>
    meeting?: boolean | Report$meetingArgs<ExtArgs>
    adminRole?: boolean | Report$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Report$legalCaseArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    accountingEntry?: boolean | Report$accountingEntryArgs<ExtArgs>
    meeting?: boolean | Report$meetingArgs<ExtArgs>
    adminRole?: boolean | Report$adminRoleArgs<ExtArgs>
    legalCase?: boolean | Report$legalCaseArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      accountingEntry: Prisma.$AccountingEntryPayload<ExtArgs> | null
      meeting: Prisma.$MeetingPayload<ExtArgs> | null
      adminRole: Prisma.$AdminRolePayload<ExtArgs> | null
      legalCase: Prisma.$LegalCasePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountingEntryId: string | null
      meetingId: string | null
      adminRoleId: string | null
      legalCaseId: string | null
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    accountingEntry<T extends Report$accountingEntryArgs<ExtArgs> = {}>(args?: Subset<T, Report$accountingEntryArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    meeting<T extends Report$meetingArgs<ExtArgs> = {}>(args?: Subset<T, Report$meetingArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    adminRole<T extends Report$adminRoleArgs<ExtArgs> = {}>(args?: Subset<T, Report$adminRoleArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    legalCase<T extends Report$legalCaseArgs<ExtArgs> = {}>(args?: Subset<T, Report$legalCaseArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly userId: FieldRef<"Report", 'String'>
    readonly accountingEntryId: FieldRef<"Report", 'String'>
    readonly meetingId: FieldRef<"Report", 'String'>
    readonly adminRoleId: FieldRef<"Report", 'String'>
    readonly legalCaseId: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report.accountingEntry
   */
  export type Report$accountingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    where?: AccountingEntryWhereInput
  }

  /**
   * Report.meeting
   */
  export type Report$meetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
  }

  /**
   * Report.adminRole
   */
  export type Report$adminRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    where?: AdminRoleWhereInput
  }

  /**
   * Report.legalCase
   */
  export type Report$legalCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    where?: LegalCaseWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    points: number | null
  }

  export type BadgeSumAggregateOutputType = {
    points: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    image: string | null
    points: number | null
    type: string | null
    earnedAt: Date | null
    createdAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    description: string | null
    image: string | null
    points: number | null
    type: string | null
    earnedAt: Date | null
    createdAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    description: number
    image: number
    points: number
    type: number
    earnedAt: number
    createdAt: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    points?: true
  }

  export type BadgeSumAggregateInputType = {
    points?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    image?: true
    points?: true
    type?: true
    earnedAt?: true
    createdAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    image?: true
    points?: true
    type?: true
    earnedAt?: true
    createdAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    description?: true
    image?: true
    points?: true
    type?: true
    earnedAt?: true
    createdAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    userId: string
    title: string
    description: string | null
    image: string | null
    points: number
    type: string
    earnedAt: Date
    createdAt: Date
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    points?: boolean
    type?: boolean
    earnedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    points?: boolean
    type?: boolean
    earnedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    points?: boolean
    type?: boolean
    earnedAt?: boolean
    createdAt?: boolean
  }

  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      description: string | null
      image: string | null
      points: number
      type: string
      earnedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */ 
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly userId: FieldRef<"Badge", 'String'>
    readonly title: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly image: FieldRef<"Badge", 'String'>
    readonly points: FieldRef<"Badge", 'Int'>
    readonly type: FieldRef<"Badge", 'String'>
    readonly earnedAt: FieldRef<"Badge", 'DateTime'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateAvgAggregateOutputType = {
    points: number | null
  }

  export type CertificateSumAggregateOutputType = {
    points: number | null
  }

  export type CertificateMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    notes: string | null
    userId: string | null
    title: string | null
    description: string | null
    url: string | null
    image: string | null
    points: number | null
    type: string | null
    earnedAt: Date | null
    createdAt: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    notes: string | null
    userId: string | null
    title: string | null
    description: string | null
    url: string | null
    image: string | null
    points: number | null
    type: string | null
    earnedAt: Date | null
    createdAt: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    notes: number
    userId: number
    title: number
    description: number
    url: number
    image: number
    points: number
    type: number
    earnedAt: number
    createdAt: number
    _all: number
  }


  export type CertificateAvgAggregateInputType = {
    points?: true
  }

  export type CertificateSumAggregateInputType = {
    points?: true
  }

  export type CertificateMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    notes?: true
    userId?: true
    title?: true
    description?: true
    url?: true
    image?: true
    points?: true
    type?: true
    earnedAt?: true
    createdAt?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    notes?: true
    userId?: true
    title?: true
    description?: true
    url?: true
    image?: true
    points?: true
    type?: true
    earnedAt?: true
    createdAt?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    notes?: true
    userId?: true
    title?: true
    description?: true
    url?: true
    image?: true
    points?: true
    type?: true
    earnedAt?: true
    createdAt?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _avg?: CertificateAvgAggregateInputType
    _sum?: CertificateSumAggregateInputType
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: string
    name: string
    address: string
    phone: string
    notes: string
    userId: string
    title: string
    description: string | null
    url: string | null
    image: string | null
    points: number
    type: string
    earnedAt: Date
    createdAt: Date
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    notes?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    image?: boolean
    points?: boolean
    type?: boolean
    earnedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    notes?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    image?: boolean
    points?: boolean
    type?: boolean
    earnedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    notes?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    url?: boolean
    image?: boolean
    points?: boolean
    type?: boolean
    earnedAt?: boolean
    createdAt?: boolean
  }

  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      phone: string
      notes: string
      userId: string
      title: string
      description: string | null
      url: string | null
      image: string | null
      points: number
      type: string
      earnedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */ 
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'String'>
    readonly name: FieldRef<"Certificate", 'String'>
    readonly address: FieldRef<"Certificate", 'String'>
    readonly phone: FieldRef<"Certificate", 'String'>
    readonly notes: FieldRef<"Certificate", 'String'>
    readonly userId: FieldRef<"Certificate", 'String'>
    readonly title: FieldRef<"Certificate", 'String'>
    readonly description: FieldRef<"Certificate", 'String'>
    readonly url: FieldRef<"Certificate", 'String'>
    readonly image: FieldRef<"Certificate", 'String'>
    readonly points: FieldRef<"Certificate", 'Int'>
    readonly type: FieldRef<"Certificate", 'String'>
    readonly earnedAt: FieldRef<"Certificate", 'DateTime'>
    readonly createdAt: FieldRef<"Certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model Community
   */

  export type AggregateCommunity = {
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  export type CommunityAvgAggregateOutputType = {
    likes: number | null
    dislikes: number | null
    views: number | null
  }

  export type CommunitySumAggregateOutputType = {
    likes: number | null
    dislikes: number | null
    views: number | null
  }

  export type CommunityMinAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    description: string | null
    type: string | null
    likes: number | null
    dislikes: number | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    image: string | null
    description: string | null
    type: string | null
    likes: number | null
    dislikes: number | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityCountAggregateOutputType = {
    id: number
    name: number
    image: number
    description: number
    type: number
    likes: number
    dislikes: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityAvgAggregateInputType = {
    likes?: true
    dislikes?: true
    views?: true
  }

  export type CommunitySumAggregateInputType = {
    likes?: true
    dislikes?: true
    views?: true
  }

  export type CommunityMinAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    type?: true
    likes?: true
    dislikes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityMaxAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    type?: true
    likes?: true
    dislikes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityCountAggregateInputType = {
    id?: true
    name?: true
    image?: true
    description?: true
    type?: true
    likes?: true
    dislikes?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Community to aggregate.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communities
    **/
    _count?: true | CommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMaxAggregateInputType
  }

  export type GetCommunityAggregateType<T extends CommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunity[P]>
      : GetScalarType<T[P], AggregateCommunity[P]>
  }




  export type CommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithAggregationInput | CommunityOrderByWithAggregationInput[]
    by: CommunityScalarFieldEnum[] | CommunityScalarFieldEnum
    having?: CommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCountAggregateInputType | true
    _avg?: CommunityAvgAggregateInputType
    _sum?: CommunitySumAggregateInputType
    _min?: CommunityMinAggregateInputType
    _max?: CommunityMaxAggregateInputType
  }

  export type CommunityGroupByOutputType = {
    id: string
    name: string
    image: string | null
    description: string | null
    type: string
    likes: number
    dislikes: number
    views: number
    createdAt: Date
    updatedAt: Date
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  type GetCommunityGroupByPayload<T extends CommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGroupByOutputType[P]>
        }
      >
    >


  export type CommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    type?: boolean
    likes?: boolean
    dislikes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    groups?: boolean | Community$groupsArgs<ExtArgs>
    liveRoom?: boolean | Community$liveRoomArgs<ExtArgs>
    participants?: boolean | Community$participantsArgs<ExtArgs>
    posts?: boolean | Community$postsArgs<ExtArgs>
    discussions?: boolean | Community$discussionsArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    type?: boolean
    likes?: boolean
    dislikes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectScalar = {
    id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    type?: boolean
    likes?: boolean
    dislikes?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groups?: boolean | Community$groupsArgs<ExtArgs>
    liveRoom?: boolean | Community$liveRoomArgs<ExtArgs>
    participants?: boolean | Community$participantsArgs<ExtArgs>
    posts?: boolean | Community$postsArgs<ExtArgs>
    discussions?: boolean | Community$discussionsArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Community"
    objects: {
      groups: Prisma.$GroupPayload<ExtArgs>[]
      liveRoom: Prisma.$LiveRoomPayload<ExtArgs>[]
      participants: Prisma.$UserPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      discussions: Prisma.$DiscussionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      image: string | null
      description: string | null
      type: string
      likes: number
      dislikes: number
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["community"]>
    composites: {}
  }

  type CommunityGetPayload<S extends boolean | null | undefined | CommunityDefaultArgs> = $Result.GetResult<Prisma.$CommunityPayload, S>

  type CommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunityCountAggregateInputType | true
    }

  export interface CommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Community'], meta: { name: 'Community' } }
    /**
     * Find zero or one Community that matches the filter.
     * @param {CommunityFindUniqueArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityFindUniqueArgs>(args: SelectSubset<T, CommunityFindUniqueArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Community that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommunityFindUniqueOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Community that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityFindFirstArgs>(args?: SelectSubset<T, CommunityFindFirstArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Community that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Communities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communities
     * const communities = await prisma.community.findMany()
     * 
     * // Get first 10 Communities
     * const communities = await prisma.community.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityWithIdOnly = await prisma.community.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityFindManyArgs>(args?: SelectSubset<T, CommunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Community.
     * @param {CommunityCreateArgs} args - Arguments to create a Community.
     * @example
     * // Create one Community
     * const Community = await prisma.community.create({
     *   data: {
     *     // ... data to create a Community
     *   }
     * })
     * 
     */
    create<T extends CommunityCreateArgs>(args: SelectSubset<T, CommunityCreateArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Communities.
     * @param {CommunityCreateManyArgs} args - Arguments to create many Communities.
     * @example
     * // Create many Communities
     * const community = await prisma.community.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityCreateManyArgs>(args?: SelectSubset<T, CommunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Communities and returns the data saved in the database.
     * @param {CommunityCreateManyAndReturnArgs} args - Arguments to create many Communities.
     * @example
     * // Create many Communities
     * const community = await prisma.community.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Communities and only return the `id`
     * const communityWithIdOnly = await prisma.community.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Community.
     * @param {CommunityDeleteArgs} args - Arguments to delete one Community.
     * @example
     * // Delete one Community
     * const Community = await prisma.community.delete({
     *   where: {
     *     // ... filter to delete one Community
     *   }
     * })
     * 
     */
    delete<T extends CommunityDeleteArgs>(args: SelectSubset<T, CommunityDeleteArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Community.
     * @param {CommunityUpdateArgs} args - Arguments to update one Community.
     * @example
     * // Update one Community
     * const community = await prisma.community.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityUpdateArgs>(args: SelectSubset<T, CommunityUpdateArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Communities.
     * @param {CommunityDeleteManyArgs} args - Arguments to filter Communities to delete.
     * @example
     * // Delete a few Communities
     * const { count } = await prisma.community.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityDeleteManyArgs>(args?: SelectSubset<T, CommunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityUpdateManyArgs>(args: SelectSubset<T, CommunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Community.
     * @param {CommunityUpsertArgs} args - Arguments to update or create a Community.
     * @example
     * // Update or create a Community
     * const community = await prisma.community.upsert({
     *   create: {
     *     // ... data to create a Community
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Community we want to update
     *   }
     * })
     */
    upsert<T extends CommunityUpsertArgs>(args: SelectSubset<T, CommunityUpsertArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCountArgs} args - Arguments to filter Communities to count.
     * @example
     * // Count the number of Communities
     * const count = await prisma.community.count({
     *   where: {
     *     // ... the filter for the Communities we want to count
     *   }
     * })
    **/
    count<T extends CommunityCountArgs>(
      args?: Subset<T, CommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityAggregateArgs>(args: Subset<T, CommunityAggregateArgs>): Prisma.PrismaPromise<GetCommunityAggregateType<T>>

    /**
     * Group by Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Community model
   */
  readonly fields: CommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Community.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groups<T extends Community$groupsArgs<ExtArgs> = {}>(args?: Subset<T, Community$groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupPayload<ExtArgs>, T, "findMany"> | Null>
    liveRoom<T extends Community$liveRoomArgs<ExtArgs> = {}>(args?: Subset<T, Community$liveRoomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "findMany"> | Null>
    participants<T extends Community$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Community$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends Community$postsArgs<ExtArgs> = {}>(args?: Subset<T, Community$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    discussions<T extends Community$discussionsArgs<ExtArgs> = {}>(args?: Subset<T, Community$discussionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Community model
   */ 
  interface CommunityFieldRefs {
    readonly id: FieldRef<"Community", 'String'>
    readonly name: FieldRef<"Community", 'String'>
    readonly image: FieldRef<"Community", 'String'>
    readonly description: FieldRef<"Community", 'String'>
    readonly type: FieldRef<"Community", 'String'>
    readonly likes: FieldRef<"Community", 'Int'>
    readonly dislikes: FieldRef<"Community", 'Int'>
    readonly views: FieldRef<"Community", 'Int'>
    readonly createdAt: FieldRef<"Community", 'DateTime'>
    readonly updatedAt: FieldRef<"Community", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Community findUnique
   */
  export type CommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findUniqueOrThrow
   */
  export type CommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findFirst
   */
  export type CommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findFirstOrThrow
   */
  export type CommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findMany
   */
  export type CommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Communities to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community create
   */
  export type CommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Community.
     */
    data: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
  }

  /**
   * Community createMany
   */
  export type CommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Community createManyAndReturn
   */
  export type CommunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Community update
   */
  export type CommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Community.
     */
    data: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
    /**
     * Choose, which Community to update.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community updateMany
   */
  export type CommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
  }

  /**
   * Community upsert
   */
  export type CommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Community to update in case it exists.
     */
    where: CommunityWhereUniqueInput
    /**
     * In case the Community found by the `where` argument doesn't exist, create a new Community with this data.
     */
    create: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
    /**
     * In case the Community was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
  }

  /**
   * Community delete
   */
  export type CommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter which Community to delete.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community deleteMany
   */
  export type CommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communities to delete
     */
    where?: CommunityWhereInput
  }

  /**
   * Community.groups
   */
  export type Community$groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Group
     */
    select?: GroupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupInclude<ExtArgs> | null
    where?: GroupWhereInput
    orderBy?: GroupOrderByWithRelationInput | GroupOrderByWithRelationInput[]
    cursor?: GroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }

  /**
   * Community.liveRoom
   */
  export type Community$liveRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    where?: LiveRoomWhereInput
    orderBy?: LiveRoomOrderByWithRelationInput | LiveRoomOrderByWithRelationInput[]
    cursor?: LiveRoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LiveRoomScalarFieldEnum | LiveRoomScalarFieldEnum[]
  }

  /**
   * Community.participants
   */
  export type Community$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Community.posts
   */
  export type Community$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Community.discussions
   */
  export type Community$discussionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    where?: DiscussionWhereInput
    orderBy?: DiscussionOrderByWithRelationInput | DiscussionOrderByWithRelationInput[]
    cursor?: DiscussionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscussionScalarFieldEnum | DiscussionScalarFieldEnum[]
  }

  /**
   * Community without action
   */
  export type CommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
  }


  /**
   * Model Discussion
   */

  export type AggregateDiscussion = {
    _count: DiscussionCountAggregateOutputType | null
    _min: DiscussionMinAggregateOutputType | null
    _max: DiscussionMaxAggregateOutputType | null
  }

  export type DiscussionMinAggregateOutputType = {
    id: string | null
    communityId: string | null
    postId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscussionMaxAggregateOutputType = {
    id: string | null
    communityId: string | null
    postId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscussionCountAggregateOutputType = {
    id: number
    communityId: number
    postId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiscussionMinAggregateInputType = {
    id?: true
    communityId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscussionMaxAggregateInputType = {
    id?: true
    communityId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscussionCountAggregateInputType = {
    id?: true
    communityId?: true
    postId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiscussionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discussion to aggregate.
     */
    where?: DiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discussions to fetch.
     */
    orderBy?: DiscussionOrderByWithRelationInput | DiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discussions
    **/
    _count?: true | DiscussionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscussionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscussionMaxAggregateInputType
  }

  export type GetDiscussionAggregateType<T extends DiscussionAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscussion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscussion[P]>
      : GetScalarType<T[P], AggregateDiscussion[P]>
  }




  export type DiscussionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscussionWhereInput
    orderBy?: DiscussionOrderByWithAggregationInput | DiscussionOrderByWithAggregationInput[]
    by: DiscussionScalarFieldEnum[] | DiscussionScalarFieldEnum
    having?: DiscussionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscussionCountAggregateInputType | true
    _min?: DiscussionMinAggregateInputType
    _max?: DiscussionMaxAggregateInputType
  }

  export type DiscussionGroupByOutputType = {
    id: string
    communityId: string
    postId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DiscussionCountAggregateOutputType | null
    _min: DiscussionMinAggregateOutputType | null
    _max: DiscussionMaxAggregateOutputType | null
  }

  type GetDiscussionGroupByPayload<T extends DiscussionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscussionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscussionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscussionGroupByOutputType[P]>
            : GetScalarType<T[P], DiscussionGroupByOutputType[P]>
        }
      >
    >


  export type DiscussionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    post?: boolean | Discussion$postArgs<ExtArgs>
  }, ExtArgs["result"]["discussion"]>

  export type DiscussionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    post?: boolean | Discussion$postArgs<ExtArgs>
  }, ExtArgs["result"]["discussion"]>

  export type DiscussionSelectScalar = {
    id?: boolean
    communityId?: boolean
    postId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiscussionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    post?: boolean | Discussion$postArgs<ExtArgs>
  }
  export type DiscussionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    post?: boolean | Discussion$postArgs<ExtArgs>
  }

  export type $DiscussionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Discussion"
    objects: {
      community: Prisma.$CommunityPayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      communityId: string
      postId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["discussion"]>
    composites: {}
  }

  type DiscussionGetPayload<S extends boolean | null | undefined | DiscussionDefaultArgs> = $Result.GetResult<Prisma.$DiscussionPayload, S>

  type DiscussionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiscussionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiscussionCountAggregateInputType | true
    }

  export interface DiscussionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Discussion'], meta: { name: 'Discussion' } }
    /**
     * Find zero or one Discussion that matches the filter.
     * @param {DiscussionFindUniqueArgs} args - Arguments to find a Discussion
     * @example
     * // Get one Discussion
     * const discussion = await prisma.discussion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscussionFindUniqueArgs>(args: SelectSubset<T, DiscussionFindUniqueArgs<ExtArgs>>): Prisma__DiscussionClient<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Discussion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiscussionFindUniqueOrThrowArgs} args - Arguments to find a Discussion
     * @example
     * // Get one Discussion
     * const discussion = await prisma.discussion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscussionFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscussionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscussionClient<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Discussion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionFindFirstArgs} args - Arguments to find a Discussion
     * @example
     * // Get one Discussion
     * const discussion = await prisma.discussion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscussionFindFirstArgs>(args?: SelectSubset<T, DiscussionFindFirstArgs<ExtArgs>>): Prisma__DiscussionClient<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Discussion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionFindFirstOrThrowArgs} args - Arguments to find a Discussion
     * @example
     * // Get one Discussion
     * const discussion = await prisma.discussion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscussionFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscussionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscussionClient<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Discussions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discussions
     * const discussions = await prisma.discussion.findMany()
     * 
     * // Get first 10 Discussions
     * const discussions = await prisma.discussion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discussionWithIdOnly = await prisma.discussion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscussionFindManyArgs>(args?: SelectSubset<T, DiscussionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Discussion.
     * @param {DiscussionCreateArgs} args - Arguments to create a Discussion.
     * @example
     * // Create one Discussion
     * const Discussion = await prisma.discussion.create({
     *   data: {
     *     // ... data to create a Discussion
     *   }
     * })
     * 
     */
    create<T extends DiscussionCreateArgs>(args: SelectSubset<T, DiscussionCreateArgs<ExtArgs>>): Prisma__DiscussionClient<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Discussions.
     * @param {DiscussionCreateManyArgs} args - Arguments to create many Discussions.
     * @example
     * // Create many Discussions
     * const discussion = await prisma.discussion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscussionCreateManyArgs>(args?: SelectSubset<T, DiscussionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Discussions and returns the data saved in the database.
     * @param {DiscussionCreateManyAndReturnArgs} args - Arguments to create many Discussions.
     * @example
     * // Create many Discussions
     * const discussion = await prisma.discussion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Discussions and only return the `id`
     * const discussionWithIdOnly = await prisma.discussion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscussionCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscussionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Discussion.
     * @param {DiscussionDeleteArgs} args - Arguments to delete one Discussion.
     * @example
     * // Delete one Discussion
     * const Discussion = await prisma.discussion.delete({
     *   where: {
     *     // ... filter to delete one Discussion
     *   }
     * })
     * 
     */
    delete<T extends DiscussionDeleteArgs>(args: SelectSubset<T, DiscussionDeleteArgs<ExtArgs>>): Prisma__DiscussionClient<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Discussion.
     * @param {DiscussionUpdateArgs} args - Arguments to update one Discussion.
     * @example
     * // Update one Discussion
     * const discussion = await prisma.discussion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscussionUpdateArgs>(args: SelectSubset<T, DiscussionUpdateArgs<ExtArgs>>): Prisma__DiscussionClient<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Discussions.
     * @param {DiscussionDeleteManyArgs} args - Arguments to filter Discussions to delete.
     * @example
     * // Delete a few Discussions
     * const { count } = await prisma.discussion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscussionDeleteManyArgs>(args?: SelectSubset<T, DiscussionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discussions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discussions
     * const discussion = await prisma.discussion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscussionUpdateManyArgs>(args: SelectSubset<T, DiscussionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Discussion.
     * @param {DiscussionUpsertArgs} args - Arguments to update or create a Discussion.
     * @example
     * // Update or create a Discussion
     * const discussion = await prisma.discussion.upsert({
     *   create: {
     *     // ... data to create a Discussion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discussion we want to update
     *   }
     * })
     */
    upsert<T extends DiscussionUpsertArgs>(args: SelectSubset<T, DiscussionUpsertArgs<ExtArgs>>): Prisma__DiscussionClient<$Result.GetResult<Prisma.$DiscussionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Discussions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionCountArgs} args - Arguments to filter Discussions to count.
     * @example
     * // Count the number of Discussions
     * const count = await prisma.discussion.count({
     *   where: {
     *     // ... the filter for the Discussions we want to count
     *   }
     * })
    **/
    count<T extends DiscussionCountArgs>(
      args?: Subset<T, DiscussionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscussionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discussion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscussionAggregateArgs>(args: Subset<T, DiscussionAggregateArgs>): Prisma.PrismaPromise<GetDiscussionAggregateType<T>>

    /**
     * Group by Discussion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscussionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscussionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscussionGroupByArgs['orderBy'] }
        : { orderBy?: DiscussionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscussionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscussionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Discussion model
   */
  readonly fields: DiscussionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discussion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscussionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    post<T extends Discussion$postArgs<ExtArgs> = {}>(args?: Subset<T, Discussion$postArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Discussion model
   */ 
  interface DiscussionFieldRefs {
    readonly id: FieldRef<"Discussion", 'String'>
    readonly communityId: FieldRef<"Discussion", 'String'>
    readonly postId: FieldRef<"Discussion", 'String'>
    readonly createdAt: FieldRef<"Discussion", 'DateTime'>
    readonly updatedAt: FieldRef<"Discussion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Discussion findUnique
   */
  export type DiscussionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    /**
     * Filter, which Discussion to fetch.
     */
    where: DiscussionWhereUniqueInput
  }

  /**
   * Discussion findUniqueOrThrow
   */
  export type DiscussionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    /**
     * Filter, which Discussion to fetch.
     */
    where: DiscussionWhereUniqueInput
  }

  /**
   * Discussion findFirst
   */
  export type DiscussionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    /**
     * Filter, which Discussion to fetch.
     */
    where?: DiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discussions to fetch.
     */
    orderBy?: DiscussionOrderByWithRelationInput | DiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discussions.
     */
    cursor?: DiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discussions.
     */
    distinct?: DiscussionScalarFieldEnum | DiscussionScalarFieldEnum[]
  }

  /**
   * Discussion findFirstOrThrow
   */
  export type DiscussionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    /**
     * Filter, which Discussion to fetch.
     */
    where?: DiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discussions to fetch.
     */
    orderBy?: DiscussionOrderByWithRelationInput | DiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discussions.
     */
    cursor?: DiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discussions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discussions.
     */
    distinct?: DiscussionScalarFieldEnum | DiscussionScalarFieldEnum[]
  }

  /**
   * Discussion findMany
   */
  export type DiscussionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    /**
     * Filter, which Discussions to fetch.
     */
    where?: DiscussionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discussions to fetch.
     */
    orderBy?: DiscussionOrderByWithRelationInput | DiscussionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discussions.
     */
    cursor?: DiscussionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discussions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discussions.
     */
    skip?: number
    distinct?: DiscussionScalarFieldEnum | DiscussionScalarFieldEnum[]
  }

  /**
   * Discussion create
   */
  export type DiscussionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    /**
     * The data needed to create a Discussion.
     */
    data: XOR<DiscussionCreateInput, DiscussionUncheckedCreateInput>
  }

  /**
   * Discussion createMany
   */
  export type DiscussionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Discussions.
     */
    data: DiscussionCreateManyInput | DiscussionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discussion createManyAndReturn
   */
  export type DiscussionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Discussions.
     */
    data: DiscussionCreateManyInput | DiscussionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Discussion update
   */
  export type DiscussionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    /**
     * The data needed to update a Discussion.
     */
    data: XOR<DiscussionUpdateInput, DiscussionUncheckedUpdateInput>
    /**
     * Choose, which Discussion to update.
     */
    where: DiscussionWhereUniqueInput
  }

  /**
   * Discussion updateMany
   */
  export type DiscussionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Discussions.
     */
    data: XOR<DiscussionUpdateManyMutationInput, DiscussionUncheckedUpdateManyInput>
    /**
     * Filter which Discussions to update
     */
    where?: DiscussionWhereInput
  }

  /**
   * Discussion upsert
   */
  export type DiscussionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    /**
     * The filter to search for the Discussion to update in case it exists.
     */
    where: DiscussionWhereUniqueInput
    /**
     * In case the Discussion found by the `where` argument doesn't exist, create a new Discussion with this data.
     */
    create: XOR<DiscussionCreateInput, DiscussionUncheckedCreateInput>
    /**
     * In case the Discussion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscussionUpdateInput, DiscussionUncheckedUpdateInput>
  }

  /**
   * Discussion delete
   */
  export type DiscussionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
    /**
     * Filter which Discussion to delete.
     */
    where: DiscussionWhereUniqueInput
  }

  /**
   * Discussion deleteMany
   */
  export type DiscussionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discussions to delete
     */
    where?: DiscussionWhereInput
  }

  /**
   * Discussion.post
   */
  export type Discussion$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Discussion without action
   */
  export type DiscussionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discussion
     */
    select?: DiscussionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscussionInclude<ExtArgs> | null
  }


  /**
   * Model LiveRoom
   */

  export type AggregateLiveRoom = {
    _count: LiveRoomCountAggregateOutputType | null
    _avg: LiveRoomAvgAggregateOutputType | null
    _sum: LiveRoomSumAggregateOutputType | null
    _min: LiveRoomMinAggregateOutputType | null
    _max: LiveRoomMaxAggregateOutputType | null
  }

  export type LiveRoomAvgAggregateOutputType = {
    participants: number | null
  }

  export type LiveRoomSumAggregateOutputType = {
    participants: number | null
  }

  export type LiveRoomMinAggregateOutputType = {
    id: string | null
    title: string | null
    topic: string | null
    participants: number | null
    isLive: boolean | null
    isActive: boolean | null
    isPublic: boolean | null
    isPrivate: boolean | null
    isPasswordProtected: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    communityId: string | null
    courseId: string | null
  }

  export type LiveRoomMaxAggregateOutputType = {
    id: string | null
    title: string | null
    topic: string | null
    participants: number | null
    isLive: boolean | null
    isActive: boolean | null
    isPublic: boolean | null
    isPrivate: boolean | null
    isPasswordProtected: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    communityId: string | null
    courseId: string | null
  }

  export type LiveRoomCountAggregateOutputType = {
    id: number
    title: number
    topic: number
    participants: number
    isLive: number
    isActive: number
    isPublic: number
    isPrivate: number
    isPasswordProtected: number
    createdAt: number
    updatedAt: number
    communityId: number
    courseId: number
    _all: number
  }


  export type LiveRoomAvgAggregateInputType = {
    participants?: true
  }

  export type LiveRoomSumAggregateInputType = {
    participants?: true
  }

  export type LiveRoomMinAggregateInputType = {
    id?: true
    title?: true
    topic?: true
    participants?: true
    isLive?: true
    isActive?: true
    isPublic?: true
    isPrivate?: true
    isPasswordProtected?: true
    createdAt?: true
    updatedAt?: true
    communityId?: true
    courseId?: true
  }

  export type LiveRoomMaxAggregateInputType = {
    id?: true
    title?: true
    topic?: true
    participants?: true
    isLive?: true
    isActive?: true
    isPublic?: true
    isPrivate?: true
    isPasswordProtected?: true
    createdAt?: true
    updatedAt?: true
    communityId?: true
    courseId?: true
  }

  export type LiveRoomCountAggregateInputType = {
    id?: true
    title?: true
    topic?: true
    participants?: true
    isLive?: true
    isActive?: true
    isPublic?: true
    isPrivate?: true
    isPasswordProtected?: true
    createdAt?: true
    updatedAt?: true
    communityId?: true
    courseId?: true
    _all?: true
  }

  export type LiveRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiveRoom to aggregate.
     */
    where?: LiveRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveRooms to fetch.
     */
    orderBy?: LiveRoomOrderByWithRelationInput | LiveRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiveRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LiveRooms
    **/
    _count?: true | LiveRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiveRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiveRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiveRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiveRoomMaxAggregateInputType
  }

  export type GetLiveRoomAggregateType<T extends LiveRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateLiveRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiveRoom[P]>
      : GetScalarType<T[P], AggregateLiveRoom[P]>
  }




  export type LiveRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiveRoomWhereInput
    orderBy?: LiveRoomOrderByWithAggregationInput | LiveRoomOrderByWithAggregationInput[]
    by: LiveRoomScalarFieldEnum[] | LiveRoomScalarFieldEnum
    having?: LiveRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiveRoomCountAggregateInputType | true
    _avg?: LiveRoomAvgAggregateInputType
    _sum?: LiveRoomSumAggregateInputType
    _min?: LiveRoomMinAggregateInputType
    _max?: LiveRoomMaxAggregateInputType
  }

  export type LiveRoomGroupByOutputType = {
    id: string
    title: string
    topic: string | null
    participants: number
    isLive: boolean
    isActive: boolean
    isPublic: boolean
    isPrivate: boolean
    isPasswordProtected: boolean
    createdAt: Date
    updatedAt: Date
    communityId: string
    courseId: string | null
    _count: LiveRoomCountAggregateOutputType | null
    _avg: LiveRoomAvgAggregateOutputType | null
    _sum: LiveRoomSumAggregateOutputType | null
    _min: LiveRoomMinAggregateOutputType | null
    _max: LiveRoomMaxAggregateOutputType | null
  }

  type GetLiveRoomGroupByPayload<T extends LiveRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiveRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiveRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiveRoomGroupByOutputType[P]>
            : GetScalarType<T[P], LiveRoomGroupByOutputType[P]>
        }
      >
    >


  export type LiveRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    topic?: boolean
    participants?: boolean
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    communityId?: boolean
    courseId?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    User?: boolean | LiveRoom$UserArgs<ExtArgs>
    course?: boolean | LiveRoom$courseArgs<ExtArgs>
    _count?: boolean | LiveRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["liveRoom"]>

  export type LiveRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    topic?: boolean
    participants?: boolean
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    communityId?: boolean
    courseId?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    course?: boolean | LiveRoom$courseArgs<ExtArgs>
  }, ExtArgs["result"]["liveRoom"]>

  export type LiveRoomSelectScalar = {
    id?: boolean
    title?: boolean
    topic?: boolean
    participants?: boolean
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    communityId?: boolean
    courseId?: boolean
  }

  export type LiveRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    User?: boolean | LiveRoom$UserArgs<ExtArgs>
    course?: boolean | LiveRoom$courseArgs<ExtArgs>
    _count?: boolean | LiveRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LiveRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    course?: boolean | LiveRoom$courseArgs<ExtArgs>
  }

  export type $LiveRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LiveRoom"
    objects: {
      community: Prisma.$CommunityPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>[]
      course: Prisma.$CoursePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      topic: string | null
      participants: number
      isLive: boolean
      isActive: boolean
      isPublic: boolean
      isPrivate: boolean
      isPasswordProtected: boolean
      createdAt: Date
      updatedAt: Date
      communityId: string
      courseId: string | null
    }, ExtArgs["result"]["liveRoom"]>
    composites: {}
  }

  type LiveRoomGetPayload<S extends boolean | null | undefined | LiveRoomDefaultArgs> = $Result.GetResult<Prisma.$LiveRoomPayload, S>

  type LiveRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LiveRoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LiveRoomCountAggregateInputType | true
    }

  export interface LiveRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LiveRoom'], meta: { name: 'LiveRoom' } }
    /**
     * Find zero or one LiveRoom that matches the filter.
     * @param {LiveRoomFindUniqueArgs} args - Arguments to find a LiveRoom
     * @example
     * // Get one LiveRoom
     * const liveRoom = await prisma.liveRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiveRoomFindUniqueArgs>(args: SelectSubset<T, LiveRoomFindUniqueArgs<ExtArgs>>): Prisma__LiveRoomClient<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LiveRoom that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LiveRoomFindUniqueOrThrowArgs} args - Arguments to find a LiveRoom
     * @example
     * // Get one LiveRoom
     * const liveRoom = await prisma.liveRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiveRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, LiveRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiveRoomClient<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LiveRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveRoomFindFirstArgs} args - Arguments to find a LiveRoom
     * @example
     * // Get one LiveRoom
     * const liveRoom = await prisma.liveRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiveRoomFindFirstArgs>(args?: SelectSubset<T, LiveRoomFindFirstArgs<ExtArgs>>): Prisma__LiveRoomClient<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LiveRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveRoomFindFirstOrThrowArgs} args - Arguments to find a LiveRoom
     * @example
     * // Get one LiveRoom
     * const liveRoom = await prisma.liveRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiveRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, LiveRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiveRoomClient<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LiveRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LiveRooms
     * const liveRooms = await prisma.liveRoom.findMany()
     * 
     * // Get first 10 LiveRooms
     * const liveRooms = await prisma.liveRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liveRoomWithIdOnly = await prisma.liveRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiveRoomFindManyArgs>(args?: SelectSubset<T, LiveRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LiveRoom.
     * @param {LiveRoomCreateArgs} args - Arguments to create a LiveRoom.
     * @example
     * // Create one LiveRoom
     * const LiveRoom = await prisma.liveRoom.create({
     *   data: {
     *     // ... data to create a LiveRoom
     *   }
     * })
     * 
     */
    create<T extends LiveRoomCreateArgs>(args: SelectSubset<T, LiveRoomCreateArgs<ExtArgs>>): Prisma__LiveRoomClient<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LiveRooms.
     * @param {LiveRoomCreateManyArgs} args - Arguments to create many LiveRooms.
     * @example
     * // Create many LiveRooms
     * const liveRoom = await prisma.liveRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiveRoomCreateManyArgs>(args?: SelectSubset<T, LiveRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LiveRooms and returns the data saved in the database.
     * @param {LiveRoomCreateManyAndReturnArgs} args - Arguments to create many LiveRooms.
     * @example
     * // Create many LiveRooms
     * const liveRoom = await prisma.liveRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LiveRooms and only return the `id`
     * const liveRoomWithIdOnly = await prisma.liveRoom.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LiveRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, LiveRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LiveRoom.
     * @param {LiveRoomDeleteArgs} args - Arguments to delete one LiveRoom.
     * @example
     * // Delete one LiveRoom
     * const LiveRoom = await prisma.liveRoom.delete({
     *   where: {
     *     // ... filter to delete one LiveRoom
     *   }
     * })
     * 
     */
    delete<T extends LiveRoomDeleteArgs>(args: SelectSubset<T, LiveRoomDeleteArgs<ExtArgs>>): Prisma__LiveRoomClient<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LiveRoom.
     * @param {LiveRoomUpdateArgs} args - Arguments to update one LiveRoom.
     * @example
     * // Update one LiveRoom
     * const liveRoom = await prisma.liveRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiveRoomUpdateArgs>(args: SelectSubset<T, LiveRoomUpdateArgs<ExtArgs>>): Prisma__LiveRoomClient<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LiveRooms.
     * @param {LiveRoomDeleteManyArgs} args - Arguments to filter LiveRooms to delete.
     * @example
     * // Delete a few LiveRooms
     * const { count } = await prisma.liveRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiveRoomDeleteManyArgs>(args?: SelectSubset<T, LiveRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LiveRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LiveRooms
     * const liveRoom = await prisma.liveRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiveRoomUpdateManyArgs>(args: SelectSubset<T, LiveRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LiveRoom.
     * @param {LiveRoomUpsertArgs} args - Arguments to update or create a LiveRoom.
     * @example
     * // Update or create a LiveRoom
     * const liveRoom = await prisma.liveRoom.upsert({
     *   create: {
     *     // ... data to create a LiveRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LiveRoom we want to update
     *   }
     * })
     */
    upsert<T extends LiveRoomUpsertArgs>(args: SelectSubset<T, LiveRoomUpsertArgs<ExtArgs>>): Prisma__LiveRoomClient<$Result.GetResult<Prisma.$LiveRoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LiveRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveRoomCountArgs} args - Arguments to filter LiveRooms to count.
     * @example
     * // Count the number of LiveRooms
     * const count = await prisma.liveRoom.count({
     *   where: {
     *     // ... the filter for the LiveRooms we want to count
     *   }
     * })
    **/
    count<T extends LiveRoomCountArgs>(
      args?: Subset<T, LiveRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiveRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LiveRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiveRoomAggregateArgs>(args: Subset<T, LiveRoomAggregateArgs>): Prisma.PrismaPromise<GetLiveRoomAggregateType<T>>

    /**
     * Group by LiveRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiveRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiveRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiveRoomGroupByArgs['orderBy'] }
        : { orderBy?: LiveRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiveRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiveRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LiveRoom model
   */
  readonly fields: LiveRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LiveRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiveRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    User<T extends LiveRoom$UserArgs<ExtArgs> = {}>(args?: Subset<T, LiveRoom$UserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    course<T extends LiveRoom$courseArgs<ExtArgs> = {}>(args?: Subset<T, LiveRoom$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LiveRoom model
   */ 
  interface LiveRoomFieldRefs {
    readonly id: FieldRef<"LiveRoom", 'String'>
    readonly title: FieldRef<"LiveRoom", 'String'>
    readonly topic: FieldRef<"LiveRoom", 'String'>
    readonly participants: FieldRef<"LiveRoom", 'Int'>
    readonly isLive: FieldRef<"LiveRoom", 'Boolean'>
    readonly isActive: FieldRef<"LiveRoom", 'Boolean'>
    readonly isPublic: FieldRef<"LiveRoom", 'Boolean'>
    readonly isPrivate: FieldRef<"LiveRoom", 'Boolean'>
    readonly isPasswordProtected: FieldRef<"LiveRoom", 'Boolean'>
    readonly createdAt: FieldRef<"LiveRoom", 'DateTime'>
    readonly updatedAt: FieldRef<"LiveRoom", 'DateTime'>
    readonly communityId: FieldRef<"LiveRoom", 'String'>
    readonly courseId: FieldRef<"LiveRoom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LiveRoom findUnique
   */
  export type LiveRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    /**
     * Filter, which LiveRoom to fetch.
     */
    where: LiveRoomWhereUniqueInput
  }

  /**
   * LiveRoom findUniqueOrThrow
   */
  export type LiveRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    /**
     * Filter, which LiveRoom to fetch.
     */
    where: LiveRoomWhereUniqueInput
  }

  /**
   * LiveRoom findFirst
   */
  export type LiveRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    /**
     * Filter, which LiveRoom to fetch.
     */
    where?: LiveRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveRooms to fetch.
     */
    orderBy?: LiveRoomOrderByWithRelationInput | LiveRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiveRooms.
     */
    cursor?: LiveRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiveRooms.
     */
    distinct?: LiveRoomScalarFieldEnum | LiveRoomScalarFieldEnum[]
  }

  /**
   * LiveRoom findFirstOrThrow
   */
  export type LiveRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    /**
     * Filter, which LiveRoom to fetch.
     */
    where?: LiveRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveRooms to fetch.
     */
    orderBy?: LiveRoomOrderByWithRelationInput | LiveRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LiveRooms.
     */
    cursor?: LiveRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LiveRooms.
     */
    distinct?: LiveRoomScalarFieldEnum | LiveRoomScalarFieldEnum[]
  }

  /**
   * LiveRoom findMany
   */
  export type LiveRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    /**
     * Filter, which LiveRooms to fetch.
     */
    where?: LiveRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LiveRooms to fetch.
     */
    orderBy?: LiveRoomOrderByWithRelationInput | LiveRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LiveRooms.
     */
    cursor?: LiveRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LiveRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LiveRooms.
     */
    skip?: number
    distinct?: LiveRoomScalarFieldEnum | LiveRoomScalarFieldEnum[]
  }

  /**
   * LiveRoom create
   */
  export type LiveRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a LiveRoom.
     */
    data: XOR<LiveRoomCreateInput, LiveRoomUncheckedCreateInput>
  }

  /**
   * LiveRoom createMany
   */
  export type LiveRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LiveRooms.
     */
    data: LiveRoomCreateManyInput | LiveRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LiveRoom createManyAndReturn
   */
  export type LiveRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LiveRooms.
     */
    data: LiveRoomCreateManyInput | LiveRoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LiveRoom update
   */
  export type LiveRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a LiveRoom.
     */
    data: XOR<LiveRoomUpdateInput, LiveRoomUncheckedUpdateInput>
    /**
     * Choose, which LiveRoom to update.
     */
    where: LiveRoomWhereUniqueInput
  }

  /**
   * LiveRoom updateMany
   */
  export type LiveRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LiveRooms.
     */
    data: XOR<LiveRoomUpdateManyMutationInput, LiveRoomUncheckedUpdateManyInput>
    /**
     * Filter which LiveRooms to update
     */
    where?: LiveRoomWhereInput
  }

  /**
   * LiveRoom upsert
   */
  export type LiveRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the LiveRoom to update in case it exists.
     */
    where: LiveRoomWhereUniqueInput
    /**
     * In case the LiveRoom found by the `where` argument doesn't exist, create a new LiveRoom with this data.
     */
    create: XOR<LiveRoomCreateInput, LiveRoomUncheckedCreateInput>
    /**
     * In case the LiveRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiveRoomUpdateInput, LiveRoomUncheckedUpdateInput>
  }

  /**
   * LiveRoom delete
   */
  export type LiveRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
    /**
     * Filter which LiveRoom to delete.
     */
    where: LiveRoomWhereUniqueInput
  }

  /**
   * LiveRoom deleteMany
   */
  export type LiveRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LiveRooms to delete
     */
    where?: LiveRoomWhereInput
  }

  /**
   * LiveRoom.User
   */
  export type LiveRoom$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * LiveRoom.course
   */
  export type LiveRoom$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * LiveRoom without action
   */
  export type LiveRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LiveRoom
     */
    select?: LiveRoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LiveRoomInclude<ExtArgs> | null
  }


  /**
   * Model AccountingEntry
   */

  export type AggregateAccountingEntry = {
    _count: AccountingEntryCountAggregateOutputType | null
    _avg: AccountingEntryAvgAggregateOutputType | null
    _sum: AccountingEntrySumAggregateOutputType | null
    _min: AccountingEntryMinAggregateOutputType | null
    _max: AccountingEntryMaxAggregateOutputType | null
  }

  export type AccountingEntryAvgAggregateOutputType = {
    amount: number | null
  }

  export type AccountingEntrySumAggregateOutputType = {
    amount: number | null
  }

  export type AccountingEntryMinAggregateOutputType = {
    id: string | null
    type: $Enums.AccountingType | null
    amount: number | null
    description: string | null
    date: Date | null
    createdByAdminId: string | null
    academyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountingEntryMaxAggregateOutputType = {
    id: string | null
    type: $Enums.AccountingType | null
    amount: number | null
    description: string | null
    date: Date | null
    createdByAdminId: string | null
    academyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountingEntryCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    description: number
    date: number
    createdByAdminId: number
    academyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountingEntryAvgAggregateInputType = {
    amount?: true
  }

  export type AccountingEntrySumAggregateInputType = {
    amount?: true
  }

  export type AccountingEntryMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    date?: true
    createdByAdminId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountingEntryMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    date?: true
    createdByAdminId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountingEntryCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    date?: true
    createdByAdminId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountingEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountingEntry to aggregate.
     */
    where?: AccountingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountingEntries to fetch.
     */
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountingEntries
    **/
    _count?: true | AccountingEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountingEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountingEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountingEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountingEntryMaxAggregateInputType
  }

  export type GetAccountingEntryAggregateType<T extends AccountingEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountingEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountingEntry[P]>
      : GetScalarType<T[P], AggregateAccountingEntry[P]>
  }




  export type AccountingEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountingEntryWhereInput
    orderBy?: AccountingEntryOrderByWithAggregationInput | AccountingEntryOrderByWithAggregationInput[]
    by: AccountingEntryScalarFieldEnum[] | AccountingEntryScalarFieldEnum
    having?: AccountingEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountingEntryCountAggregateInputType | true
    _avg?: AccountingEntryAvgAggregateInputType
    _sum?: AccountingEntrySumAggregateInputType
    _min?: AccountingEntryMinAggregateInputType
    _max?: AccountingEntryMaxAggregateInputType
  }

  export type AccountingEntryGroupByOutputType = {
    id: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date
    createdByAdminId: string
    academyId: string
    createdAt: Date
    updatedAt: Date
    _count: AccountingEntryCountAggregateOutputType | null
    _avg: AccountingEntryAvgAggregateOutputType | null
    _sum: AccountingEntrySumAggregateOutputType | null
    _min: AccountingEntryMinAggregateOutputType | null
    _max: AccountingEntryMaxAggregateOutputType | null
  }

  type GetAccountingEntryGroupByPayload<T extends AccountingEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountingEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountingEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountingEntryGroupByOutputType[P]>
            : GetScalarType<T[P], AccountingEntryGroupByOutputType[P]>
        }
      >
    >


  export type AccountingEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    createdByAdminId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    invoice?: boolean | AccountingEntry$invoiceArgs<ExtArgs>
    salaryPayment?: boolean | AccountingEntry$salaryPaymentArgs<ExtArgs>
    files?: boolean | AccountingEntry$filesArgs<ExtArgs>
    reports?: boolean | AccountingEntry$reportsArgs<ExtArgs>
    _count?: boolean | AccountingEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountingEntry"]>

  export type AccountingEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    createdByAdminId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountingEntry"]>

  export type AccountingEntrySelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    createdByAdminId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountingEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    invoice?: boolean | AccountingEntry$invoiceArgs<ExtArgs>
    salaryPayment?: boolean | AccountingEntry$salaryPaymentArgs<ExtArgs>
    files?: boolean | AccountingEntry$filesArgs<ExtArgs>
    reports?: boolean | AccountingEntry$reportsArgs<ExtArgs>
    _count?: boolean | AccountingEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountingEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }

  export type $AccountingEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountingEntry"
    objects: {
      createdByAdmin: Prisma.$AdminPayload<ExtArgs>
      academy: Prisma.$AcademyPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      salaryPayment: Prisma.$SalaryPaymentPayload<ExtArgs> | null
      files: Prisma.$FilePayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.AccountingType
      amount: number
      description: string
      date: Date
      createdByAdminId: string
      academyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accountingEntry"]>
    composites: {}
  }

  type AccountingEntryGetPayload<S extends boolean | null | undefined | AccountingEntryDefaultArgs> = $Result.GetResult<Prisma.$AccountingEntryPayload, S>

  type AccountingEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountingEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountingEntryCountAggregateInputType | true
    }

  export interface AccountingEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountingEntry'], meta: { name: 'AccountingEntry' } }
    /**
     * Find zero or one AccountingEntry that matches the filter.
     * @param {AccountingEntryFindUniqueArgs} args - Arguments to find a AccountingEntry
     * @example
     * // Get one AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountingEntryFindUniqueArgs>(args: SelectSubset<T, AccountingEntryFindUniqueArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccountingEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountingEntryFindUniqueOrThrowArgs} args - Arguments to find a AccountingEntry
     * @example
     * // Get one AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountingEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountingEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccountingEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryFindFirstArgs} args - Arguments to find a AccountingEntry
     * @example
     * // Get one AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountingEntryFindFirstArgs>(args?: SelectSubset<T, AccountingEntryFindFirstArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccountingEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryFindFirstOrThrowArgs} args - Arguments to find a AccountingEntry
     * @example
     * // Get one AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountingEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountingEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccountingEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountingEntries
     * const accountingEntries = await prisma.accountingEntry.findMany()
     * 
     * // Get first 10 AccountingEntries
     * const accountingEntries = await prisma.accountingEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountingEntryWithIdOnly = await prisma.accountingEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountingEntryFindManyArgs>(args?: SelectSubset<T, AccountingEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccountingEntry.
     * @param {AccountingEntryCreateArgs} args - Arguments to create a AccountingEntry.
     * @example
     * // Create one AccountingEntry
     * const AccountingEntry = await prisma.accountingEntry.create({
     *   data: {
     *     // ... data to create a AccountingEntry
     *   }
     * })
     * 
     */
    create<T extends AccountingEntryCreateArgs>(args: SelectSubset<T, AccountingEntryCreateArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccountingEntries.
     * @param {AccountingEntryCreateManyArgs} args - Arguments to create many AccountingEntries.
     * @example
     * // Create many AccountingEntries
     * const accountingEntry = await prisma.accountingEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountingEntryCreateManyArgs>(args?: SelectSubset<T, AccountingEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountingEntries and returns the data saved in the database.
     * @param {AccountingEntryCreateManyAndReturnArgs} args - Arguments to create many AccountingEntries.
     * @example
     * // Create many AccountingEntries
     * const accountingEntry = await prisma.accountingEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountingEntries and only return the `id`
     * const accountingEntryWithIdOnly = await prisma.accountingEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountingEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountingEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccountingEntry.
     * @param {AccountingEntryDeleteArgs} args - Arguments to delete one AccountingEntry.
     * @example
     * // Delete one AccountingEntry
     * const AccountingEntry = await prisma.accountingEntry.delete({
     *   where: {
     *     // ... filter to delete one AccountingEntry
     *   }
     * })
     * 
     */
    delete<T extends AccountingEntryDeleteArgs>(args: SelectSubset<T, AccountingEntryDeleteArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccountingEntry.
     * @param {AccountingEntryUpdateArgs} args - Arguments to update one AccountingEntry.
     * @example
     * // Update one AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountingEntryUpdateArgs>(args: SelectSubset<T, AccountingEntryUpdateArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccountingEntries.
     * @param {AccountingEntryDeleteManyArgs} args - Arguments to filter AccountingEntries to delete.
     * @example
     * // Delete a few AccountingEntries
     * const { count } = await prisma.accountingEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountingEntryDeleteManyArgs>(args?: SelectSubset<T, AccountingEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountingEntries
     * const accountingEntry = await prisma.accountingEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountingEntryUpdateManyArgs>(args: SelectSubset<T, AccountingEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountingEntry.
     * @param {AccountingEntryUpsertArgs} args - Arguments to update or create a AccountingEntry.
     * @example
     * // Update or create a AccountingEntry
     * const accountingEntry = await prisma.accountingEntry.upsert({
     *   create: {
     *     // ... data to create a AccountingEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountingEntry we want to update
     *   }
     * })
     */
    upsert<T extends AccountingEntryUpsertArgs>(args: SelectSubset<T, AccountingEntryUpsertArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccountingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryCountArgs} args - Arguments to filter AccountingEntries to count.
     * @example
     * // Count the number of AccountingEntries
     * const count = await prisma.accountingEntry.count({
     *   where: {
     *     // ... the filter for the AccountingEntries we want to count
     *   }
     * })
    **/
    count<T extends AccountingEntryCountArgs>(
      args?: Subset<T, AccountingEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountingEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountingEntryAggregateArgs>(args: Subset<T, AccountingEntryAggregateArgs>): Prisma.PrismaPromise<GetAccountingEntryAggregateType<T>>

    /**
     * Group by AccountingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountingEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountingEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountingEntryGroupByArgs['orderBy'] }
        : { orderBy?: AccountingEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountingEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountingEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountingEntry model
   */
  readonly fields: AccountingEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountingEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountingEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByAdmin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academy<T extends AcademyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademyDefaultArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoice<T extends AccountingEntry$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, AccountingEntry$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    salaryPayment<T extends AccountingEntry$salaryPaymentArgs<ExtArgs> = {}>(args?: Subset<T, AccountingEntry$salaryPaymentArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    files<T extends AccountingEntry$filesArgs<ExtArgs> = {}>(args?: Subset<T, AccountingEntry$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends AccountingEntry$reportsArgs<ExtArgs> = {}>(args?: Subset<T, AccountingEntry$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountingEntry model
   */ 
  interface AccountingEntryFieldRefs {
    readonly id: FieldRef<"AccountingEntry", 'String'>
    readonly type: FieldRef<"AccountingEntry", 'AccountingType'>
    readonly amount: FieldRef<"AccountingEntry", 'Float'>
    readonly description: FieldRef<"AccountingEntry", 'String'>
    readonly date: FieldRef<"AccountingEntry", 'DateTime'>
    readonly createdByAdminId: FieldRef<"AccountingEntry", 'String'>
    readonly academyId: FieldRef<"AccountingEntry", 'String'>
    readonly createdAt: FieldRef<"AccountingEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"AccountingEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountingEntry findUnique
   */
  export type AccountingEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountingEntry to fetch.
     */
    where: AccountingEntryWhereUniqueInput
  }

  /**
   * AccountingEntry findUniqueOrThrow
   */
  export type AccountingEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountingEntry to fetch.
     */
    where: AccountingEntryWhereUniqueInput
  }

  /**
   * AccountingEntry findFirst
   */
  export type AccountingEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountingEntry to fetch.
     */
    where?: AccountingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountingEntries to fetch.
     */
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountingEntries.
     */
    cursor?: AccountingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountingEntries.
     */
    distinct?: AccountingEntryScalarFieldEnum | AccountingEntryScalarFieldEnum[]
  }

  /**
   * AccountingEntry findFirstOrThrow
   */
  export type AccountingEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountingEntry to fetch.
     */
    where?: AccountingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountingEntries to fetch.
     */
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountingEntries.
     */
    cursor?: AccountingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountingEntries.
     */
    distinct?: AccountingEntryScalarFieldEnum | AccountingEntryScalarFieldEnum[]
  }

  /**
   * AccountingEntry findMany
   */
  export type AccountingEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter, which AccountingEntries to fetch.
     */
    where?: AccountingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountingEntries to fetch.
     */
    orderBy?: AccountingEntryOrderByWithRelationInput | AccountingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountingEntries.
     */
    cursor?: AccountingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountingEntries.
     */
    skip?: number
    distinct?: AccountingEntryScalarFieldEnum | AccountingEntryScalarFieldEnum[]
  }

  /**
   * AccountingEntry create
   */
  export type AccountingEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountingEntry.
     */
    data: XOR<AccountingEntryCreateInput, AccountingEntryUncheckedCreateInput>
  }

  /**
   * AccountingEntry createMany
   */
  export type AccountingEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountingEntries.
     */
    data: AccountingEntryCreateManyInput | AccountingEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountingEntry createManyAndReturn
   */
  export type AccountingEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccountingEntries.
     */
    data: AccountingEntryCreateManyInput | AccountingEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountingEntry update
   */
  export type AccountingEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountingEntry.
     */
    data: XOR<AccountingEntryUpdateInput, AccountingEntryUncheckedUpdateInput>
    /**
     * Choose, which AccountingEntry to update.
     */
    where: AccountingEntryWhereUniqueInput
  }

  /**
   * AccountingEntry updateMany
   */
  export type AccountingEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountingEntries.
     */
    data: XOR<AccountingEntryUpdateManyMutationInput, AccountingEntryUncheckedUpdateManyInput>
    /**
     * Filter which AccountingEntries to update
     */
    where?: AccountingEntryWhereInput
  }

  /**
   * AccountingEntry upsert
   */
  export type AccountingEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountingEntry to update in case it exists.
     */
    where: AccountingEntryWhereUniqueInput
    /**
     * In case the AccountingEntry found by the `where` argument doesn't exist, create a new AccountingEntry with this data.
     */
    create: XOR<AccountingEntryCreateInput, AccountingEntryUncheckedCreateInput>
    /**
     * In case the AccountingEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountingEntryUpdateInput, AccountingEntryUncheckedUpdateInput>
  }

  /**
   * AccountingEntry delete
   */
  export type AccountingEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
    /**
     * Filter which AccountingEntry to delete.
     */
    where: AccountingEntryWhereUniqueInput
  }

  /**
   * AccountingEntry deleteMany
   */
  export type AccountingEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountingEntries to delete
     */
    where?: AccountingEntryWhereInput
  }

  /**
   * AccountingEntry.invoice
   */
  export type AccountingEntry$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * AccountingEntry.salaryPayment
   */
  export type AccountingEntry$salaryPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    where?: SalaryPaymentWhereInput
  }

  /**
   * AccountingEntry.files
   */
  export type AccountingEntry$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * AccountingEntry.reports
   */
  export type AccountingEntry$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * AccountingEntry without action
   */
  export type AccountingEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountingEntry
     */
    select?: AccountingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountingEntryInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    amount: number | null
    description: string | null
    dueDate: Date | null
    status: $Enums.InvoiceStatus | null
    accountingEntryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    amount: number | null
    description: string | null
    dueDate: Date | null
    status: $Enums.InvoiceStatus | null
    accountingEntryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    amount: number
    description: number
    dueDate: number
    status: number
    accountingEntryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    amount?: true
    description?: true
    dueDate?: true
    status?: true
    accountingEntryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    amount?: true
    description?: true
    dueDate?: true
    status?: true
    accountingEntryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    amount?: true
    description?: true
    dueDate?: true
    status?: true
    accountingEntryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    amount: number
    description: string
    dueDate: Date
    status: $Enums.InvoiceStatus
    accountingEntryId: string
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    accountingEntryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountingEntry?: boolean | AccountingEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    accountingEntryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountingEntry?: boolean | AccountingEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    accountingEntryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountingEntry?: boolean | AccountingEntryDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountingEntry?: boolean | AccountingEntryDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      accountingEntry: Prisma.$AccountingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      amount: number
      description: string
      dueDate: Date
      status: $Enums.InvoiceStatus
      accountingEntryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accountingEntry<T extends AccountingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountingEntryDefaultArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Float'>
    readonly description: FieldRef<"Invoice", 'String'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly accountingEntryId: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model SalaryPayment
   */

  export type AggregateSalaryPayment = {
    _count: SalaryPaymentCountAggregateOutputType | null
    _avg: SalaryPaymentAvgAggregateOutputType | null
    _sum: SalaryPaymentSumAggregateOutputType | null
    _min: SalaryPaymentMinAggregateOutputType | null
    _max: SalaryPaymentMaxAggregateOutputType | null
  }

  export type SalaryPaymentAvgAggregateOutputType = {
    amount: number | null
    month: number | null
    year: number | null
  }

  export type SalaryPaymentSumAggregateOutputType = {
    amount: number | null
    month: number | null
    year: number | null
  }

  export type SalaryPaymentMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    amount: number | null
    month: number | null
    year: number | null
    accountingEntryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryPaymentMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    amount: number | null
    month: number | null
    year: number | null
    accountingEntryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryPaymentCountAggregateOutputType = {
    id: number
    employeeId: number
    amount: number
    month: number
    year: number
    accountingEntryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalaryPaymentAvgAggregateInputType = {
    amount?: true
    month?: true
    year?: true
  }

  export type SalaryPaymentSumAggregateInputType = {
    amount?: true
    month?: true
    year?: true
  }

  export type SalaryPaymentMinAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    month?: true
    year?: true
    accountingEntryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryPaymentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    month?: true
    year?: true
    accountingEntryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryPaymentCountAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    month?: true
    year?: true
    accountingEntryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalaryPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayment to aggregate.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryPayments
    **/
    _count?: true | SalaryPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryPaymentMaxAggregateInputType
  }

  export type GetSalaryPaymentAggregateType<T extends SalaryPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryPayment[P]>
      : GetScalarType<T[P], AggregateSalaryPayment[P]>
  }




  export type SalaryPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryPaymentWhereInput
    orderBy?: SalaryPaymentOrderByWithAggregationInput | SalaryPaymentOrderByWithAggregationInput[]
    by: SalaryPaymentScalarFieldEnum[] | SalaryPaymentScalarFieldEnum
    having?: SalaryPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryPaymentCountAggregateInputType | true
    _avg?: SalaryPaymentAvgAggregateInputType
    _sum?: SalaryPaymentSumAggregateInputType
    _min?: SalaryPaymentMinAggregateInputType
    _max?: SalaryPaymentMaxAggregateInputType
  }

  export type SalaryPaymentGroupByOutputType = {
    id: string
    employeeId: string
    amount: number
    month: number
    year: number
    accountingEntryId: string
    createdAt: Date
    updatedAt: Date
    _count: SalaryPaymentCountAggregateOutputType | null
    _avg: SalaryPaymentAvgAggregateOutputType | null
    _sum: SalaryPaymentSumAggregateOutputType | null
    _min: SalaryPaymentMinAggregateOutputType | null
    _max: SalaryPaymentMaxAggregateOutputType | null
  }

  type GetSalaryPaymentGroupByPayload<T extends SalaryPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryPaymentGroupByOutputType[P]>
        }
      >
    >


  export type SalaryPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    amount?: boolean
    month?: boolean
    year?: boolean
    accountingEntryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    accountingEntry?: boolean | AccountingEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayment"]>

  export type SalaryPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    amount?: boolean
    month?: boolean
    year?: boolean
    accountingEntryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    accountingEntry?: boolean | AccountingEntryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salaryPayment"]>

  export type SalaryPaymentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    amount?: boolean
    month?: boolean
    year?: boolean
    accountingEntryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalaryPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    accountingEntry?: boolean | AccountingEntryDefaultArgs<ExtArgs>
  }
  export type SalaryPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    accountingEntry?: boolean | AccountingEntryDefaultArgs<ExtArgs>
  }

  export type $SalaryPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryPayment"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
      accountingEntry: Prisma.$AccountingEntryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      amount: number
      month: number
      year: number
      accountingEntryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salaryPayment"]>
    composites: {}
  }

  type SalaryPaymentGetPayload<S extends boolean | null | undefined | SalaryPaymentDefaultArgs> = $Result.GetResult<Prisma.$SalaryPaymentPayload, S>

  type SalaryPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalaryPaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalaryPaymentCountAggregateInputType | true
    }

  export interface SalaryPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryPayment'], meta: { name: 'SalaryPayment' } }
    /**
     * Find zero or one SalaryPayment that matches the filter.
     * @param {SalaryPaymentFindUniqueArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryPaymentFindUniqueArgs>(args: SelectSubset<T, SalaryPaymentFindUniqueArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalaryPayment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalaryPaymentFindUniqueOrThrowArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalaryPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindFirstArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryPaymentFindFirstArgs>(args?: SelectSubset<T, SalaryPaymentFindFirstArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalaryPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindFirstOrThrowArgs} args - Arguments to find a SalaryPayment
     * @example
     * // Get one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalaryPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryPayments
     * const salaryPayments = await prisma.salaryPayment.findMany()
     * 
     * // Get first 10 SalaryPayments
     * const salaryPayments = await prisma.salaryPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryPaymentWithIdOnly = await prisma.salaryPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryPaymentFindManyArgs>(args?: SelectSubset<T, SalaryPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalaryPayment.
     * @param {SalaryPaymentCreateArgs} args - Arguments to create a SalaryPayment.
     * @example
     * // Create one SalaryPayment
     * const SalaryPayment = await prisma.salaryPayment.create({
     *   data: {
     *     // ... data to create a SalaryPayment
     *   }
     * })
     * 
     */
    create<T extends SalaryPaymentCreateArgs>(args: SelectSubset<T, SalaryPaymentCreateArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalaryPayments.
     * @param {SalaryPaymentCreateManyArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryPaymentCreateManyArgs>(args?: SelectSubset<T, SalaryPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryPayments and returns the data saved in the database.
     * @param {SalaryPaymentCreateManyAndReturnArgs} args - Arguments to create many SalaryPayments.
     * @example
     * // Create many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryPayments and only return the `id`
     * const salaryPaymentWithIdOnly = await prisma.salaryPayment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalaryPayment.
     * @param {SalaryPaymentDeleteArgs} args - Arguments to delete one SalaryPayment.
     * @example
     * // Delete one SalaryPayment
     * const SalaryPayment = await prisma.salaryPayment.delete({
     *   where: {
     *     // ... filter to delete one SalaryPayment
     *   }
     * })
     * 
     */
    delete<T extends SalaryPaymentDeleteArgs>(args: SelectSubset<T, SalaryPaymentDeleteArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalaryPayment.
     * @param {SalaryPaymentUpdateArgs} args - Arguments to update one SalaryPayment.
     * @example
     * // Update one SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryPaymentUpdateArgs>(args: SelectSubset<T, SalaryPaymentUpdateArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalaryPayments.
     * @param {SalaryPaymentDeleteManyArgs} args - Arguments to filter SalaryPayments to delete.
     * @example
     * // Delete a few SalaryPayments
     * const { count } = await prisma.salaryPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryPaymentDeleteManyArgs>(args?: SelectSubset<T, SalaryPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryPayments
     * const salaryPayment = await prisma.salaryPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryPaymentUpdateManyArgs>(args: SelectSubset<T, SalaryPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalaryPayment.
     * @param {SalaryPaymentUpsertArgs} args - Arguments to update or create a SalaryPayment.
     * @example
     * // Update or create a SalaryPayment
     * const salaryPayment = await prisma.salaryPayment.upsert({
     *   create: {
     *     // ... data to create a SalaryPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryPayment we want to update
     *   }
     * })
     */
    upsert<T extends SalaryPaymentUpsertArgs>(args: SelectSubset<T, SalaryPaymentUpsertArgs<ExtArgs>>): Prisma__SalaryPaymentClient<$Result.GetResult<Prisma.$SalaryPaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalaryPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentCountArgs} args - Arguments to filter SalaryPayments to count.
     * @example
     * // Count the number of SalaryPayments
     * const count = await prisma.salaryPayment.count({
     *   where: {
     *     // ... the filter for the SalaryPayments we want to count
     *   }
     * })
    **/
    count<T extends SalaryPaymentCountArgs>(
      args?: Subset<T, SalaryPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryPaymentAggregateArgs>(args: Subset<T, SalaryPaymentAggregateArgs>): Prisma.PrismaPromise<GetSalaryPaymentAggregateType<T>>

    /**
     * Group by SalaryPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryPaymentGroupByArgs['orderBy'] }
        : { orderBy?: SalaryPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryPayment model
   */
  readonly fields: SalaryPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    accountingEntry<T extends AccountingEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountingEntryDefaultArgs<ExtArgs>>): Prisma__AccountingEntryClient<$Result.GetResult<Prisma.$AccountingEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryPayment model
   */ 
  interface SalaryPaymentFieldRefs {
    readonly id: FieldRef<"SalaryPayment", 'String'>
    readonly employeeId: FieldRef<"SalaryPayment", 'String'>
    readonly amount: FieldRef<"SalaryPayment", 'Float'>
    readonly month: FieldRef<"SalaryPayment", 'Int'>
    readonly year: FieldRef<"SalaryPayment", 'Int'>
    readonly accountingEntryId: FieldRef<"SalaryPayment", 'String'>
    readonly createdAt: FieldRef<"SalaryPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"SalaryPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalaryPayment findUnique
   */
  export type SalaryPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment findUniqueOrThrow
   */
  export type SalaryPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment findFirst
   */
  export type SalaryPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment findFirstOrThrow
   */
  export type SalaryPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayment to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryPayments.
     */
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment findMany
   */
  export type SalaryPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryPayments to fetch.
     */
    where?: SalaryPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryPayments to fetch.
     */
    orderBy?: SalaryPaymentOrderByWithRelationInput | SalaryPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryPayments.
     */
    cursor?: SalaryPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryPayments.
     */
    skip?: number
    distinct?: SalaryPaymentScalarFieldEnum | SalaryPaymentScalarFieldEnum[]
  }

  /**
   * SalaryPayment create
   */
  export type SalaryPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryPayment.
     */
    data: XOR<SalaryPaymentCreateInput, SalaryPaymentUncheckedCreateInput>
  }

  /**
   * SalaryPayment createMany
   */
  export type SalaryPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentCreateManyInput | SalaryPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryPayment createManyAndReturn
   */
  export type SalaryPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalaryPayments.
     */
    data: SalaryPaymentCreateManyInput | SalaryPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryPayment update
   */
  export type SalaryPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryPayment.
     */
    data: XOR<SalaryPaymentUpdateInput, SalaryPaymentUncheckedUpdateInput>
    /**
     * Choose, which SalaryPayment to update.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment updateMany
   */
  export type SalaryPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryPayments.
     */
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SalaryPayments to update
     */
    where?: SalaryPaymentWhereInput
  }

  /**
   * SalaryPayment upsert
   */
  export type SalaryPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryPayment to update in case it exists.
     */
    where: SalaryPaymentWhereUniqueInput
    /**
     * In case the SalaryPayment found by the `where` argument doesn't exist, create a new SalaryPayment with this data.
     */
    create: XOR<SalaryPaymentCreateInput, SalaryPaymentUncheckedCreateInput>
    /**
     * In case the SalaryPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryPaymentUpdateInput, SalaryPaymentUncheckedUpdateInput>
  }

  /**
   * SalaryPayment delete
   */
  export type SalaryPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
    /**
     * Filter which SalaryPayment to delete.
     */
    where: SalaryPaymentWhereUniqueInput
  }

  /**
   * SalaryPayment deleteMany
   */
  export type SalaryPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryPayments to delete
     */
    where?: SalaryPaymentWhereInput
  }

  /**
   * SalaryPayment without action
   */
  export type SalaryPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryPayment
     */
    select?: SalaryPaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryPaymentInclude<ExtArgs> | null
  }


  /**
   * Model PublicRelationsRecord
   */

  export type AggregatePublicRelationsRecord = {
    _count: PublicRelationsRecordCountAggregateOutputType | null
    _min: PublicRelationsRecordMinAggregateOutputType | null
    _max: PublicRelationsRecordMaxAggregateOutputType | null
  }

  export type PublicRelationsRecordMinAggregateOutputType = {
    id: string | null
    message: string | null
    senderName: string | null
    senderContact: string | null
    status: $Enums.PRRequestStatus | null
    handledByAdminId: string | null
    academyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicRelationsRecordMaxAggregateOutputType = {
    id: string | null
    message: string | null
    senderName: string | null
    senderContact: string | null
    status: $Enums.PRRequestStatus | null
    handledByAdminId: string | null
    academyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicRelationsRecordCountAggregateOutputType = {
    id: number
    message: number
    senderName: number
    senderContact: number
    status: number
    handledByAdminId: number
    academyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PublicRelationsRecordMinAggregateInputType = {
    id?: true
    message?: true
    senderName?: true
    senderContact?: true
    status?: true
    handledByAdminId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicRelationsRecordMaxAggregateInputType = {
    id?: true
    message?: true
    senderName?: true
    senderContact?: true
    status?: true
    handledByAdminId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicRelationsRecordCountAggregateInputType = {
    id?: true
    message?: true
    senderName?: true
    senderContact?: true
    status?: true
    handledByAdminId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PublicRelationsRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicRelationsRecord to aggregate.
     */
    where?: PublicRelationsRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicRelationsRecords to fetch.
     */
    orderBy?: PublicRelationsRecordOrderByWithRelationInput | PublicRelationsRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicRelationsRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicRelationsRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicRelationsRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PublicRelationsRecords
    **/
    _count?: true | PublicRelationsRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicRelationsRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicRelationsRecordMaxAggregateInputType
  }

  export type GetPublicRelationsRecordAggregateType<T extends PublicRelationsRecordAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicRelationsRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicRelationsRecord[P]>
      : GetScalarType<T[P], AggregatePublicRelationsRecord[P]>
  }




  export type PublicRelationsRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicRelationsRecordWhereInput
    orderBy?: PublicRelationsRecordOrderByWithAggregationInput | PublicRelationsRecordOrderByWithAggregationInput[]
    by: PublicRelationsRecordScalarFieldEnum[] | PublicRelationsRecordScalarFieldEnum
    having?: PublicRelationsRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicRelationsRecordCountAggregateInputType | true
    _min?: PublicRelationsRecordMinAggregateInputType
    _max?: PublicRelationsRecordMaxAggregateInputType
  }

  export type PublicRelationsRecordGroupByOutputType = {
    id: string
    message: string
    senderName: string
    senderContact: string
    status: $Enums.PRRequestStatus
    handledByAdminId: string
    academyId: string
    createdAt: Date
    updatedAt: Date
    _count: PublicRelationsRecordCountAggregateOutputType | null
    _min: PublicRelationsRecordMinAggregateOutputType | null
    _max: PublicRelationsRecordMaxAggregateOutputType | null
  }

  type GetPublicRelationsRecordGroupByPayload<T extends PublicRelationsRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicRelationsRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicRelationsRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicRelationsRecordGroupByOutputType[P]>
            : GetScalarType<T[P], PublicRelationsRecordGroupByOutputType[P]>
        }
      >
    >


  export type PublicRelationsRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    senderName?: boolean
    senderContact?: boolean
    status?: boolean
    handledByAdminId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    handledByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    responses?: boolean | PublicRelationsRecord$responsesArgs<ExtArgs>
    events?: boolean | PublicRelationsRecord$eventsArgs<ExtArgs>
    posts?: boolean | PublicRelationsRecord$postsArgs<ExtArgs>
    files?: boolean | PublicRelationsRecord$filesArgs<ExtArgs>
    channels?: boolean | PublicRelationsRecord$channelsArgs<ExtArgs>
    _count?: boolean | PublicRelationsRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publicRelationsRecord"]>

  export type PublicRelationsRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    senderName?: boolean
    senderContact?: boolean
    status?: boolean
    handledByAdminId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    handledByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publicRelationsRecord"]>

  export type PublicRelationsRecordSelectScalar = {
    id?: boolean
    message?: boolean
    senderName?: boolean
    senderContact?: boolean
    status?: boolean
    handledByAdminId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PublicRelationsRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    handledByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    responses?: boolean | PublicRelationsRecord$responsesArgs<ExtArgs>
    events?: boolean | PublicRelationsRecord$eventsArgs<ExtArgs>
    posts?: boolean | PublicRelationsRecord$postsArgs<ExtArgs>
    files?: boolean | PublicRelationsRecord$filesArgs<ExtArgs>
    channels?: boolean | PublicRelationsRecord$channelsArgs<ExtArgs>
    _count?: boolean | PublicRelationsRecordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PublicRelationsRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    handledByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }

  export type $PublicRelationsRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PublicRelationsRecord"
    objects: {
      handledByAdmin: Prisma.$AdminPayload<ExtArgs>
      academy: Prisma.$AcademyPayload<ExtArgs>
      responses: Prisma.$PRResponsePayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      channels: Prisma.$ChannelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message: string
      senderName: string
      senderContact: string
      status: $Enums.PRRequestStatus
      handledByAdminId: string
      academyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["publicRelationsRecord"]>
    composites: {}
  }

  type PublicRelationsRecordGetPayload<S extends boolean | null | undefined | PublicRelationsRecordDefaultArgs> = $Result.GetResult<Prisma.$PublicRelationsRecordPayload, S>

  type PublicRelationsRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PublicRelationsRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PublicRelationsRecordCountAggregateInputType | true
    }

  export interface PublicRelationsRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PublicRelationsRecord'], meta: { name: 'PublicRelationsRecord' } }
    /**
     * Find zero or one PublicRelationsRecord that matches the filter.
     * @param {PublicRelationsRecordFindUniqueArgs} args - Arguments to find a PublicRelationsRecord
     * @example
     * // Get one PublicRelationsRecord
     * const publicRelationsRecord = await prisma.publicRelationsRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicRelationsRecordFindUniqueArgs>(args: SelectSubset<T, PublicRelationsRecordFindUniqueArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PublicRelationsRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PublicRelationsRecordFindUniqueOrThrowArgs} args - Arguments to find a PublicRelationsRecord
     * @example
     * // Get one PublicRelationsRecord
     * const publicRelationsRecord = await prisma.publicRelationsRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicRelationsRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicRelationsRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PublicRelationsRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicRelationsRecordFindFirstArgs} args - Arguments to find a PublicRelationsRecord
     * @example
     * // Get one PublicRelationsRecord
     * const publicRelationsRecord = await prisma.publicRelationsRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicRelationsRecordFindFirstArgs>(args?: SelectSubset<T, PublicRelationsRecordFindFirstArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PublicRelationsRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicRelationsRecordFindFirstOrThrowArgs} args - Arguments to find a PublicRelationsRecord
     * @example
     * // Get one PublicRelationsRecord
     * const publicRelationsRecord = await prisma.publicRelationsRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicRelationsRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicRelationsRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PublicRelationsRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicRelationsRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PublicRelationsRecords
     * const publicRelationsRecords = await prisma.publicRelationsRecord.findMany()
     * 
     * // Get first 10 PublicRelationsRecords
     * const publicRelationsRecords = await prisma.publicRelationsRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicRelationsRecordWithIdOnly = await prisma.publicRelationsRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublicRelationsRecordFindManyArgs>(args?: SelectSubset<T, PublicRelationsRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PublicRelationsRecord.
     * @param {PublicRelationsRecordCreateArgs} args - Arguments to create a PublicRelationsRecord.
     * @example
     * // Create one PublicRelationsRecord
     * const PublicRelationsRecord = await prisma.publicRelationsRecord.create({
     *   data: {
     *     // ... data to create a PublicRelationsRecord
     *   }
     * })
     * 
     */
    create<T extends PublicRelationsRecordCreateArgs>(args: SelectSubset<T, PublicRelationsRecordCreateArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PublicRelationsRecords.
     * @param {PublicRelationsRecordCreateManyArgs} args - Arguments to create many PublicRelationsRecords.
     * @example
     * // Create many PublicRelationsRecords
     * const publicRelationsRecord = await prisma.publicRelationsRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicRelationsRecordCreateManyArgs>(args?: SelectSubset<T, PublicRelationsRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PublicRelationsRecords and returns the data saved in the database.
     * @param {PublicRelationsRecordCreateManyAndReturnArgs} args - Arguments to create many PublicRelationsRecords.
     * @example
     * // Create many PublicRelationsRecords
     * const publicRelationsRecord = await prisma.publicRelationsRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PublicRelationsRecords and only return the `id`
     * const publicRelationsRecordWithIdOnly = await prisma.publicRelationsRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PublicRelationsRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, PublicRelationsRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PublicRelationsRecord.
     * @param {PublicRelationsRecordDeleteArgs} args - Arguments to delete one PublicRelationsRecord.
     * @example
     * // Delete one PublicRelationsRecord
     * const PublicRelationsRecord = await prisma.publicRelationsRecord.delete({
     *   where: {
     *     // ... filter to delete one PublicRelationsRecord
     *   }
     * })
     * 
     */
    delete<T extends PublicRelationsRecordDeleteArgs>(args: SelectSubset<T, PublicRelationsRecordDeleteArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PublicRelationsRecord.
     * @param {PublicRelationsRecordUpdateArgs} args - Arguments to update one PublicRelationsRecord.
     * @example
     * // Update one PublicRelationsRecord
     * const publicRelationsRecord = await prisma.publicRelationsRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicRelationsRecordUpdateArgs>(args: SelectSubset<T, PublicRelationsRecordUpdateArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PublicRelationsRecords.
     * @param {PublicRelationsRecordDeleteManyArgs} args - Arguments to filter PublicRelationsRecords to delete.
     * @example
     * // Delete a few PublicRelationsRecords
     * const { count } = await prisma.publicRelationsRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicRelationsRecordDeleteManyArgs>(args?: SelectSubset<T, PublicRelationsRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublicRelationsRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicRelationsRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PublicRelationsRecords
     * const publicRelationsRecord = await prisma.publicRelationsRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicRelationsRecordUpdateManyArgs>(args: SelectSubset<T, PublicRelationsRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PublicRelationsRecord.
     * @param {PublicRelationsRecordUpsertArgs} args - Arguments to update or create a PublicRelationsRecord.
     * @example
     * // Update or create a PublicRelationsRecord
     * const publicRelationsRecord = await prisma.publicRelationsRecord.upsert({
     *   create: {
     *     // ... data to create a PublicRelationsRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PublicRelationsRecord we want to update
     *   }
     * })
     */
    upsert<T extends PublicRelationsRecordUpsertArgs>(args: SelectSubset<T, PublicRelationsRecordUpsertArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PublicRelationsRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicRelationsRecordCountArgs} args - Arguments to filter PublicRelationsRecords to count.
     * @example
     * // Count the number of PublicRelationsRecords
     * const count = await prisma.publicRelationsRecord.count({
     *   where: {
     *     // ... the filter for the PublicRelationsRecords we want to count
     *   }
     * })
    **/
    count<T extends PublicRelationsRecordCountArgs>(
      args?: Subset<T, PublicRelationsRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicRelationsRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PublicRelationsRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicRelationsRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicRelationsRecordAggregateArgs>(args: Subset<T, PublicRelationsRecordAggregateArgs>): Prisma.PrismaPromise<GetPublicRelationsRecordAggregateType<T>>

    /**
     * Group by PublicRelationsRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicRelationsRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicRelationsRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicRelationsRecordGroupByArgs['orderBy'] }
        : { orderBy?: PublicRelationsRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicRelationsRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicRelationsRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PublicRelationsRecord model
   */
  readonly fields: PublicRelationsRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PublicRelationsRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicRelationsRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    handledByAdmin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academy<T extends AcademyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademyDefaultArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responses<T extends PublicRelationsRecord$responsesArgs<ExtArgs> = {}>(args?: Subset<T, PublicRelationsRecord$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends PublicRelationsRecord$eventsArgs<ExtArgs> = {}>(args?: Subset<T, PublicRelationsRecord$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    posts<T extends PublicRelationsRecord$postsArgs<ExtArgs> = {}>(args?: Subset<T, PublicRelationsRecord$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends PublicRelationsRecord$filesArgs<ExtArgs> = {}>(args?: Subset<T, PublicRelationsRecord$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    channels<T extends PublicRelationsRecord$channelsArgs<ExtArgs> = {}>(args?: Subset<T, PublicRelationsRecord$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PublicRelationsRecord model
   */ 
  interface PublicRelationsRecordFieldRefs {
    readonly id: FieldRef<"PublicRelationsRecord", 'String'>
    readonly message: FieldRef<"PublicRelationsRecord", 'String'>
    readonly senderName: FieldRef<"PublicRelationsRecord", 'String'>
    readonly senderContact: FieldRef<"PublicRelationsRecord", 'String'>
    readonly status: FieldRef<"PublicRelationsRecord", 'PRRequestStatus'>
    readonly handledByAdminId: FieldRef<"PublicRelationsRecord", 'String'>
    readonly academyId: FieldRef<"PublicRelationsRecord", 'String'>
    readonly createdAt: FieldRef<"PublicRelationsRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"PublicRelationsRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PublicRelationsRecord findUnique
   */
  export type PublicRelationsRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    /**
     * Filter, which PublicRelationsRecord to fetch.
     */
    where: PublicRelationsRecordWhereUniqueInput
  }

  /**
   * PublicRelationsRecord findUniqueOrThrow
   */
  export type PublicRelationsRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    /**
     * Filter, which PublicRelationsRecord to fetch.
     */
    where: PublicRelationsRecordWhereUniqueInput
  }

  /**
   * PublicRelationsRecord findFirst
   */
  export type PublicRelationsRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    /**
     * Filter, which PublicRelationsRecord to fetch.
     */
    where?: PublicRelationsRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicRelationsRecords to fetch.
     */
    orderBy?: PublicRelationsRecordOrderByWithRelationInput | PublicRelationsRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicRelationsRecords.
     */
    cursor?: PublicRelationsRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicRelationsRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicRelationsRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicRelationsRecords.
     */
    distinct?: PublicRelationsRecordScalarFieldEnum | PublicRelationsRecordScalarFieldEnum[]
  }

  /**
   * PublicRelationsRecord findFirstOrThrow
   */
  export type PublicRelationsRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    /**
     * Filter, which PublicRelationsRecord to fetch.
     */
    where?: PublicRelationsRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicRelationsRecords to fetch.
     */
    orderBy?: PublicRelationsRecordOrderByWithRelationInput | PublicRelationsRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicRelationsRecords.
     */
    cursor?: PublicRelationsRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicRelationsRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicRelationsRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicRelationsRecords.
     */
    distinct?: PublicRelationsRecordScalarFieldEnum | PublicRelationsRecordScalarFieldEnum[]
  }

  /**
   * PublicRelationsRecord findMany
   */
  export type PublicRelationsRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    /**
     * Filter, which PublicRelationsRecords to fetch.
     */
    where?: PublicRelationsRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicRelationsRecords to fetch.
     */
    orderBy?: PublicRelationsRecordOrderByWithRelationInput | PublicRelationsRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PublicRelationsRecords.
     */
    cursor?: PublicRelationsRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicRelationsRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicRelationsRecords.
     */
    skip?: number
    distinct?: PublicRelationsRecordScalarFieldEnum | PublicRelationsRecordScalarFieldEnum[]
  }

  /**
   * PublicRelationsRecord create
   */
  export type PublicRelationsRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a PublicRelationsRecord.
     */
    data: XOR<PublicRelationsRecordCreateInput, PublicRelationsRecordUncheckedCreateInput>
  }

  /**
   * PublicRelationsRecord createMany
   */
  export type PublicRelationsRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PublicRelationsRecords.
     */
    data: PublicRelationsRecordCreateManyInput | PublicRelationsRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PublicRelationsRecord createManyAndReturn
   */
  export type PublicRelationsRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PublicRelationsRecords.
     */
    data: PublicRelationsRecordCreateManyInput | PublicRelationsRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PublicRelationsRecord update
   */
  export type PublicRelationsRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a PublicRelationsRecord.
     */
    data: XOR<PublicRelationsRecordUpdateInput, PublicRelationsRecordUncheckedUpdateInput>
    /**
     * Choose, which PublicRelationsRecord to update.
     */
    where: PublicRelationsRecordWhereUniqueInput
  }

  /**
   * PublicRelationsRecord updateMany
   */
  export type PublicRelationsRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PublicRelationsRecords.
     */
    data: XOR<PublicRelationsRecordUpdateManyMutationInput, PublicRelationsRecordUncheckedUpdateManyInput>
    /**
     * Filter which PublicRelationsRecords to update
     */
    where?: PublicRelationsRecordWhereInput
  }

  /**
   * PublicRelationsRecord upsert
   */
  export type PublicRelationsRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the PublicRelationsRecord to update in case it exists.
     */
    where: PublicRelationsRecordWhereUniqueInput
    /**
     * In case the PublicRelationsRecord found by the `where` argument doesn't exist, create a new PublicRelationsRecord with this data.
     */
    create: XOR<PublicRelationsRecordCreateInput, PublicRelationsRecordUncheckedCreateInput>
    /**
     * In case the PublicRelationsRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicRelationsRecordUpdateInput, PublicRelationsRecordUncheckedUpdateInput>
  }

  /**
   * PublicRelationsRecord delete
   */
  export type PublicRelationsRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
    /**
     * Filter which PublicRelationsRecord to delete.
     */
    where: PublicRelationsRecordWhereUniqueInput
  }

  /**
   * PublicRelationsRecord deleteMany
   */
  export type PublicRelationsRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicRelationsRecords to delete
     */
    where?: PublicRelationsRecordWhereInput
  }

  /**
   * PublicRelationsRecord.responses
   */
  export type PublicRelationsRecord$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    where?: PRResponseWhereInput
    orderBy?: PRResponseOrderByWithRelationInput | PRResponseOrderByWithRelationInput[]
    cursor?: PRResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PRResponseScalarFieldEnum | PRResponseScalarFieldEnum[]
  }

  /**
   * PublicRelationsRecord.events
   */
  export type PublicRelationsRecord$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * PublicRelationsRecord.posts
   */
  export type PublicRelationsRecord$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * PublicRelationsRecord.files
   */
  export type PublicRelationsRecord$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * PublicRelationsRecord.channels
   */
  export type PublicRelationsRecord$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * PublicRelationsRecord without action
   */
  export type PublicRelationsRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicRelationsRecord
     */
    select?: PublicRelationsRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicRelationsRecordInclude<ExtArgs> | null
  }


  /**
   * Model PRResponse
   */

  export type AggregatePRResponse = {
    _count: PRResponseCountAggregateOutputType | null
    _min: PRResponseMinAggregateOutputType | null
    _max: PRResponseMaxAggregateOutputType | null
  }

  export type PRResponseMinAggregateOutputType = {
    id: string | null
    response: string | null
    prRecordId: string | null
    respondedByAdminId: string | null
    createdAt: Date | null
  }

  export type PRResponseMaxAggregateOutputType = {
    id: string | null
    response: string | null
    prRecordId: string | null
    respondedByAdminId: string | null
    createdAt: Date | null
  }

  export type PRResponseCountAggregateOutputType = {
    id: number
    response: number
    prRecordId: number
    respondedByAdminId: number
    createdAt: number
    _all: number
  }


  export type PRResponseMinAggregateInputType = {
    id?: true
    response?: true
    prRecordId?: true
    respondedByAdminId?: true
    createdAt?: true
  }

  export type PRResponseMaxAggregateInputType = {
    id?: true
    response?: true
    prRecordId?: true
    respondedByAdminId?: true
    createdAt?: true
  }

  export type PRResponseCountAggregateInputType = {
    id?: true
    response?: true
    prRecordId?: true
    respondedByAdminId?: true
    createdAt?: true
    _all?: true
  }

  export type PRResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRResponse to aggregate.
     */
    where?: PRResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRResponses to fetch.
     */
    orderBy?: PRResponseOrderByWithRelationInput | PRResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PRResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PRResponses
    **/
    _count?: true | PRResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PRResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PRResponseMaxAggregateInputType
  }

  export type GetPRResponseAggregateType<T extends PRResponseAggregateArgs> = {
        [P in keyof T & keyof AggregatePRResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePRResponse[P]>
      : GetScalarType<T[P], AggregatePRResponse[P]>
  }




  export type PRResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PRResponseWhereInput
    orderBy?: PRResponseOrderByWithAggregationInput | PRResponseOrderByWithAggregationInput[]
    by: PRResponseScalarFieldEnum[] | PRResponseScalarFieldEnum
    having?: PRResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PRResponseCountAggregateInputType | true
    _min?: PRResponseMinAggregateInputType
    _max?: PRResponseMaxAggregateInputType
  }

  export type PRResponseGroupByOutputType = {
    id: string
    response: string
    prRecordId: string
    respondedByAdminId: string
    createdAt: Date
    _count: PRResponseCountAggregateOutputType | null
    _min: PRResponseMinAggregateOutputType | null
    _max: PRResponseMaxAggregateOutputType | null
  }

  type GetPRResponseGroupByPayload<T extends PRResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PRResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PRResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PRResponseGroupByOutputType[P]>
            : GetScalarType<T[P], PRResponseGroupByOutputType[P]>
        }
      >
    >


  export type PRResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    response?: boolean
    prRecordId?: boolean
    respondedByAdminId?: boolean
    createdAt?: boolean
    prRecord?: boolean | PublicRelationsRecordDefaultArgs<ExtArgs>
    respondedByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pRResponse"]>

  export type PRResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    response?: boolean
    prRecordId?: boolean
    respondedByAdminId?: boolean
    createdAt?: boolean
    prRecord?: boolean | PublicRelationsRecordDefaultArgs<ExtArgs>
    respondedByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pRResponse"]>

  export type PRResponseSelectScalar = {
    id?: boolean
    response?: boolean
    prRecordId?: boolean
    respondedByAdminId?: boolean
    createdAt?: boolean
  }

  export type PRResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prRecord?: boolean | PublicRelationsRecordDefaultArgs<ExtArgs>
    respondedByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type PRResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prRecord?: boolean | PublicRelationsRecordDefaultArgs<ExtArgs>
    respondedByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $PRResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PRResponse"
    objects: {
      prRecord: Prisma.$PublicRelationsRecordPayload<ExtArgs>
      respondedByAdmin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      response: string
      prRecordId: string
      respondedByAdminId: string
      createdAt: Date
    }, ExtArgs["result"]["pRResponse"]>
    composites: {}
  }

  type PRResponseGetPayload<S extends boolean | null | undefined | PRResponseDefaultArgs> = $Result.GetResult<Prisma.$PRResponsePayload, S>

  type PRResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PRResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PRResponseCountAggregateInputType | true
    }

  export interface PRResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PRResponse'], meta: { name: 'PRResponse' } }
    /**
     * Find zero or one PRResponse that matches the filter.
     * @param {PRResponseFindUniqueArgs} args - Arguments to find a PRResponse
     * @example
     * // Get one PRResponse
     * const pRResponse = await prisma.pRResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PRResponseFindUniqueArgs>(args: SelectSubset<T, PRResponseFindUniqueArgs<ExtArgs>>): Prisma__PRResponseClient<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PRResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PRResponseFindUniqueOrThrowArgs} args - Arguments to find a PRResponse
     * @example
     * // Get one PRResponse
     * const pRResponse = await prisma.pRResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PRResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, PRResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PRResponseClient<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PRResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRResponseFindFirstArgs} args - Arguments to find a PRResponse
     * @example
     * // Get one PRResponse
     * const pRResponse = await prisma.pRResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PRResponseFindFirstArgs>(args?: SelectSubset<T, PRResponseFindFirstArgs<ExtArgs>>): Prisma__PRResponseClient<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PRResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRResponseFindFirstOrThrowArgs} args - Arguments to find a PRResponse
     * @example
     * // Get one PRResponse
     * const pRResponse = await prisma.pRResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PRResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, PRResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PRResponseClient<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PRResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PRResponses
     * const pRResponses = await prisma.pRResponse.findMany()
     * 
     * // Get first 10 PRResponses
     * const pRResponses = await prisma.pRResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pRResponseWithIdOnly = await prisma.pRResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PRResponseFindManyArgs>(args?: SelectSubset<T, PRResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PRResponse.
     * @param {PRResponseCreateArgs} args - Arguments to create a PRResponse.
     * @example
     * // Create one PRResponse
     * const PRResponse = await prisma.pRResponse.create({
     *   data: {
     *     // ... data to create a PRResponse
     *   }
     * })
     * 
     */
    create<T extends PRResponseCreateArgs>(args: SelectSubset<T, PRResponseCreateArgs<ExtArgs>>): Prisma__PRResponseClient<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PRResponses.
     * @param {PRResponseCreateManyArgs} args - Arguments to create many PRResponses.
     * @example
     * // Create many PRResponses
     * const pRResponse = await prisma.pRResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PRResponseCreateManyArgs>(args?: SelectSubset<T, PRResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PRResponses and returns the data saved in the database.
     * @param {PRResponseCreateManyAndReturnArgs} args - Arguments to create many PRResponses.
     * @example
     * // Create many PRResponses
     * const pRResponse = await prisma.pRResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PRResponses and only return the `id`
     * const pRResponseWithIdOnly = await prisma.pRResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PRResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, PRResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PRResponse.
     * @param {PRResponseDeleteArgs} args - Arguments to delete one PRResponse.
     * @example
     * // Delete one PRResponse
     * const PRResponse = await prisma.pRResponse.delete({
     *   where: {
     *     // ... filter to delete one PRResponse
     *   }
     * })
     * 
     */
    delete<T extends PRResponseDeleteArgs>(args: SelectSubset<T, PRResponseDeleteArgs<ExtArgs>>): Prisma__PRResponseClient<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PRResponse.
     * @param {PRResponseUpdateArgs} args - Arguments to update one PRResponse.
     * @example
     * // Update one PRResponse
     * const pRResponse = await prisma.pRResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PRResponseUpdateArgs>(args: SelectSubset<T, PRResponseUpdateArgs<ExtArgs>>): Prisma__PRResponseClient<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PRResponses.
     * @param {PRResponseDeleteManyArgs} args - Arguments to filter PRResponses to delete.
     * @example
     * // Delete a few PRResponses
     * const { count } = await prisma.pRResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PRResponseDeleteManyArgs>(args?: SelectSubset<T, PRResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PRResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PRResponses
     * const pRResponse = await prisma.pRResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PRResponseUpdateManyArgs>(args: SelectSubset<T, PRResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PRResponse.
     * @param {PRResponseUpsertArgs} args - Arguments to update or create a PRResponse.
     * @example
     * // Update or create a PRResponse
     * const pRResponse = await prisma.pRResponse.upsert({
     *   create: {
     *     // ... data to create a PRResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PRResponse we want to update
     *   }
     * })
     */
    upsert<T extends PRResponseUpsertArgs>(args: SelectSubset<T, PRResponseUpsertArgs<ExtArgs>>): Prisma__PRResponseClient<$Result.GetResult<Prisma.$PRResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PRResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRResponseCountArgs} args - Arguments to filter PRResponses to count.
     * @example
     * // Count the number of PRResponses
     * const count = await prisma.pRResponse.count({
     *   where: {
     *     // ... the filter for the PRResponses we want to count
     *   }
     * })
    **/
    count<T extends PRResponseCountArgs>(
      args?: Subset<T, PRResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PRResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PRResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PRResponseAggregateArgs>(args: Subset<T, PRResponseAggregateArgs>): Prisma.PrismaPromise<GetPRResponseAggregateType<T>>

    /**
     * Group by PRResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PRResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PRResponseGroupByArgs['orderBy'] }
        : { orderBy?: PRResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PRResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPRResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PRResponse model
   */
  readonly fields: PRResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PRResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PRResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prRecord<T extends PublicRelationsRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicRelationsRecordDefaultArgs<ExtArgs>>): Prisma__PublicRelationsRecordClient<$Result.GetResult<Prisma.$PublicRelationsRecordPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    respondedByAdmin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PRResponse model
   */ 
  interface PRResponseFieldRefs {
    readonly id: FieldRef<"PRResponse", 'String'>
    readonly response: FieldRef<"PRResponse", 'String'>
    readonly prRecordId: FieldRef<"PRResponse", 'String'>
    readonly respondedByAdminId: FieldRef<"PRResponse", 'String'>
    readonly createdAt: FieldRef<"PRResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PRResponse findUnique
   */
  export type PRResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    /**
     * Filter, which PRResponse to fetch.
     */
    where: PRResponseWhereUniqueInput
  }

  /**
   * PRResponse findUniqueOrThrow
   */
  export type PRResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    /**
     * Filter, which PRResponse to fetch.
     */
    where: PRResponseWhereUniqueInput
  }

  /**
   * PRResponse findFirst
   */
  export type PRResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    /**
     * Filter, which PRResponse to fetch.
     */
    where?: PRResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRResponses to fetch.
     */
    orderBy?: PRResponseOrderByWithRelationInput | PRResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRResponses.
     */
    cursor?: PRResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRResponses.
     */
    distinct?: PRResponseScalarFieldEnum | PRResponseScalarFieldEnum[]
  }

  /**
   * PRResponse findFirstOrThrow
   */
  export type PRResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    /**
     * Filter, which PRResponse to fetch.
     */
    where?: PRResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRResponses to fetch.
     */
    orderBy?: PRResponseOrderByWithRelationInput | PRResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRResponses.
     */
    cursor?: PRResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRResponses.
     */
    distinct?: PRResponseScalarFieldEnum | PRResponseScalarFieldEnum[]
  }

  /**
   * PRResponse findMany
   */
  export type PRResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    /**
     * Filter, which PRResponses to fetch.
     */
    where?: PRResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRResponses to fetch.
     */
    orderBy?: PRResponseOrderByWithRelationInput | PRResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PRResponses.
     */
    cursor?: PRResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRResponses.
     */
    skip?: number
    distinct?: PRResponseScalarFieldEnum | PRResponseScalarFieldEnum[]
  }

  /**
   * PRResponse create
   */
  export type PRResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a PRResponse.
     */
    data: XOR<PRResponseCreateInput, PRResponseUncheckedCreateInput>
  }

  /**
   * PRResponse createMany
   */
  export type PRResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PRResponses.
     */
    data: PRResponseCreateManyInput | PRResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PRResponse createManyAndReturn
   */
  export type PRResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PRResponses.
     */
    data: PRResponseCreateManyInput | PRResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PRResponse update
   */
  export type PRResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a PRResponse.
     */
    data: XOR<PRResponseUpdateInput, PRResponseUncheckedUpdateInput>
    /**
     * Choose, which PRResponse to update.
     */
    where: PRResponseWhereUniqueInput
  }

  /**
   * PRResponse updateMany
   */
  export type PRResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PRResponses.
     */
    data: XOR<PRResponseUpdateManyMutationInput, PRResponseUncheckedUpdateManyInput>
    /**
     * Filter which PRResponses to update
     */
    where?: PRResponseWhereInput
  }

  /**
   * PRResponse upsert
   */
  export type PRResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the PRResponse to update in case it exists.
     */
    where: PRResponseWhereUniqueInput
    /**
     * In case the PRResponse found by the `where` argument doesn't exist, create a new PRResponse with this data.
     */
    create: XOR<PRResponseCreateInput, PRResponseUncheckedCreateInput>
    /**
     * In case the PRResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PRResponseUpdateInput, PRResponseUncheckedUpdateInput>
  }

  /**
   * PRResponse delete
   */
  export type PRResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
    /**
     * Filter which PRResponse to delete.
     */
    where: PRResponseWhereUniqueInput
  }

  /**
   * PRResponse deleteMany
   */
  export type PRResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PRResponses to delete
     */
    where?: PRResponseWhereInput
  }

  /**
   * PRResponse without action
   */
  export type PRResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PRResponse
     */
    select?: PRResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PRResponseInclude<ExtArgs> | null
  }


  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingMinAggregateOutputType = {
    id: string | null
    meetingTitle: string | null
    meetingDate: Date | null
    location: string | null
    notes: string | null
    createdByAdminId: string | null
    academyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingMaxAggregateOutputType = {
    id: string | null
    meetingTitle: string | null
    meetingDate: Date | null
    location: string | null
    notes: string | null
    createdByAdminId: string | null
    academyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingCountAggregateOutputType = {
    id: number
    meetingTitle: number
    meetingDate: number
    location: number
    notes: number
    createdByAdminId: number
    academyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeetingMinAggregateInputType = {
    id?: true
    meetingTitle?: true
    meetingDate?: true
    location?: true
    notes?: true
    createdByAdminId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingMaxAggregateInputType = {
    id?: true
    meetingTitle?: true
    meetingDate?: true
    location?: true
    notes?: true
    createdByAdminId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingCountAggregateInputType = {
    id?: true
    meetingTitle?: true
    meetingDate?: true
    location?: true
    notes?: true
    createdByAdminId?: true
    academyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type MeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithAggregationInput | MeetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: MeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    id: string
    meetingTitle: string
    meetingDate: Date
    location: string
    notes: string | null
    createdByAdminId: string
    academyId: string
    createdAt: Date
    updatedAt: Date
    _count: MeetingCountAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingTitle?: boolean
    meetingDate?: boolean
    location?: boolean
    notes?: boolean
    createdByAdminId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    participants?: boolean | Meeting$participantsArgs<ExtArgs>
    files?: boolean | Meeting$filesArgs<ExtArgs>
    reports?: boolean | Meeting$reportsArgs<ExtArgs>
    channels?: boolean | Meeting$channelsArgs<ExtArgs>
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingTitle?: boolean
    meetingDate?: boolean
    location?: boolean
    notes?: boolean
    createdByAdminId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectScalar = {
    id?: boolean
    meetingTitle?: boolean
    meetingDate?: boolean
    location?: boolean
    notes?: boolean
    createdByAdminId?: boolean
    academyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    participants?: boolean | Meeting$participantsArgs<ExtArgs>
    files?: boolean | Meeting$filesArgs<ExtArgs>
    reports?: boolean | Meeting$reportsArgs<ExtArgs>
    channels?: boolean | Meeting$channelsArgs<ExtArgs>
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MeetingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdByAdmin?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
  }

  export type $MeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meeting"
    objects: {
      createdByAdmin: Prisma.$AdminPayload<ExtArgs>
      academy: Prisma.$AcademyPayload<ExtArgs>
      participants: Prisma.$MeetingParticipantPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      channels: Prisma.$ChannelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meetingTitle: string
      meetingDate: Date
      location: string
      notes: string | null
      createdByAdminId: string
      academyId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }

  type MeetingGetPayload<S extends boolean | null | undefined | MeetingDefaultArgs> = $Result.GetResult<Prisma.$MeetingPayload, S>

  type MeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface MeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meeting'], meta: { name: 'Meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingFindUniqueArgs>(args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingFindFirstArgs>(args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingFindManyArgs>(args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
     */
    create<T extends MeetingCreateArgs>(args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meetings.
     * @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingCreateManyArgs>(args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meetings and returns the data saved in the database.
     * @param {MeetingCreateManyAndReturnArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
     */
    delete<T extends MeetingDeleteArgs>(args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingUpdateArgs>(args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingDeleteManyArgs>(args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingUpdateManyArgs>(args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends MeetingUpsertArgs>(args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meeting model
   */
  readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdByAdmin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academy<T extends AcademyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademyDefaultArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    participants<T extends Meeting$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends Meeting$filesArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends Meeting$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    channels<T extends Meeting$channelsArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meeting model
   */ 
  interface MeetingFieldRefs {
    readonly id: FieldRef<"Meeting", 'String'>
    readonly meetingTitle: FieldRef<"Meeting", 'String'>
    readonly meetingDate: FieldRef<"Meeting", 'DateTime'>
    readonly location: FieldRef<"Meeting", 'String'>
    readonly notes: FieldRef<"Meeting", 'String'>
    readonly createdByAdminId: FieldRef<"Meeting", 'String'>
    readonly academyId: FieldRef<"Meeting", 'String'>
    readonly createdAt: FieldRef<"Meeting", 'DateTime'>
    readonly updatedAt: FieldRef<"Meeting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting create
   */
  export type MeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
  }

  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meeting createManyAndReturn
   */
  export type MeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
  }

  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
  }

  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput
  }

  /**
   * Meeting.participants
   */
  export type Meeting$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    where?: MeetingParticipantWhereInput
    orderBy?: MeetingParticipantOrderByWithRelationInput | MeetingParticipantOrderByWithRelationInput[]
    cursor?: MeetingParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingParticipantScalarFieldEnum | MeetingParticipantScalarFieldEnum[]
  }

  /**
   * Meeting.files
   */
  export type Meeting$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Meeting.reports
   */
  export type Meeting$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Meeting.channels
   */
  export type Meeting$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
  }


  /**
   * Model MeetingParticipant
   */

  export type AggregateMeetingParticipant = {
    _count: MeetingParticipantCountAggregateOutputType | null
    _min: MeetingParticipantMinAggregateOutputType | null
    _max: MeetingParticipantMaxAggregateOutputType | null
  }

  export type MeetingParticipantMinAggregateOutputType = {
    id: string | null
    meetingId: string | null
    userId: string | null
    isAttended: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingParticipantMaxAggregateOutputType = {
    id: string | null
    meetingId: string | null
    userId: string | null
    isAttended: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingParticipantCountAggregateOutputType = {
    id: number
    meetingId: number
    userId: number
    isAttended: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeetingParticipantMinAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    isAttended?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingParticipantMaxAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    isAttended?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingParticipantCountAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    isAttended?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeetingParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingParticipant to aggregate.
     */
    where?: MeetingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingParticipants to fetch.
     */
    orderBy?: MeetingParticipantOrderByWithRelationInput | MeetingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeetingParticipants
    **/
    _count?: true | MeetingParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingParticipantMaxAggregateInputType
  }

  export type GetMeetingParticipantAggregateType<T extends MeetingParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateMeetingParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeetingParticipant[P]>
      : GetScalarType<T[P], AggregateMeetingParticipant[P]>
  }




  export type MeetingParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingParticipantWhereInput
    orderBy?: MeetingParticipantOrderByWithAggregationInput | MeetingParticipantOrderByWithAggregationInput[]
    by: MeetingParticipantScalarFieldEnum[] | MeetingParticipantScalarFieldEnum
    having?: MeetingParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingParticipantCountAggregateInputType | true
    _min?: MeetingParticipantMinAggregateInputType
    _max?: MeetingParticipantMaxAggregateInputType
  }

  export type MeetingParticipantGroupByOutputType = {
    id: string
    meetingId: string
    userId: string
    isAttended: boolean
    createdAt: Date
    updatedAt: Date
    _count: MeetingParticipantCountAggregateOutputType | null
    _min: MeetingParticipantMinAggregateOutputType | null
    _max: MeetingParticipantMaxAggregateOutputType | null
  }

  type GetMeetingParticipantGroupByPayload<T extends MeetingParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingParticipantGroupByOutputType[P]>
        }
      >
    >


  export type MeetingParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    isAttended?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingParticipant"]>

  export type MeetingParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    isAttended?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingParticipant"]>

  export type MeetingParticipantSelectScalar = {
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    isAttended?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MeetingParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MeetingParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MeetingParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeetingParticipant"
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meetingId: string
      userId: string
      isAttended: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meetingParticipant"]>
    composites: {}
  }

  type MeetingParticipantGetPayload<S extends boolean | null | undefined | MeetingParticipantDefaultArgs> = $Result.GetResult<Prisma.$MeetingParticipantPayload, S>

  type MeetingParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeetingParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeetingParticipantCountAggregateInputType | true
    }

  export interface MeetingParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeetingParticipant'], meta: { name: 'MeetingParticipant' } }
    /**
     * Find zero or one MeetingParticipant that matches the filter.
     * @param {MeetingParticipantFindUniqueArgs} args - Arguments to find a MeetingParticipant
     * @example
     * // Get one MeetingParticipant
     * const meetingParticipant = await prisma.meetingParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingParticipantFindUniqueArgs>(args: SelectSubset<T, MeetingParticipantFindUniqueArgs<ExtArgs>>): Prisma__MeetingParticipantClient<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MeetingParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MeetingParticipantFindUniqueOrThrowArgs} args - Arguments to find a MeetingParticipant
     * @example
     * // Get one MeetingParticipant
     * const meetingParticipant = await prisma.meetingParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingParticipantClient<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MeetingParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingParticipantFindFirstArgs} args - Arguments to find a MeetingParticipant
     * @example
     * // Get one MeetingParticipant
     * const meetingParticipant = await prisma.meetingParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingParticipantFindFirstArgs>(args?: SelectSubset<T, MeetingParticipantFindFirstArgs<ExtArgs>>): Prisma__MeetingParticipantClient<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MeetingParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingParticipantFindFirstOrThrowArgs} args - Arguments to find a MeetingParticipant
     * @example
     * // Get one MeetingParticipant
     * const meetingParticipant = await prisma.meetingParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingParticipantClient<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MeetingParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeetingParticipants
     * const meetingParticipants = await prisma.meetingParticipant.findMany()
     * 
     * // Get first 10 MeetingParticipants
     * const meetingParticipants = await prisma.meetingParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingParticipantWithIdOnly = await prisma.meetingParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingParticipantFindManyArgs>(args?: SelectSubset<T, MeetingParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MeetingParticipant.
     * @param {MeetingParticipantCreateArgs} args - Arguments to create a MeetingParticipant.
     * @example
     * // Create one MeetingParticipant
     * const MeetingParticipant = await prisma.meetingParticipant.create({
     *   data: {
     *     // ... data to create a MeetingParticipant
     *   }
     * })
     * 
     */
    create<T extends MeetingParticipantCreateArgs>(args: SelectSubset<T, MeetingParticipantCreateArgs<ExtArgs>>): Prisma__MeetingParticipantClient<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MeetingParticipants.
     * @param {MeetingParticipantCreateManyArgs} args - Arguments to create many MeetingParticipants.
     * @example
     * // Create many MeetingParticipants
     * const meetingParticipant = await prisma.meetingParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingParticipantCreateManyArgs>(args?: SelectSubset<T, MeetingParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeetingParticipants and returns the data saved in the database.
     * @param {MeetingParticipantCreateManyAndReturnArgs} args - Arguments to create many MeetingParticipants.
     * @example
     * // Create many MeetingParticipants
     * const meetingParticipant = await prisma.meetingParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeetingParticipants and only return the `id`
     * const meetingParticipantWithIdOnly = await prisma.meetingParticipant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MeetingParticipant.
     * @param {MeetingParticipantDeleteArgs} args - Arguments to delete one MeetingParticipant.
     * @example
     * // Delete one MeetingParticipant
     * const MeetingParticipant = await prisma.meetingParticipant.delete({
     *   where: {
     *     // ... filter to delete one MeetingParticipant
     *   }
     * })
     * 
     */
    delete<T extends MeetingParticipantDeleteArgs>(args: SelectSubset<T, MeetingParticipantDeleteArgs<ExtArgs>>): Prisma__MeetingParticipantClient<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MeetingParticipant.
     * @param {MeetingParticipantUpdateArgs} args - Arguments to update one MeetingParticipant.
     * @example
     * // Update one MeetingParticipant
     * const meetingParticipant = await prisma.meetingParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingParticipantUpdateArgs>(args: SelectSubset<T, MeetingParticipantUpdateArgs<ExtArgs>>): Prisma__MeetingParticipantClient<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MeetingParticipants.
     * @param {MeetingParticipantDeleteManyArgs} args - Arguments to filter MeetingParticipants to delete.
     * @example
     * // Delete a few MeetingParticipants
     * const { count } = await prisma.meetingParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingParticipantDeleteManyArgs>(args?: SelectSubset<T, MeetingParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeetingParticipants
     * const meetingParticipant = await prisma.meetingParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingParticipantUpdateManyArgs>(args: SelectSubset<T, MeetingParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MeetingParticipant.
     * @param {MeetingParticipantUpsertArgs} args - Arguments to update or create a MeetingParticipant.
     * @example
     * // Update or create a MeetingParticipant
     * const meetingParticipant = await prisma.meetingParticipant.upsert({
     *   create: {
     *     // ... data to create a MeetingParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeetingParticipant we want to update
     *   }
     * })
     */
    upsert<T extends MeetingParticipantUpsertArgs>(args: SelectSubset<T, MeetingParticipantUpsertArgs<ExtArgs>>): Prisma__MeetingParticipantClient<$Result.GetResult<Prisma.$MeetingParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MeetingParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingParticipantCountArgs} args - Arguments to filter MeetingParticipants to count.
     * @example
     * // Count the number of MeetingParticipants
     * const count = await prisma.meetingParticipant.count({
     *   where: {
     *     // ... the filter for the MeetingParticipants we want to count
     *   }
     * })
    **/
    count<T extends MeetingParticipantCountArgs>(
      args?: Subset<T, MeetingParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeetingParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingParticipantAggregateArgs>(args: Subset<T, MeetingParticipantAggregateArgs>): Prisma.PrismaPromise<GetMeetingParticipantAggregateType<T>>

    /**
     * Group by MeetingParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingParticipantGroupByArgs['orderBy'] }
        : { orderBy?: MeetingParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeetingParticipant model
   */
  readonly fields: MeetingParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeetingParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeetingDefaultArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeetingParticipant model
   */ 
  interface MeetingParticipantFieldRefs {
    readonly id: FieldRef<"MeetingParticipant", 'String'>
    readonly meetingId: FieldRef<"MeetingParticipant", 'String'>
    readonly userId: FieldRef<"MeetingParticipant", 'String'>
    readonly isAttended: FieldRef<"MeetingParticipant", 'Boolean'>
    readonly createdAt: FieldRef<"MeetingParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"MeetingParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MeetingParticipant findUnique
   */
  export type MeetingParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MeetingParticipant to fetch.
     */
    where: MeetingParticipantWhereUniqueInput
  }

  /**
   * MeetingParticipant findUniqueOrThrow
   */
  export type MeetingParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MeetingParticipant to fetch.
     */
    where: MeetingParticipantWhereUniqueInput
  }

  /**
   * MeetingParticipant findFirst
   */
  export type MeetingParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MeetingParticipant to fetch.
     */
    where?: MeetingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingParticipants to fetch.
     */
    orderBy?: MeetingParticipantOrderByWithRelationInput | MeetingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingParticipants.
     */
    cursor?: MeetingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingParticipants.
     */
    distinct?: MeetingParticipantScalarFieldEnum | MeetingParticipantScalarFieldEnum[]
  }

  /**
   * MeetingParticipant findFirstOrThrow
   */
  export type MeetingParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MeetingParticipant to fetch.
     */
    where?: MeetingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingParticipants to fetch.
     */
    orderBy?: MeetingParticipantOrderByWithRelationInput | MeetingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingParticipants.
     */
    cursor?: MeetingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingParticipants.
     */
    distinct?: MeetingParticipantScalarFieldEnum | MeetingParticipantScalarFieldEnum[]
  }

  /**
   * MeetingParticipant findMany
   */
  export type MeetingParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MeetingParticipants to fetch.
     */
    where?: MeetingParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingParticipants to fetch.
     */
    orderBy?: MeetingParticipantOrderByWithRelationInput | MeetingParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeetingParticipants.
     */
    cursor?: MeetingParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingParticipants.
     */
    skip?: number
    distinct?: MeetingParticipantScalarFieldEnum | MeetingParticipantScalarFieldEnum[]
  }

  /**
   * MeetingParticipant create
   */
  export type MeetingParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a MeetingParticipant.
     */
    data: XOR<MeetingParticipantCreateInput, MeetingParticipantUncheckedCreateInput>
  }

  /**
   * MeetingParticipant createMany
   */
  export type MeetingParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeetingParticipants.
     */
    data: MeetingParticipantCreateManyInput | MeetingParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeetingParticipant createManyAndReturn
   */
  export type MeetingParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MeetingParticipants.
     */
    data: MeetingParticipantCreateManyInput | MeetingParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeetingParticipant update
   */
  export type MeetingParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a MeetingParticipant.
     */
    data: XOR<MeetingParticipantUpdateInput, MeetingParticipantUncheckedUpdateInput>
    /**
     * Choose, which MeetingParticipant to update.
     */
    where: MeetingParticipantWhereUniqueInput
  }

  /**
   * MeetingParticipant updateMany
   */
  export type MeetingParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeetingParticipants.
     */
    data: XOR<MeetingParticipantUpdateManyMutationInput, MeetingParticipantUncheckedUpdateManyInput>
    /**
     * Filter which MeetingParticipants to update
     */
    where?: MeetingParticipantWhereInput
  }

  /**
   * MeetingParticipant upsert
   */
  export type MeetingParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the MeetingParticipant to update in case it exists.
     */
    where: MeetingParticipantWhereUniqueInput
    /**
     * In case the MeetingParticipant found by the `where` argument doesn't exist, create a new MeetingParticipant with this data.
     */
    create: XOR<MeetingParticipantCreateInput, MeetingParticipantUncheckedCreateInput>
    /**
     * In case the MeetingParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingParticipantUpdateInput, MeetingParticipantUncheckedUpdateInput>
  }

  /**
   * MeetingParticipant delete
   */
  export type MeetingParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
    /**
     * Filter which MeetingParticipant to delete.
     */
    where: MeetingParticipantWhereUniqueInput
  }

  /**
   * MeetingParticipant deleteMany
   */
  export type MeetingParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingParticipants to delete
     */
    where?: MeetingParticipantWhereInput
  }

  /**
   * MeetingParticipant without action
   */
  export type MeetingParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingParticipant
     */
    select?: MeetingParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    AdminRole?: boolean | Permission$AdminRoleArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AdminRole?: boolean | Permission$AdminRoleArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      AdminRole: Prisma.$AdminRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AdminRole<T extends Permission$AdminRoleArgs<ExtArgs> = {}>(args?: Subset<T, Permission$AdminRoleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly isActive: FieldRef<"Permission", 'Boolean'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.AdminRole
   */
  export type Permission$AdminRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    where?: AdminRoleWhereInput
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    cursor?: AdminRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminRoleScalarFieldEnum | AdminRoleScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model AdminRole
   */

  export type AggregateAdminRole = {
    _count: AdminRoleCountAggregateOutputType | null
    _min: AdminRoleMinAggregateOutputType | null
    _max: AdminRoleMaxAggregateOutputType | null
  }

  export type AdminRoleMinAggregateOutputType = {
    id: string | null
    name: $Enums.AdminRoleType | null
    description: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminRoleMaxAggregateOutputType = {
    id: string | null
    name: $Enums.AdminRoleType | null
    description: string | null
    adminId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminRoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    adminId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminRoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminRoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminRoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    adminId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminRole to aggregate.
     */
    where?: AdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminRoles
    **/
    _count?: true | AdminRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminRoleMaxAggregateInputType
  }

  export type GetAdminRoleAggregateType<T extends AdminRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminRole[P]>
      : GetScalarType<T[P], AggregateAdminRole[P]>
  }




  export type AdminRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminRoleWhereInput
    orderBy?: AdminRoleOrderByWithAggregationInput | AdminRoleOrderByWithAggregationInput[]
    by: AdminRoleScalarFieldEnum[] | AdminRoleScalarFieldEnum
    having?: AdminRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminRoleCountAggregateInputType | true
    _min?: AdminRoleMinAggregateInputType
    _max?: AdminRoleMaxAggregateInputType
  }

  export type AdminRoleGroupByOutputType = {
    id: string
    name: $Enums.AdminRoleType
    description: string | null
    adminId: string
    createdAt: Date
    updatedAt: Date
    _count: AdminRoleCountAggregateOutputType | null
    _min: AdminRoleMinAggregateOutputType | null
    _max: AdminRoleMaxAggregateOutputType | null
  }

  type GetAdminRoleGroupByPayload<T extends AdminRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminRoleGroupByOutputType[P]>
            : GetScalarType<T[P], AdminRoleGroupByOutputType[P]>
        }
      >
    >


  export type AdminRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    assignments?: boolean | AdminRole$assignmentsArgs<ExtArgs>
    permissions?: boolean | AdminRole$permissionsArgs<ExtArgs>
    reports?: boolean | AdminRole$reportsArgs<ExtArgs>
    files?: boolean | AdminRole$filesArgs<ExtArgs>
    events?: boolean | AdminRole$eventsArgs<ExtArgs>
    channels?: boolean | AdminRole$channelsArgs<ExtArgs>
    _count?: boolean | AdminRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminRole"]>

  export type AdminRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminRole"]>

  export type AdminRoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    adminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    assignments?: boolean | AdminRole$assignmentsArgs<ExtArgs>
    permissions?: boolean | AdminRole$permissionsArgs<ExtArgs>
    reports?: boolean | AdminRole$reportsArgs<ExtArgs>
    files?: boolean | AdminRole$filesArgs<ExtArgs>
    events?: boolean | AdminRole$eventsArgs<ExtArgs>
    channels?: boolean | AdminRole$channelsArgs<ExtArgs>
    _count?: boolean | AdminRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminRole"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      assignments: Prisma.$AdminAssignmentPayload<ExtArgs>[]
      permissions: Prisma.$PermissionPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      channels: Prisma.$ChannelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: $Enums.AdminRoleType
      description: string | null
      adminId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminRole"]>
    composites: {}
  }

  type AdminRoleGetPayload<S extends boolean | null | undefined | AdminRoleDefaultArgs> = $Result.GetResult<Prisma.$AdminRolePayload, S>

  type AdminRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminRoleCountAggregateInputType | true
    }

  export interface AdminRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminRole'], meta: { name: 'AdminRole' } }
    /**
     * Find zero or one AdminRole that matches the filter.
     * @param {AdminRoleFindUniqueArgs} args - Arguments to find a AdminRole
     * @example
     * // Get one AdminRole
     * const adminRole = await prisma.adminRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminRoleFindUniqueArgs>(args: SelectSubset<T, AdminRoleFindUniqueArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminRoleFindUniqueOrThrowArgs} args - Arguments to find a AdminRole
     * @example
     * // Get one AdminRole
     * const adminRole = await prisma.adminRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleFindFirstArgs} args - Arguments to find a AdminRole
     * @example
     * // Get one AdminRole
     * const adminRole = await prisma.adminRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminRoleFindFirstArgs>(args?: SelectSubset<T, AdminRoleFindFirstArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleFindFirstOrThrowArgs} args - Arguments to find a AdminRole
     * @example
     * // Get one AdminRole
     * const adminRole = await prisma.adminRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminRoles
     * const adminRoles = await prisma.adminRole.findMany()
     * 
     * // Get first 10 AdminRoles
     * const adminRoles = await prisma.adminRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminRoleWithIdOnly = await prisma.adminRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminRoleFindManyArgs>(args?: SelectSubset<T, AdminRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminRole.
     * @param {AdminRoleCreateArgs} args - Arguments to create a AdminRole.
     * @example
     * // Create one AdminRole
     * const AdminRole = await prisma.adminRole.create({
     *   data: {
     *     // ... data to create a AdminRole
     *   }
     * })
     * 
     */
    create<T extends AdminRoleCreateArgs>(args: SelectSubset<T, AdminRoleCreateArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminRoles.
     * @param {AdminRoleCreateManyArgs} args - Arguments to create many AdminRoles.
     * @example
     * // Create many AdminRoles
     * const adminRole = await prisma.adminRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminRoleCreateManyArgs>(args?: SelectSubset<T, AdminRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminRoles and returns the data saved in the database.
     * @param {AdminRoleCreateManyAndReturnArgs} args - Arguments to create many AdminRoles.
     * @example
     * // Create many AdminRoles
     * const adminRole = await prisma.adminRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminRoles and only return the `id`
     * const adminRoleWithIdOnly = await prisma.adminRole.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminRole.
     * @param {AdminRoleDeleteArgs} args - Arguments to delete one AdminRole.
     * @example
     * // Delete one AdminRole
     * const AdminRole = await prisma.adminRole.delete({
     *   where: {
     *     // ... filter to delete one AdminRole
     *   }
     * })
     * 
     */
    delete<T extends AdminRoleDeleteArgs>(args: SelectSubset<T, AdminRoleDeleteArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminRole.
     * @param {AdminRoleUpdateArgs} args - Arguments to update one AdminRole.
     * @example
     * // Update one AdminRole
     * const adminRole = await prisma.adminRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminRoleUpdateArgs>(args: SelectSubset<T, AdminRoleUpdateArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminRoles.
     * @param {AdminRoleDeleteManyArgs} args - Arguments to filter AdminRoles to delete.
     * @example
     * // Delete a few AdminRoles
     * const { count } = await prisma.adminRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminRoleDeleteManyArgs>(args?: SelectSubset<T, AdminRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminRoles
     * const adminRole = await prisma.adminRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminRoleUpdateManyArgs>(args: SelectSubset<T, AdminRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminRole.
     * @param {AdminRoleUpsertArgs} args - Arguments to update or create a AdminRole.
     * @example
     * // Update or create a AdminRole
     * const adminRole = await prisma.adminRole.upsert({
     *   create: {
     *     // ... data to create a AdminRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminRole we want to update
     *   }
     * })
     */
    upsert<T extends AdminRoleUpsertArgs>(args: SelectSubset<T, AdminRoleUpsertArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleCountArgs} args - Arguments to filter AdminRoles to count.
     * @example
     * // Count the number of AdminRoles
     * const count = await prisma.adminRole.count({
     *   where: {
     *     // ... the filter for the AdminRoles we want to count
     *   }
     * })
    **/
    count<T extends AdminRoleCountArgs>(
      args?: Subset<T, AdminRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminRoleAggregateArgs>(args: Subset<T, AdminRoleAggregateArgs>): Prisma.PrismaPromise<GetAdminRoleAggregateType<T>>

    /**
     * Group by AdminRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminRoleGroupByArgs['orderBy'] }
        : { orderBy?: AdminRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminRole model
   */
  readonly fields: AdminRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignments<T extends AdminRole$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, AdminRole$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    permissions<T extends AdminRole$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, AdminRole$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends AdminRole$reportsArgs<ExtArgs> = {}>(args?: Subset<T, AdminRole$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    files<T extends AdminRole$filesArgs<ExtArgs> = {}>(args?: Subset<T, AdminRole$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends AdminRole$eventsArgs<ExtArgs> = {}>(args?: Subset<T, AdminRole$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    channels<T extends AdminRole$channelsArgs<ExtArgs> = {}>(args?: Subset<T, AdminRole$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminRole model
   */ 
  interface AdminRoleFieldRefs {
    readonly id: FieldRef<"AdminRole", 'String'>
    readonly name: FieldRef<"AdminRole", 'AdminRoleType'>
    readonly description: FieldRef<"AdminRole", 'String'>
    readonly adminId: FieldRef<"AdminRole", 'String'>
    readonly createdAt: FieldRef<"AdminRole", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminRole findUnique
   */
  export type AdminRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminRole to fetch.
     */
    where: AdminRoleWhereUniqueInput
  }

  /**
   * AdminRole findUniqueOrThrow
   */
  export type AdminRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminRole to fetch.
     */
    where: AdminRoleWhereUniqueInput
  }

  /**
   * AdminRole findFirst
   */
  export type AdminRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminRole to fetch.
     */
    where?: AdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminRoles.
     */
    cursor?: AdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminRoles.
     */
    distinct?: AdminRoleScalarFieldEnum | AdminRoleScalarFieldEnum[]
  }

  /**
   * AdminRole findFirstOrThrow
   */
  export type AdminRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminRole to fetch.
     */
    where?: AdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminRoles.
     */
    cursor?: AdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminRoles.
     */
    distinct?: AdminRoleScalarFieldEnum | AdminRoleScalarFieldEnum[]
  }

  /**
   * AdminRole findMany
   */
  export type AdminRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter, which AdminRoles to fetch.
     */
    where?: AdminRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminRoles to fetch.
     */
    orderBy?: AdminRoleOrderByWithRelationInput | AdminRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminRoles.
     */
    cursor?: AdminRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminRoles.
     */
    skip?: number
    distinct?: AdminRoleScalarFieldEnum | AdminRoleScalarFieldEnum[]
  }

  /**
   * AdminRole create
   */
  export type AdminRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminRole.
     */
    data: XOR<AdminRoleCreateInput, AdminRoleUncheckedCreateInput>
  }

  /**
   * AdminRole createMany
   */
  export type AdminRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminRoles.
     */
    data: AdminRoleCreateManyInput | AdminRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminRole createManyAndReturn
   */
  export type AdminRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminRoles.
     */
    data: AdminRoleCreateManyInput | AdminRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminRole update
   */
  export type AdminRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminRole.
     */
    data: XOR<AdminRoleUpdateInput, AdminRoleUncheckedUpdateInput>
    /**
     * Choose, which AdminRole to update.
     */
    where: AdminRoleWhereUniqueInput
  }

  /**
   * AdminRole updateMany
   */
  export type AdminRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminRoles.
     */
    data: XOR<AdminRoleUpdateManyMutationInput, AdminRoleUncheckedUpdateManyInput>
    /**
     * Filter which AdminRoles to update
     */
    where?: AdminRoleWhereInput
  }

  /**
   * AdminRole upsert
   */
  export type AdminRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminRole to update in case it exists.
     */
    where: AdminRoleWhereUniqueInput
    /**
     * In case the AdminRole found by the `where` argument doesn't exist, create a new AdminRole with this data.
     */
    create: XOR<AdminRoleCreateInput, AdminRoleUncheckedCreateInput>
    /**
     * In case the AdminRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminRoleUpdateInput, AdminRoleUncheckedUpdateInput>
  }

  /**
   * AdminRole delete
   */
  export type AdminRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
    /**
     * Filter which AdminRole to delete.
     */
    where: AdminRoleWhereUniqueInput
  }

  /**
   * AdminRole deleteMany
   */
  export type AdminRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminRoles to delete
     */
    where?: AdminRoleWhereInput
  }

  /**
   * AdminRole.assignments
   */
  export type AdminRole$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    where?: AdminAssignmentWhereInput
    orderBy?: AdminAssignmentOrderByWithRelationInput | AdminAssignmentOrderByWithRelationInput[]
    cursor?: AdminAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAssignmentScalarFieldEnum | AdminAssignmentScalarFieldEnum[]
  }

  /**
   * AdminRole.permissions
   */
  export type AdminRole$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * AdminRole.reports
   */
  export type AdminRole$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * AdminRole.files
   */
  export type AdminRole$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * AdminRole.events
   */
  export type AdminRole$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * AdminRole.channels
   */
  export type AdminRole$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * AdminRole without action
   */
  export type AdminRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminRole
     */
    select?: AdminRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminRoleInclude<ExtArgs> | null
  }


  /**
   * Model AdminAssignment
   */

  export type AggregateAdminAssignment = {
    _count: AdminAssignmentCountAggregateOutputType | null
    _min: AdminAssignmentMinAggregateOutputType | null
    _max: AdminAssignmentMaxAggregateOutputType | null
  }

  export type AdminAssignmentMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    roleId: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminAssignmentMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    roleId: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminAssignmentCountAggregateOutputType = {
    id: number
    adminId: number
    roleId: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminAssignmentMinAggregateInputType = {
    id?: true
    adminId?: true
    roleId?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminAssignmentMaxAggregateInputType = {
    id?: true
    adminId?: true
    roleId?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminAssignmentCountAggregateInputType = {
    id?: true
    adminId?: true
    roleId?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAssignment to aggregate.
     */
    where?: AdminAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAssignments to fetch.
     */
    orderBy?: AdminAssignmentOrderByWithRelationInput | AdminAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAssignments
    **/
    _count?: true | AdminAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAssignmentMaxAggregateInputType
  }

  export type GetAdminAssignmentAggregateType<T extends AdminAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAssignment[P]>
      : GetScalarType<T[P], AggregateAdminAssignment[P]>
  }




  export type AdminAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAssignmentWhereInput
    orderBy?: AdminAssignmentOrderByWithAggregationInput | AdminAssignmentOrderByWithAggregationInput[]
    by: AdminAssignmentScalarFieldEnum[] | AdminAssignmentScalarFieldEnum
    having?: AdminAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAssignmentCountAggregateInputType | true
    _min?: AdminAssignmentMinAggregateInputType
    _max?: AdminAssignmentMaxAggregateInputType
  }

  export type AdminAssignmentGroupByOutputType = {
    id: string
    adminId: string
    roleId: string
    startDate: Date
    endDate: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AdminAssignmentCountAggregateOutputType | null
    _min: AdminAssignmentMinAggregateOutputType | null
    _max: AdminAssignmentMaxAggregateOutputType | null
  }

  type GetAdminAssignmentGroupByPayload<T extends AdminAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AdminAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    roleId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    role?: boolean | AdminRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAssignment"]>

  export type AdminAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    roleId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    role?: boolean | AdminRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAssignment"]>

  export type AdminAssignmentSelectScalar = {
    id?: boolean
    adminId?: boolean
    roleId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    role?: boolean | AdminRoleDefaultArgs<ExtArgs>
  }
  export type AdminAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    role?: boolean | AdminRoleDefaultArgs<ExtArgs>
  }

  export type $AdminAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAssignment"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      role: Prisma.$AdminRolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      roleId: string
      startDate: Date
      endDate: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminAssignment"]>
    composites: {}
  }

  type AdminAssignmentGetPayload<S extends boolean | null | undefined | AdminAssignmentDefaultArgs> = $Result.GetResult<Prisma.$AdminAssignmentPayload, S>

  type AdminAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminAssignmentCountAggregateInputType | true
    }

  export interface AdminAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAssignment'], meta: { name: 'AdminAssignment' } }
    /**
     * Find zero or one AdminAssignment that matches the filter.
     * @param {AdminAssignmentFindUniqueArgs} args - Arguments to find a AdminAssignment
     * @example
     * // Get one AdminAssignment
     * const adminAssignment = await prisma.adminAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAssignmentFindUniqueArgs>(args: SelectSubset<T, AdminAssignmentFindUniqueArgs<ExtArgs>>): Prisma__AdminAssignmentClient<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminAssignmentFindUniqueOrThrowArgs} args - Arguments to find a AdminAssignment
     * @example
     * // Get one AdminAssignment
     * const adminAssignment = await prisma.adminAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAssignmentClient<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAssignmentFindFirstArgs} args - Arguments to find a AdminAssignment
     * @example
     * // Get one AdminAssignment
     * const adminAssignment = await prisma.adminAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAssignmentFindFirstArgs>(args?: SelectSubset<T, AdminAssignmentFindFirstArgs<ExtArgs>>): Prisma__AdminAssignmentClient<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAssignmentFindFirstOrThrowArgs} args - Arguments to find a AdminAssignment
     * @example
     * // Get one AdminAssignment
     * const adminAssignment = await prisma.adminAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAssignmentClient<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAssignments
     * const adminAssignments = await prisma.adminAssignment.findMany()
     * 
     * // Get first 10 AdminAssignments
     * const adminAssignments = await prisma.adminAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAssignmentWithIdOnly = await prisma.adminAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAssignmentFindManyArgs>(args?: SelectSubset<T, AdminAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminAssignment.
     * @param {AdminAssignmentCreateArgs} args - Arguments to create a AdminAssignment.
     * @example
     * // Create one AdminAssignment
     * const AdminAssignment = await prisma.adminAssignment.create({
     *   data: {
     *     // ... data to create a AdminAssignment
     *   }
     * })
     * 
     */
    create<T extends AdminAssignmentCreateArgs>(args: SelectSubset<T, AdminAssignmentCreateArgs<ExtArgs>>): Prisma__AdminAssignmentClient<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminAssignments.
     * @param {AdminAssignmentCreateManyArgs} args - Arguments to create many AdminAssignments.
     * @example
     * // Create many AdminAssignments
     * const adminAssignment = await prisma.adminAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAssignmentCreateManyArgs>(args?: SelectSubset<T, AdminAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAssignments and returns the data saved in the database.
     * @param {AdminAssignmentCreateManyAndReturnArgs} args - Arguments to create many AdminAssignments.
     * @example
     * // Create many AdminAssignments
     * const adminAssignment = await prisma.adminAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAssignments and only return the `id`
     * const adminAssignmentWithIdOnly = await prisma.adminAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminAssignment.
     * @param {AdminAssignmentDeleteArgs} args - Arguments to delete one AdminAssignment.
     * @example
     * // Delete one AdminAssignment
     * const AdminAssignment = await prisma.adminAssignment.delete({
     *   where: {
     *     // ... filter to delete one AdminAssignment
     *   }
     * })
     * 
     */
    delete<T extends AdminAssignmentDeleteArgs>(args: SelectSubset<T, AdminAssignmentDeleteArgs<ExtArgs>>): Prisma__AdminAssignmentClient<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminAssignment.
     * @param {AdminAssignmentUpdateArgs} args - Arguments to update one AdminAssignment.
     * @example
     * // Update one AdminAssignment
     * const adminAssignment = await prisma.adminAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAssignmentUpdateArgs>(args: SelectSubset<T, AdminAssignmentUpdateArgs<ExtArgs>>): Prisma__AdminAssignmentClient<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminAssignments.
     * @param {AdminAssignmentDeleteManyArgs} args - Arguments to filter AdminAssignments to delete.
     * @example
     * // Delete a few AdminAssignments
     * const { count } = await prisma.adminAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAssignmentDeleteManyArgs>(args?: SelectSubset<T, AdminAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAssignments
     * const adminAssignment = await prisma.adminAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAssignmentUpdateManyArgs>(args: SelectSubset<T, AdminAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminAssignment.
     * @param {AdminAssignmentUpsertArgs} args - Arguments to update or create a AdminAssignment.
     * @example
     * // Update or create a AdminAssignment
     * const adminAssignment = await prisma.adminAssignment.upsert({
     *   create: {
     *     // ... data to create a AdminAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAssignment we want to update
     *   }
     * })
     */
    upsert<T extends AdminAssignmentUpsertArgs>(args: SelectSubset<T, AdminAssignmentUpsertArgs<ExtArgs>>): Prisma__AdminAssignmentClient<$Result.GetResult<Prisma.$AdminAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAssignmentCountArgs} args - Arguments to filter AdminAssignments to count.
     * @example
     * // Count the number of AdminAssignments
     * const count = await prisma.adminAssignment.count({
     *   where: {
     *     // ... the filter for the AdminAssignments we want to count
     *   }
     * })
    **/
    count<T extends AdminAssignmentCountArgs>(
      args?: Subset<T, AdminAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAssignmentAggregateArgs>(args: Subset<T, AdminAssignmentAggregateArgs>): Prisma.PrismaPromise<GetAdminAssignmentAggregateType<T>>

    /**
     * Group by AdminAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AdminAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAssignment model
   */
  readonly fields: AdminAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends AdminRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminRoleDefaultArgs<ExtArgs>>): Prisma__AdminRoleClient<$Result.GetResult<Prisma.$AdminRolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAssignment model
   */ 
  interface AdminAssignmentFieldRefs {
    readonly id: FieldRef<"AdminAssignment", 'String'>
    readonly adminId: FieldRef<"AdminAssignment", 'String'>
    readonly roleId: FieldRef<"AdminAssignment", 'String'>
    readonly startDate: FieldRef<"AdminAssignment", 'DateTime'>
    readonly endDate: FieldRef<"AdminAssignment", 'DateTime'>
    readonly status: FieldRef<"AdminAssignment", 'String'>
    readonly createdAt: FieldRef<"AdminAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAssignment findUnique
   */
  export type AdminAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AdminAssignment to fetch.
     */
    where: AdminAssignmentWhereUniqueInput
  }

  /**
   * AdminAssignment findUniqueOrThrow
   */
  export type AdminAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AdminAssignment to fetch.
     */
    where: AdminAssignmentWhereUniqueInput
  }

  /**
   * AdminAssignment findFirst
   */
  export type AdminAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AdminAssignment to fetch.
     */
    where?: AdminAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAssignments to fetch.
     */
    orderBy?: AdminAssignmentOrderByWithRelationInput | AdminAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAssignments.
     */
    cursor?: AdminAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAssignments.
     */
    distinct?: AdminAssignmentScalarFieldEnum | AdminAssignmentScalarFieldEnum[]
  }

  /**
   * AdminAssignment findFirstOrThrow
   */
  export type AdminAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AdminAssignment to fetch.
     */
    where?: AdminAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAssignments to fetch.
     */
    orderBy?: AdminAssignmentOrderByWithRelationInput | AdminAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAssignments.
     */
    cursor?: AdminAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAssignments.
     */
    distinct?: AdminAssignmentScalarFieldEnum | AdminAssignmentScalarFieldEnum[]
  }

  /**
   * AdminAssignment findMany
   */
  export type AdminAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which AdminAssignments to fetch.
     */
    where?: AdminAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAssignments to fetch.
     */
    orderBy?: AdminAssignmentOrderByWithRelationInput | AdminAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAssignments.
     */
    cursor?: AdminAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAssignments.
     */
    skip?: number
    distinct?: AdminAssignmentScalarFieldEnum | AdminAssignmentScalarFieldEnum[]
  }

  /**
   * AdminAssignment create
   */
  export type AdminAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAssignment.
     */
    data: XOR<AdminAssignmentCreateInput, AdminAssignmentUncheckedCreateInput>
  }

  /**
   * AdminAssignment createMany
   */
  export type AdminAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAssignments.
     */
    data: AdminAssignmentCreateManyInput | AdminAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAssignment createManyAndReturn
   */
  export type AdminAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminAssignments.
     */
    data: AdminAssignmentCreateManyInput | AdminAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAssignment update
   */
  export type AdminAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAssignment.
     */
    data: XOR<AdminAssignmentUpdateInput, AdminAssignmentUncheckedUpdateInput>
    /**
     * Choose, which AdminAssignment to update.
     */
    where: AdminAssignmentWhereUniqueInput
  }

  /**
   * AdminAssignment updateMany
   */
  export type AdminAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAssignments.
     */
    data: XOR<AdminAssignmentUpdateManyMutationInput, AdminAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which AdminAssignments to update
     */
    where?: AdminAssignmentWhereInput
  }

  /**
   * AdminAssignment upsert
   */
  export type AdminAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAssignment to update in case it exists.
     */
    where: AdminAssignmentWhereUniqueInput
    /**
     * In case the AdminAssignment found by the `where` argument doesn't exist, create a new AdminAssignment with this data.
     */
    create: XOR<AdminAssignmentCreateInput, AdminAssignmentUncheckedCreateInput>
    /**
     * In case the AdminAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAssignmentUpdateInput, AdminAssignmentUncheckedUpdateInput>
  }

  /**
   * AdminAssignment delete
   */
  export type AdminAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
    /**
     * Filter which AdminAssignment to delete.
     */
    where: AdminAssignmentWhereUniqueInput
  }

  /**
   * AdminAssignment deleteMany
   */
  export type AdminAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAssignments to delete
     */
    where?: AdminAssignmentWhereInput
  }

  /**
   * AdminAssignment without action
   */
  export type AdminAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAssignment
     */
    select?: AdminAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model LegalCase
   */

  export type AggregateLegalCase = {
    _count: LegalCaseCountAggregateOutputType | null
    _min: LegalCaseMinAggregateOutputType | null
    _max: LegalCaseMaxAggregateOutputType | null
  }

  export type LegalCaseMinAggregateOutputType = {
    id: string | null
    caseTitle: string | null
    caseType: $Enums.LegalCaseType | null
    status: $Enums.LegalCaseStatus | null
    description: string | null
    courtDate: Date | null
    assignedLawyerId: string | null
    academyId: string | null
    relatedUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LegalCaseMaxAggregateOutputType = {
    id: string | null
    caseTitle: string | null
    caseType: $Enums.LegalCaseType | null
    status: $Enums.LegalCaseStatus | null
    description: string | null
    courtDate: Date | null
    assignedLawyerId: string | null
    academyId: string | null
    relatedUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LegalCaseCountAggregateOutputType = {
    id: number
    caseTitle: number
    caseType: number
    status: number
    description: number
    courtDate: number
    assignedLawyerId: number
    academyId: number
    relatedUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LegalCaseMinAggregateInputType = {
    id?: true
    caseTitle?: true
    caseType?: true
    status?: true
    description?: true
    courtDate?: true
    assignedLawyerId?: true
    academyId?: true
    relatedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LegalCaseMaxAggregateInputType = {
    id?: true
    caseTitle?: true
    caseType?: true
    status?: true
    description?: true
    courtDate?: true
    assignedLawyerId?: true
    academyId?: true
    relatedUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LegalCaseCountAggregateInputType = {
    id?: true
    caseTitle?: true
    caseType?: true
    status?: true
    description?: true
    courtDate?: true
    assignedLawyerId?: true
    academyId?: true
    relatedUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LegalCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LegalCase to aggregate.
     */
    where?: LegalCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalCases to fetch.
     */
    orderBy?: LegalCaseOrderByWithRelationInput | LegalCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LegalCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LegalCases
    **/
    _count?: true | LegalCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LegalCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LegalCaseMaxAggregateInputType
  }

  export type GetLegalCaseAggregateType<T extends LegalCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateLegalCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegalCase[P]>
      : GetScalarType<T[P], AggregateLegalCase[P]>
  }




  export type LegalCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LegalCaseWhereInput
    orderBy?: LegalCaseOrderByWithAggregationInput | LegalCaseOrderByWithAggregationInput[]
    by: LegalCaseScalarFieldEnum[] | LegalCaseScalarFieldEnum
    having?: LegalCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LegalCaseCountAggregateInputType | true
    _min?: LegalCaseMinAggregateInputType
    _max?: LegalCaseMaxAggregateInputType
  }

  export type LegalCaseGroupByOutputType = {
    id: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status: $Enums.LegalCaseStatus
    description: string
    courtDate: Date | null
    assignedLawyerId: string
    academyId: string
    relatedUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LegalCaseCountAggregateOutputType | null
    _min: LegalCaseMinAggregateOutputType | null
    _max: LegalCaseMaxAggregateOutputType | null
  }

  type GetLegalCaseGroupByPayload<T extends LegalCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LegalCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LegalCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LegalCaseGroupByOutputType[P]>
            : GetScalarType<T[P], LegalCaseGroupByOutputType[P]>
        }
      >
    >


  export type LegalCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseTitle?: boolean
    caseType?: boolean
    status?: boolean
    description?: boolean
    courtDate?: boolean
    assignedLawyerId?: boolean
    academyId?: boolean
    relatedUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedLawyer?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    relatedUser?: boolean | LegalCase$relatedUserArgs<ExtArgs>
    files?: boolean | LegalCase$filesArgs<ExtArgs>
    reports?: boolean | LegalCase$reportsArgs<ExtArgs>
    events?: boolean | LegalCase$eventsArgs<ExtArgs>
    channels?: boolean | LegalCase$channelsArgs<ExtArgs>
    payments?: boolean | LegalCase$paymentsArgs<ExtArgs>
    _count?: boolean | LegalCaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["legalCase"]>

  export type LegalCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseTitle?: boolean
    caseType?: boolean
    status?: boolean
    description?: boolean
    courtDate?: boolean
    assignedLawyerId?: boolean
    academyId?: boolean
    relatedUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedLawyer?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    relatedUser?: boolean | LegalCase$relatedUserArgs<ExtArgs>
  }, ExtArgs["result"]["legalCase"]>

  export type LegalCaseSelectScalar = {
    id?: boolean
    caseTitle?: boolean
    caseType?: boolean
    status?: boolean
    description?: boolean
    courtDate?: boolean
    assignedLawyerId?: boolean
    academyId?: boolean
    relatedUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LegalCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedLawyer?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    relatedUser?: boolean | LegalCase$relatedUserArgs<ExtArgs>
    files?: boolean | LegalCase$filesArgs<ExtArgs>
    reports?: boolean | LegalCase$reportsArgs<ExtArgs>
    events?: boolean | LegalCase$eventsArgs<ExtArgs>
    channels?: boolean | LegalCase$channelsArgs<ExtArgs>
    payments?: boolean | LegalCase$paymentsArgs<ExtArgs>
    _count?: boolean | LegalCaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LegalCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedLawyer?: boolean | AdminDefaultArgs<ExtArgs>
    academy?: boolean | AcademyDefaultArgs<ExtArgs>
    relatedUser?: boolean | LegalCase$relatedUserArgs<ExtArgs>
  }

  export type $LegalCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LegalCase"
    objects: {
      assignedLawyer: Prisma.$AdminPayload<ExtArgs>
      academy: Prisma.$AcademyPayload<ExtArgs>
      relatedUser: Prisma.$UserPayload<ExtArgs> | null
      files: Prisma.$FilePayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      channels: Prisma.$ChannelPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseTitle: string
      caseType: $Enums.LegalCaseType
      status: $Enums.LegalCaseStatus
      description: string
      courtDate: Date | null
      assignedLawyerId: string
      academyId: string
      relatedUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["legalCase"]>
    composites: {}
  }

  type LegalCaseGetPayload<S extends boolean | null | undefined | LegalCaseDefaultArgs> = $Result.GetResult<Prisma.$LegalCasePayload, S>

  type LegalCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LegalCaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LegalCaseCountAggregateInputType | true
    }

  export interface LegalCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LegalCase'], meta: { name: 'LegalCase' } }
    /**
     * Find zero or one LegalCase that matches the filter.
     * @param {LegalCaseFindUniqueArgs} args - Arguments to find a LegalCase
     * @example
     * // Get one LegalCase
     * const legalCase = await prisma.legalCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LegalCaseFindUniqueArgs>(args: SelectSubset<T, LegalCaseFindUniqueArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LegalCase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LegalCaseFindUniqueOrThrowArgs} args - Arguments to find a LegalCase
     * @example
     * // Get one LegalCase
     * const legalCase = await prisma.legalCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LegalCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, LegalCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LegalCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalCaseFindFirstArgs} args - Arguments to find a LegalCase
     * @example
     * // Get one LegalCase
     * const legalCase = await prisma.legalCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LegalCaseFindFirstArgs>(args?: SelectSubset<T, LegalCaseFindFirstArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LegalCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalCaseFindFirstOrThrowArgs} args - Arguments to find a LegalCase
     * @example
     * // Get one LegalCase
     * const legalCase = await prisma.legalCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LegalCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, LegalCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LegalCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LegalCases
     * const legalCases = await prisma.legalCase.findMany()
     * 
     * // Get first 10 LegalCases
     * const legalCases = await prisma.legalCase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const legalCaseWithIdOnly = await prisma.legalCase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LegalCaseFindManyArgs>(args?: SelectSubset<T, LegalCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LegalCase.
     * @param {LegalCaseCreateArgs} args - Arguments to create a LegalCase.
     * @example
     * // Create one LegalCase
     * const LegalCase = await prisma.legalCase.create({
     *   data: {
     *     // ... data to create a LegalCase
     *   }
     * })
     * 
     */
    create<T extends LegalCaseCreateArgs>(args: SelectSubset<T, LegalCaseCreateArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LegalCases.
     * @param {LegalCaseCreateManyArgs} args - Arguments to create many LegalCases.
     * @example
     * // Create many LegalCases
     * const legalCase = await prisma.legalCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LegalCaseCreateManyArgs>(args?: SelectSubset<T, LegalCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LegalCases and returns the data saved in the database.
     * @param {LegalCaseCreateManyAndReturnArgs} args - Arguments to create many LegalCases.
     * @example
     * // Create many LegalCases
     * const legalCase = await prisma.legalCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LegalCases and only return the `id`
     * const legalCaseWithIdOnly = await prisma.legalCase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LegalCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, LegalCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LegalCase.
     * @param {LegalCaseDeleteArgs} args - Arguments to delete one LegalCase.
     * @example
     * // Delete one LegalCase
     * const LegalCase = await prisma.legalCase.delete({
     *   where: {
     *     // ... filter to delete one LegalCase
     *   }
     * })
     * 
     */
    delete<T extends LegalCaseDeleteArgs>(args: SelectSubset<T, LegalCaseDeleteArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LegalCase.
     * @param {LegalCaseUpdateArgs} args - Arguments to update one LegalCase.
     * @example
     * // Update one LegalCase
     * const legalCase = await prisma.legalCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LegalCaseUpdateArgs>(args: SelectSubset<T, LegalCaseUpdateArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LegalCases.
     * @param {LegalCaseDeleteManyArgs} args - Arguments to filter LegalCases to delete.
     * @example
     * // Delete a few LegalCases
     * const { count } = await prisma.legalCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LegalCaseDeleteManyArgs>(args?: SelectSubset<T, LegalCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LegalCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LegalCases
     * const legalCase = await prisma.legalCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LegalCaseUpdateManyArgs>(args: SelectSubset<T, LegalCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LegalCase.
     * @param {LegalCaseUpsertArgs} args - Arguments to update or create a LegalCase.
     * @example
     * // Update or create a LegalCase
     * const legalCase = await prisma.legalCase.upsert({
     *   create: {
     *     // ... data to create a LegalCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LegalCase we want to update
     *   }
     * })
     */
    upsert<T extends LegalCaseUpsertArgs>(args: SelectSubset<T, LegalCaseUpsertArgs<ExtArgs>>): Prisma__LegalCaseClient<$Result.GetResult<Prisma.$LegalCasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LegalCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalCaseCountArgs} args - Arguments to filter LegalCases to count.
     * @example
     * // Count the number of LegalCases
     * const count = await prisma.legalCase.count({
     *   where: {
     *     // ... the filter for the LegalCases we want to count
     *   }
     * })
    **/
    count<T extends LegalCaseCountArgs>(
      args?: Subset<T, LegalCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LegalCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LegalCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LegalCaseAggregateArgs>(args: Subset<T, LegalCaseAggregateArgs>): Prisma.PrismaPromise<GetLegalCaseAggregateType<T>>

    /**
     * Group by LegalCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegalCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LegalCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LegalCaseGroupByArgs['orderBy'] }
        : { orderBy?: LegalCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LegalCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegalCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LegalCase model
   */
  readonly fields: LegalCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LegalCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LegalCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedLawyer<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    academy<T extends AcademyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcademyDefaultArgs<ExtArgs>>): Prisma__AcademyClient<$Result.GetResult<Prisma.$AcademyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    relatedUser<T extends LegalCase$relatedUserArgs<ExtArgs> = {}>(args?: Subset<T, LegalCase$relatedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    files<T extends LegalCase$filesArgs<ExtArgs> = {}>(args?: Subset<T, LegalCase$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends LegalCase$reportsArgs<ExtArgs> = {}>(args?: Subset<T, LegalCase$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends LegalCase$eventsArgs<ExtArgs> = {}>(args?: Subset<T, LegalCase$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    channels<T extends LegalCase$channelsArgs<ExtArgs> = {}>(args?: Subset<T, LegalCase$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends LegalCase$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, LegalCase$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LegalCase model
   */ 
  interface LegalCaseFieldRefs {
    readonly id: FieldRef<"LegalCase", 'String'>
    readonly caseTitle: FieldRef<"LegalCase", 'String'>
    readonly caseType: FieldRef<"LegalCase", 'LegalCaseType'>
    readonly status: FieldRef<"LegalCase", 'LegalCaseStatus'>
    readonly description: FieldRef<"LegalCase", 'String'>
    readonly courtDate: FieldRef<"LegalCase", 'DateTime'>
    readonly assignedLawyerId: FieldRef<"LegalCase", 'String'>
    readonly academyId: FieldRef<"LegalCase", 'String'>
    readonly relatedUserId: FieldRef<"LegalCase", 'String'>
    readonly createdAt: FieldRef<"LegalCase", 'DateTime'>
    readonly updatedAt: FieldRef<"LegalCase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LegalCase findUnique
   */
  export type LegalCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    /**
     * Filter, which LegalCase to fetch.
     */
    where: LegalCaseWhereUniqueInput
  }

  /**
   * LegalCase findUniqueOrThrow
   */
  export type LegalCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    /**
     * Filter, which LegalCase to fetch.
     */
    where: LegalCaseWhereUniqueInput
  }

  /**
   * LegalCase findFirst
   */
  export type LegalCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    /**
     * Filter, which LegalCase to fetch.
     */
    where?: LegalCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalCases to fetch.
     */
    orderBy?: LegalCaseOrderByWithRelationInput | LegalCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LegalCases.
     */
    cursor?: LegalCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LegalCases.
     */
    distinct?: LegalCaseScalarFieldEnum | LegalCaseScalarFieldEnum[]
  }

  /**
   * LegalCase findFirstOrThrow
   */
  export type LegalCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    /**
     * Filter, which LegalCase to fetch.
     */
    where?: LegalCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalCases to fetch.
     */
    orderBy?: LegalCaseOrderByWithRelationInput | LegalCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LegalCases.
     */
    cursor?: LegalCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LegalCases.
     */
    distinct?: LegalCaseScalarFieldEnum | LegalCaseScalarFieldEnum[]
  }

  /**
   * LegalCase findMany
   */
  export type LegalCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    /**
     * Filter, which LegalCases to fetch.
     */
    where?: LegalCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LegalCases to fetch.
     */
    orderBy?: LegalCaseOrderByWithRelationInput | LegalCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LegalCases.
     */
    cursor?: LegalCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LegalCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LegalCases.
     */
    skip?: number
    distinct?: LegalCaseScalarFieldEnum | LegalCaseScalarFieldEnum[]
  }

  /**
   * LegalCase create
   */
  export type LegalCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a LegalCase.
     */
    data: XOR<LegalCaseCreateInput, LegalCaseUncheckedCreateInput>
  }

  /**
   * LegalCase createMany
   */
  export type LegalCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LegalCases.
     */
    data: LegalCaseCreateManyInput | LegalCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LegalCase createManyAndReturn
   */
  export type LegalCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LegalCases.
     */
    data: LegalCaseCreateManyInput | LegalCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LegalCase update
   */
  export type LegalCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a LegalCase.
     */
    data: XOR<LegalCaseUpdateInput, LegalCaseUncheckedUpdateInput>
    /**
     * Choose, which LegalCase to update.
     */
    where: LegalCaseWhereUniqueInput
  }

  /**
   * LegalCase updateMany
   */
  export type LegalCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LegalCases.
     */
    data: XOR<LegalCaseUpdateManyMutationInput, LegalCaseUncheckedUpdateManyInput>
    /**
     * Filter which LegalCases to update
     */
    where?: LegalCaseWhereInput
  }

  /**
   * LegalCase upsert
   */
  export type LegalCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the LegalCase to update in case it exists.
     */
    where: LegalCaseWhereUniqueInput
    /**
     * In case the LegalCase found by the `where` argument doesn't exist, create a new LegalCase with this data.
     */
    create: XOR<LegalCaseCreateInput, LegalCaseUncheckedCreateInput>
    /**
     * In case the LegalCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LegalCaseUpdateInput, LegalCaseUncheckedUpdateInput>
  }

  /**
   * LegalCase delete
   */
  export type LegalCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
    /**
     * Filter which LegalCase to delete.
     */
    where: LegalCaseWhereUniqueInput
  }

  /**
   * LegalCase deleteMany
   */
  export type LegalCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LegalCases to delete
     */
    where?: LegalCaseWhereInput
  }

  /**
   * LegalCase.relatedUser
   */
  export type LegalCase$relatedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LegalCase.files
   */
  export type LegalCase$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * LegalCase.reports
   */
  export type LegalCase$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * LegalCase.events
   */
  export type LegalCase$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * LegalCase.channels
   */
  export type LegalCase$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Channel
     */
    select?: ChannelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelInclude<ExtArgs> | null
    where?: ChannelWhereInput
    orderBy?: ChannelOrderByWithRelationInput | ChannelOrderByWithRelationInput[]
    cursor?: ChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelScalarFieldEnum | ChannelScalarFieldEnum[]
  }

  /**
   * LegalCase.payments
   */
  export type LegalCase$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * LegalCase without action
   */
  export type LegalCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegalCase
     */
    select?: LegalCaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LegalCaseInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    phone: 'phone',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    subRole: 'subRole',
    avatar: 'avatar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    academyId: 'academyId',
    isOnline: 'isOnline',
    isVerified: 'isVerified',
    age: 'age'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LoginHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    success: 'success',
    ip: 'ip',
    device: 'device',
    location: 'location',
    browser: 'browser',
    os: 'os',
    createdAt: 'createdAt'
  };

  export type LoginHistoryScalarFieldEnum = (typeof LoginHistoryScalarFieldEnum)[keyof typeof LoginHistoryScalarFieldEnum]


  export const TwoFactorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    sms: 'sms',
    authenticator: 'authenticator',
    secret: 'secret',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TwoFactorScalarFieldEnum = (typeof TwoFactorScalarFieldEnum)[keyof typeof TwoFactorScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bio: 'bio',
    phone: 'phone',
    address: 'address',
    preferences: 'preferences'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const UserAcademyCEOScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    academyId: 'academyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAcademyCEOScalarFieldEnum = (typeof UserAcademyCEOScalarFieldEnum)[keyof typeof UserAcademyCEOScalarFieldEnum]


  export const AcademyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    logo: 'logo',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademyScalarFieldEnum = (typeof AcademyScalarFieldEnum)[keyof typeof AcademyScalarFieldEnum]


  export const InstructorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    academyId: 'academyId'
  };

  export type InstructorScalarFieldEnum = (typeof InstructorScalarFieldEnum)[keyof typeof InstructorScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    academyId: 'academyId',
    image: 'image',
    level: 'level',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const PathScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    level: 'level',
    completedTasks: 'completedTasks',
    remainingTime: 'remainingTime',
    studyTime: 'studyTime',
    totalTasks: 'totalTasks',
    progress: 'progress',
    engagement: 'engagement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PathScalarFieldEnum = (typeof PathScalarFieldEnum)[keyof typeof PathScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    pathId: 'pathId',
    createdAt: 'createdAt'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    courseId: 'courseId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    type: 'type',
    lessonId: 'lessonId',
    accountingEntryId: 'accountingEntryId',
    prRecordId: 'prRecordId',
    meetingId: 'meetingId',
    adminRoleId: 'adminRoleId',
    legalCaseId: 'legalCaseId',
    createdAt: 'createdAt'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    progress: 'progress',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    lessonId: 'lessonId',
    timeLimit: 'timeLimit',
    passingScore: 'passingScore',
    upComing: 'upComing',
    isCompleted: 'isCompleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    text: 'text',
    type: 'type',
    isMultiple: 'isMultiple',
    points: 'points',
    isAnswered: 'isAnswered',
    quizId: 'quizId',
    createdAt: 'createdAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const OptionScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    text: 'text',
    isCorrect: 'isCorrect',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OptionScalarFieldEnum = (typeof OptionScalarFieldEnum)[keyof typeof OptionScalarFieldEnum]


  export const SubmissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    quizId: 'quizId',
    answers: 'answers',
    score: 'score',
    feedback: 'feedback',
    passed: 'passed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubmissionScalarFieldEnum = (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    value: 'value',
    isNew: 'isNew',
    createdAt: 'createdAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    message: 'message',
    isImportant: 'isImportant',
    urgent: 'urgent',
    title: 'title',
    actionUrl: 'actionUrl',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    assignments: 'assignments',
    grades: 'grades',
    messages: 'messages',
    achievements: 'achievements',
    urgent: 'urgent',
    email: 'email',
    push: 'push',
    createdAt: 'createdAt'
  };

  export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    content: 'content',
    createdAt: 'createdAt',
    isRead: 'isRead'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    content: 'content',
    title: 'title',
    createdAt: 'createdAt',
    likesCount: 'likesCount',
    publicRelationsRecordId: 'publicRelationsRecordId'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    image: 'image',
    adminId: 'adminId',
    createdAt: 'createdAt'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ChannelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ownerId: 'ownerId',
    prRecordId: 'prRecordId',
    meetingId: 'meetingId',
    adminRoleId: 'adminRoleId',
    legalCaseId: 'legalCaseId',
    createdAt: 'createdAt'
  };

  export type ChannelScalarFieldEnum = (typeof ChannelScalarFieldEnum)[keyof typeof ChannelScalarFieldEnum]


  export const OwnerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type OwnerScalarFieldEnum = (typeof OwnerScalarFieldEnum)[keyof typeof OwnerScalarFieldEnum]


  export const BookmarkScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    itemId: 'itemId',
    createdAt: 'createdAt'
  };

  export type BookmarkScalarFieldEnum = (typeof BookmarkScalarFieldEnum)[keyof typeof BookmarkScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    academyId: 'academyId',
    prRecordId: 'prRecordId',
    adminRoleId: 'adminRoleId',
    legalCaseId: 'legalCaseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    lessonId: 'lessonId',
    status: 'status',
    method: 'method',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    legalCaseId: 'legalCaseId',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountingEntryId: 'accountingEntryId',
    meetingId: 'meetingId',
    adminRoleId: 'adminRoleId',
    legalCaseId: 'legalCaseId',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    description: 'description',
    image: 'image',
    points: 'points',
    type: 'type',
    earnedAt: 'earnedAt',
    createdAt: 'createdAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    notes: 'notes',
    userId: 'userId',
    title: 'title',
    description: 'description',
    url: 'url',
    image: 'image',
    points: 'points',
    type: 'type',
    earnedAt: 'earnedAt',
    createdAt: 'createdAt'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const CommunityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    image: 'image',
    description: 'description',
    type: 'type',
    likes: 'likes',
    dislikes: 'dislikes',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityScalarFieldEnum = (typeof CommunityScalarFieldEnum)[keyof typeof CommunityScalarFieldEnum]


  export const DiscussionScalarFieldEnum: {
    id: 'id',
    communityId: 'communityId',
    postId: 'postId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiscussionScalarFieldEnum = (typeof DiscussionScalarFieldEnum)[keyof typeof DiscussionScalarFieldEnum]


  export const LiveRoomScalarFieldEnum: {
    id: 'id',
    title: 'title',
    topic: 'topic',
    participants: 'participants',
    isLive: 'isLive',
    isActive: 'isActive',
    isPublic: 'isPublic',
    isPrivate: 'isPrivate',
    isPasswordProtected: 'isPasswordProtected',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    communityId: 'communityId',
    courseId: 'courseId'
  };

  export type LiveRoomScalarFieldEnum = (typeof LiveRoomScalarFieldEnum)[keyof typeof LiveRoomScalarFieldEnum]


  export const AccountingEntryScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    description: 'description',
    date: 'date',
    createdByAdminId: 'createdByAdminId',
    academyId: 'academyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountingEntryScalarFieldEnum = (typeof AccountingEntryScalarFieldEnum)[keyof typeof AccountingEntryScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    amount: 'amount',
    description: 'description',
    dueDate: 'dueDate',
    status: 'status',
    accountingEntryId: 'accountingEntryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const SalaryPaymentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    amount: 'amount',
    month: 'month',
    year: 'year',
    accountingEntryId: 'accountingEntryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalaryPaymentScalarFieldEnum = (typeof SalaryPaymentScalarFieldEnum)[keyof typeof SalaryPaymentScalarFieldEnum]


  export const PublicRelationsRecordScalarFieldEnum: {
    id: 'id',
    message: 'message',
    senderName: 'senderName',
    senderContact: 'senderContact',
    status: 'status',
    handledByAdminId: 'handledByAdminId',
    academyId: 'academyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PublicRelationsRecordScalarFieldEnum = (typeof PublicRelationsRecordScalarFieldEnum)[keyof typeof PublicRelationsRecordScalarFieldEnum]


  export const PRResponseScalarFieldEnum: {
    id: 'id',
    response: 'response',
    prRecordId: 'prRecordId',
    respondedByAdminId: 'respondedByAdminId',
    createdAt: 'createdAt'
  };

  export type PRResponseScalarFieldEnum = (typeof PRResponseScalarFieldEnum)[keyof typeof PRResponseScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    id: 'id',
    meetingTitle: 'meetingTitle',
    meetingDate: 'meetingDate',
    location: 'location',
    notes: 'notes',
    createdByAdminId: 'createdByAdminId',
    academyId: 'academyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const MeetingParticipantScalarFieldEnum: {
    id: 'id',
    meetingId: 'meetingId',
    userId: 'userId',
    isAttended: 'isAttended',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeetingParticipantScalarFieldEnum = (typeof MeetingParticipantScalarFieldEnum)[keyof typeof MeetingParticipantScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const AdminRoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    adminId: 'adminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminRoleScalarFieldEnum = (typeof AdminRoleScalarFieldEnum)[keyof typeof AdminRoleScalarFieldEnum]


  export const AdminAssignmentScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    roleId: 'roleId',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminAssignmentScalarFieldEnum = (typeof AdminAssignmentScalarFieldEnum)[keyof typeof AdminAssignmentScalarFieldEnum]


  export const LegalCaseScalarFieldEnum: {
    id: 'id',
    caseTitle: 'caseTitle',
    caseType: 'caseType',
    status: 'status',
    description: 'description',
    courtDate: 'courtDate',
    assignedLawyerId: 'assignedLawyerId',
    academyId: 'academyId',
    relatedUserId: 'relatedUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LegalCaseScalarFieldEnum = (typeof LegalCaseScalarFieldEnum)[keyof typeof LegalCaseScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'LoginDevice'
   */
  export type EnumLoginDeviceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoginDevice'>
    


  /**
   * Reference to a field of type 'LoginDevice[]'
   */
  export type ListEnumLoginDeviceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoginDevice[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'CourseStatus'
   */
  export type EnumCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatus'>
    


  /**
   * Reference to a field of type 'CourseStatus[]'
   */
  export type ListEnumCourseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MilestoneStatus'
   */
  export type EnumMilestoneStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MilestoneStatus'>
    


  /**
   * Reference to a field of type 'MilestoneStatus[]'
   */
  export type ListEnumMilestoneStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MilestoneStatus[]'>
    


  /**
   * Reference to a field of type 'LessonStatus'
   */
  export type EnumLessonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonStatus'>
    


  /**
   * Reference to a field of type 'LessonStatus[]'
   */
  export type ListEnumLessonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonStatus[]'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'AccountingType'
   */
  export type EnumAccountingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountingType'>
    


  /**
   * Reference to a field of type 'AccountingType[]'
   */
  export type ListEnumAccountingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountingType[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'PRRequestStatus'
   */
  export type EnumPRRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PRRequestStatus'>
    


  /**
   * Reference to a field of type 'PRRequestStatus[]'
   */
  export type ListEnumPRRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PRRequestStatus[]'>
    


  /**
   * Reference to a field of type 'AdminRoleType'
   */
  export type EnumAdminRoleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRoleType'>
    


  /**
   * Reference to a field of type 'AdminRoleType[]'
   */
  export type ListEnumAdminRoleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRoleType[]'>
    


  /**
   * Reference to a field of type 'LegalCaseType'
   */
  export type EnumLegalCaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LegalCaseType'>
    


  /**
   * Reference to a field of type 'LegalCaseType[]'
   */
  export type ListEnumLegalCaseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LegalCaseType[]'>
    


  /**
   * Reference to a field of type 'LegalCaseStatus'
   */
  export type EnumLegalCaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LegalCaseStatus'>
    


  /**
   * Reference to a field of type 'LegalCaseStatus[]'
   */
  export type ListEnumLegalCaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LegalCaseStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    subRole?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    academyId?: StringNullableFilter<"User"> | string | null
    isOnline?: BoolFilter<"User"> | boolean
    isVerified?: BoolFilter<"User"> | boolean
    age?: IntNullableFilter<"User"> | number | null
    academy?: XOR<AcademyNullableScalarRelationFilter, AcademyWhereInput> | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    enrollments?: EnrollmentListRelationFilter
    achievements?: AchievementListRelationFilter
    notifications?: NotificationListRelationFilter
    messages?: MessageListRelationFilter
    posts?: PostListRelationFilter
    groups?: GroupListRelationFilter
    channels?: ChannelListRelationFilter
    bookmarks?: BookmarkListRelationFilter
    Submission?: SubmissionListRelationFilter
    Attendance?: AttendanceListRelationFilter
    Instructor?: InstructorListRelationFilter
    Owner?: OwnerListRelationFilter
    Admin?: AdminListRelationFilter
    Lesson?: LessonListRelationFilter
    Payment?: PaymentListRelationFilter
    Report?: ReportListRelationFilter
    Badge?: BadgeListRelationFilter
    Certificate?: CertificateListRelationFilter
    Community?: CommunityListRelationFilter
    LiveRoom?: LiveRoomListRelationFilter
    NotificationSettings?: NotificationSettingsListRelationFilter
    Path?: PathListRelationFilter
    LoginHistory?: LoginHistoryListRelationFilter
    TwoFactor?: TwoFactorListRelationFilter
    UserAcademyCEO?: UserAcademyCEOListRelationFilter
    SalaryPayment?: SalaryPaymentListRelationFilter
    MeetingParticipant?: MeetingParticipantListRelationFilter
    LegalCase?: LegalCaseListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    subRole?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academyId?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    isVerified?: SortOrder
    age?: SortOrderInput | SortOrder
    academy?: AcademyOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    achievements?: AchievementOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    groups?: GroupOrderByRelationAggregateInput
    channels?: ChannelOrderByRelationAggregateInput
    bookmarks?: BookmarkOrderByRelationAggregateInput
    Submission?: SubmissionOrderByRelationAggregateInput
    Attendance?: AttendanceOrderByRelationAggregateInput
    Instructor?: InstructorOrderByRelationAggregateInput
    Owner?: OwnerOrderByRelationAggregateInput
    Admin?: AdminOrderByRelationAggregateInput
    Lesson?: LessonOrderByRelationAggregateInput
    Payment?: PaymentOrderByRelationAggregateInput
    Report?: ReportOrderByRelationAggregateInput
    Badge?: BadgeOrderByRelationAggregateInput
    Certificate?: CertificateOrderByRelationAggregateInput
    Community?: CommunityOrderByRelationAggregateInput
    LiveRoom?: LiveRoomOrderByRelationAggregateInput
    NotificationSettings?: NotificationSettingsOrderByRelationAggregateInput
    Path?: PathOrderByRelationAggregateInput
    LoginHistory?: LoginHistoryOrderByRelationAggregateInput
    TwoFactor?: TwoFactorOrderByRelationAggregateInput
    UserAcademyCEO?: UserAcademyCEOOrderByRelationAggregateInput
    SalaryPayment?: SalaryPaymentOrderByRelationAggregateInput
    MeetingParticipant?: MeetingParticipantOrderByRelationAggregateInput
    LegalCase?: LegalCaseOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    subRole?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    academyId?: StringNullableFilter<"User"> | string | null
    isOnline?: BoolFilter<"User"> | boolean
    isVerified?: BoolFilter<"User"> | boolean
    age?: IntNullableFilter<"User"> | number | null
    academy?: XOR<AcademyNullableScalarRelationFilter, AcademyWhereInput> | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    enrollments?: EnrollmentListRelationFilter
    achievements?: AchievementListRelationFilter
    notifications?: NotificationListRelationFilter
    messages?: MessageListRelationFilter
    posts?: PostListRelationFilter
    groups?: GroupListRelationFilter
    channels?: ChannelListRelationFilter
    bookmarks?: BookmarkListRelationFilter
    Submission?: SubmissionListRelationFilter
    Attendance?: AttendanceListRelationFilter
    Instructor?: InstructorListRelationFilter
    Owner?: OwnerListRelationFilter
    Admin?: AdminListRelationFilter
    Lesson?: LessonListRelationFilter
    Payment?: PaymentListRelationFilter
    Report?: ReportListRelationFilter
    Badge?: BadgeListRelationFilter
    Certificate?: CertificateListRelationFilter
    Community?: CommunityListRelationFilter
    LiveRoom?: LiveRoomListRelationFilter
    NotificationSettings?: NotificationSettingsListRelationFilter
    Path?: PathListRelationFilter
    LoginHistory?: LoginHistoryListRelationFilter
    TwoFactor?: TwoFactorListRelationFilter
    UserAcademyCEO?: UserAcademyCEOListRelationFilter
    SalaryPayment?: SalaryPaymentListRelationFilter
    MeetingParticipant?: MeetingParticipantListRelationFilter
    LegalCase?: LegalCaseListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    subRole?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academyId?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    isVerified?: SortOrder
    age?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    subRole?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    academyId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isOnline?: BoolWithAggregatesFilter<"User"> | boolean
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    age?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type LoginHistoryWhereInput = {
    AND?: LoginHistoryWhereInput | LoginHistoryWhereInput[]
    OR?: LoginHistoryWhereInput[]
    NOT?: LoginHistoryWhereInput | LoginHistoryWhereInput[]
    id?: StringFilter<"LoginHistory"> | string
    userId?: StringFilter<"LoginHistory"> | string
    success?: BoolFilter<"LoginHistory"> | boolean
    ip?: StringNullableFilter<"LoginHistory"> | string | null
    device?: EnumLoginDeviceNullableFilter<"LoginHistory"> | $Enums.LoginDevice | null
    location?: StringNullableFilter<"LoginHistory"> | string | null
    browser?: StringNullableFilter<"LoginHistory"> | string | null
    os?: StringNullableFilter<"LoginHistory"> | string | null
    createdAt?: DateTimeFilter<"LoginHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type LoginHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    success?: SortOrder
    ip?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LoginHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoginHistoryWhereInput | LoginHistoryWhereInput[]
    OR?: LoginHistoryWhereInput[]
    NOT?: LoginHistoryWhereInput | LoginHistoryWhereInput[]
    userId?: StringFilter<"LoginHistory"> | string
    success?: BoolFilter<"LoginHistory"> | boolean
    ip?: StringNullableFilter<"LoginHistory"> | string | null
    device?: EnumLoginDeviceNullableFilter<"LoginHistory"> | $Enums.LoginDevice | null
    location?: StringNullableFilter<"LoginHistory"> | string | null
    browser?: StringNullableFilter<"LoginHistory"> | string | null
    os?: StringNullableFilter<"LoginHistory"> | string | null
    createdAt?: DateTimeFilter<"LoginHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type LoginHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    success?: SortOrder
    ip?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LoginHistoryCountOrderByAggregateInput
    _max?: LoginHistoryMaxOrderByAggregateInput
    _min?: LoginHistoryMinOrderByAggregateInput
  }

  export type LoginHistoryScalarWhereWithAggregatesInput = {
    AND?: LoginHistoryScalarWhereWithAggregatesInput | LoginHistoryScalarWhereWithAggregatesInput[]
    OR?: LoginHistoryScalarWhereWithAggregatesInput[]
    NOT?: LoginHistoryScalarWhereWithAggregatesInput | LoginHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoginHistory"> | string
    userId?: StringWithAggregatesFilter<"LoginHistory"> | string
    success?: BoolWithAggregatesFilter<"LoginHistory"> | boolean
    ip?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    device?: EnumLoginDeviceNullableWithAggregatesFilter<"LoginHistory"> | $Enums.LoginDevice | null
    location?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    browser?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    os?: StringNullableWithAggregatesFilter<"LoginHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoginHistory"> | Date | string
  }

  export type TwoFactorWhereInput = {
    AND?: TwoFactorWhereInput | TwoFactorWhereInput[]
    OR?: TwoFactorWhereInput[]
    NOT?: TwoFactorWhereInput | TwoFactorWhereInput[]
    id?: StringFilter<"TwoFactor"> | string
    userId?: StringFilter<"TwoFactor"> | string
    email?: BoolFilter<"TwoFactor"> | boolean
    sms?: BoolFilter<"TwoFactor"> | boolean
    authenticator?: BoolFilter<"TwoFactor"> | boolean
    secret?: StringNullableFilter<"TwoFactor"> | string | null
    createdAt?: DateTimeFilter<"TwoFactor"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TwoFactorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    sms?: SortOrder
    authenticator?: SortOrder
    secret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TwoFactorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TwoFactorWhereInput | TwoFactorWhereInput[]
    OR?: TwoFactorWhereInput[]
    NOT?: TwoFactorWhereInput | TwoFactorWhereInput[]
    userId?: StringFilter<"TwoFactor"> | string
    email?: BoolFilter<"TwoFactor"> | boolean
    sms?: BoolFilter<"TwoFactor"> | boolean
    authenticator?: BoolFilter<"TwoFactor"> | boolean
    secret?: StringNullableFilter<"TwoFactor"> | string | null
    createdAt?: DateTimeFilter<"TwoFactor"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactor"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TwoFactorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    sms?: SortOrder
    authenticator?: SortOrder
    secret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TwoFactorCountOrderByAggregateInput
    _max?: TwoFactorMaxOrderByAggregateInput
    _min?: TwoFactorMinOrderByAggregateInput
  }

  export type TwoFactorScalarWhereWithAggregatesInput = {
    AND?: TwoFactorScalarWhereWithAggregatesInput | TwoFactorScalarWhereWithAggregatesInput[]
    OR?: TwoFactorScalarWhereWithAggregatesInput[]
    NOT?: TwoFactorScalarWhereWithAggregatesInput | TwoFactorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwoFactor"> | string
    userId?: StringWithAggregatesFilter<"TwoFactor"> | string
    email?: BoolWithAggregatesFilter<"TwoFactor"> | boolean
    sms?: BoolWithAggregatesFilter<"TwoFactor"> | boolean
    authenticator?: BoolWithAggregatesFilter<"TwoFactor"> | boolean
    secret?: StringNullableWithAggregatesFilter<"TwoFactor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TwoFactor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TwoFactor"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    bio?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    address?: StringNullableFilter<"Profile"> | string | null
    preferences?: JsonNullableFilter<"Profile">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    bio?: StringNullableFilter<"Profile"> | string | null
    phone?: StringNullableFilter<"Profile"> | string | null
    address?: StringNullableFilter<"Profile"> | string | null
    preferences?: JsonNullableFilter<"Profile">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    address?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    preferences?: JsonNullableWithAggregatesFilter<"Profile">
  }

  export type UserAcademyCEOWhereInput = {
    AND?: UserAcademyCEOWhereInput | UserAcademyCEOWhereInput[]
    OR?: UserAcademyCEOWhereInput[]
    NOT?: UserAcademyCEOWhereInput | UserAcademyCEOWhereInput[]
    id?: StringFilter<"UserAcademyCEO"> | string
    userId?: StringFilter<"UserAcademyCEO"> | string
    academyId?: StringFilter<"UserAcademyCEO"> | string
    createdAt?: DateTimeFilter<"UserAcademyCEO"> | Date | string
    updatedAt?: DateTimeFilter<"UserAcademyCEO"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
  }

  export type UserAcademyCEOOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    academy?: AcademyOrderByWithRelationInput
  }

  export type UserAcademyCEOWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserAcademyCEOWhereInput | UserAcademyCEOWhereInput[]
    OR?: UserAcademyCEOWhereInput[]
    NOT?: UserAcademyCEOWhereInput | UserAcademyCEOWhereInput[]
    userId?: StringFilter<"UserAcademyCEO"> | string
    academyId?: StringFilter<"UserAcademyCEO"> | string
    createdAt?: DateTimeFilter<"UserAcademyCEO"> | Date | string
    updatedAt?: DateTimeFilter<"UserAcademyCEO"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
  }, "id">

  export type UserAcademyCEOOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAcademyCEOCountOrderByAggregateInput
    _max?: UserAcademyCEOMaxOrderByAggregateInput
    _min?: UserAcademyCEOMinOrderByAggregateInput
  }

  export type UserAcademyCEOScalarWhereWithAggregatesInput = {
    AND?: UserAcademyCEOScalarWhereWithAggregatesInput | UserAcademyCEOScalarWhereWithAggregatesInput[]
    OR?: UserAcademyCEOScalarWhereWithAggregatesInput[]
    NOT?: UserAcademyCEOScalarWhereWithAggregatesInput | UserAcademyCEOScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAcademyCEO"> | string
    userId?: StringWithAggregatesFilter<"UserAcademyCEO"> | string
    academyId?: StringWithAggregatesFilter<"UserAcademyCEO"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserAcademyCEO"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAcademyCEO"> | Date | string
  }

  export type AcademyWhereInput = {
    AND?: AcademyWhereInput | AcademyWhereInput[]
    OR?: AcademyWhereInput[]
    NOT?: AcademyWhereInput | AcademyWhereInput[]
    id?: StringFilter<"Academy"> | string
    name?: StringFilter<"Academy"> | string
    description?: StringNullableFilter<"Academy"> | string | null
    logo?: StringNullableFilter<"Academy"> | string | null
    settings?: JsonNullableFilter<"Academy">
    createdAt?: DateTimeFilter<"Academy"> | Date | string
    updatedAt?: DateTimeFilter<"Academy"> | Date | string
    users?: UserListRelationFilter
    ceos?: UserAcademyCEOListRelationFilter
    courses?: CourseListRelationFilter
    instructors?: InstructorListRelationFilter
    events?: EventListRelationFilter
    AccountingEntry?: AccountingEntryListRelationFilter
    PublicRelationsRecord?: PublicRelationsRecordListRelationFilter
    Meeting?: MeetingListRelationFilter
    LegalCase?: LegalCaseListRelationFilter
  }

  export type AcademyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    ceos?: UserAcademyCEOOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    instructors?: InstructorOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    AccountingEntry?: AccountingEntryOrderByRelationAggregateInput
    PublicRelationsRecord?: PublicRelationsRecordOrderByRelationAggregateInput
    Meeting?: MeetingOrderByRelationAggregateInput
    LegalCase?: LegalCaseOrderByRelationAggregateInput
  }

  export type AcademyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademyWhereInput | AcademyWhereInput[]
    OR?: AcademyWhereInput[]
    NOT?: AcademyWhereInput | AcademyWhereInput[]
    name?: StringFilter<"Academy"> | string
    description?: StringNullableFilter<"Academy"> | string | null
    logo?: StringNullableFilter<"Academy"> | string | null
    settings?: JsonNullableFilter<"Academy">
    createdAt?: DateTimeFilter<"Academy"> | Date | string
    updatedAt?: DateTimeFilter<"Academy"> | Date | string
    users?: UserListRelationFilter
    ceos?: UserAcademyCEOListRelationFilter
    courses?: CourseListRelationFilter
    instructors?: InstructorListRelationFilter
    events?: EventListRelationFilter
    AccountingEntry?: AccountingEntryListRelationFilter
    PublicRelationsRecord?: PublicRelationsRecordListRelationFilter
    Meeting?: MeetingListRelationFilter
    LegalCase?: LegalCaseListRelationFilter
  }, "id">

  export type AcademyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademyCountOrderByAggregateInput
    _max?: AcademyMaxOrderByAggregateInput
    _min?: AcademyMinOrderByAggregateInput
  }

  export type AcademyScalarWhereWithAggregatesInput = {
    AND?: AcademyScalarWhereWithAggregatesInput | AcademyScalarWhereWithAggregatesInput[]
    OR?: AcademyScalarWhereWithAggregatesInput[]
    NOT?: AcademyScalarWhereWithAggregatesInput | AcademyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Academy"> | string
    name?: StringWithAggregatesFilter<"Academy"> | string
    description?: StringNullableWithAggregatesFilter<"Academy"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Academy"> | string | null
    settings?: JsonNullableWithAggregatesFilter<"Academy">
    createdAt?: DateTimeWithAggregatesFilter<"Academy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Academy"> | Date | string
  }

  export type InstructorWhereInput = {
    AND?: InstructorWhereInput | InstructorWhereInput[]
    OR?: InstructorWhereInput[]
    NOT?: InstructorWhereInput | InstructorWhereInput[]
    id?: StringFilter<"Instructor"> | string
    userId?: StringFilter<"Instructor"> | string
    academyId?: StringFilter<"Instructor"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    courses?: CourseListRelationFilter
  }

  export type InstructorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    academyId?: SortOrder
    user?: UserOrderByWithRelationInput
    academy?: AcademyOrderByWithRelationInput
    courses?: CourseOrderByRelationAggregateInput
  }

  export type InstructorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstructorWhereInput | InstructorWhereInput[]
    OR?: InstructorWhereInput[]
    NOT?: InstructorWhereInput | InstructorWhereInput[]
    userId?: StringFilter<"Instructor"> | string
    academyId?: StringFilter<"Instructor"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    courses?: CourseListRelationFilter
  }, "id">

  export type InstructorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    academyId?: SortOrder
    _count?: InstructorCountOrderByAggregateInput
    _max?: InstructorMaxOrderByAggregateInput
    _min?: InstructorMinOrderByAggregateInput
  }

  export type InstructorScalarWhereWithAggregatesInput = {
    AND?: InstructorScalarWhereWithAggregatesInput | InstructorScalarWhereWithAggregatesInput[]
    OR?: InstructorScalarWhereWithAggregatesInput[]
    NOT?: InstructorScalarWhereWithAggregatesInput | InstructorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Instructor"> | string
    userId?: StringWithAggregatesFilter<"Instructor"> | string
    academyId?: StringWithAggregatesFilter<"Instructor"> | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    academyId?: StringFilter<"Course"> | string
    image?: StringNullableFilter<"Course"> | string | null
    level?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    lessons?: LessonListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    quizzes?: QuizListRelationFilter
    instructors?: InstructorListRelationFilter
    liveRoom?: LiveRoomListRelationFilter
    Path?: PathListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academyId?: SortOrder
    image?: SortOrderInput | SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    academy?: AcademyOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    quizzes?: QuizOrderByRelationAggregateInput
    instructors?: InstructorOrderByRelationAggregateInput
    liveRoom?: LiveRoomOrderByRelationAggregateInput
    Path?: PathOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    academyId?: StringFilter<"Course"> | string
    image?: StringNullableFilter<"Course"> | string | null
    level?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    lessons?: LessonListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    quizzes?: QuizListRelationFilter
    instructors?: InstructorListRelationFilter
    liveRoom?: LiveRoomListRelationFilter
    Path?: PathListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academyId?: SortOrder
    image?: SortOrderInput | SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    academyId?: StringWithAggregatesFilter<"Course"> | string
    image?: StringNullableWithAggregatesFilter<"Course"> | string | null
    level?: StringWithAggregatesFilter<"Course"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    status?: EnumCourseStatusWithAggregatesFilter<"Course"> | $Enums.CourseStatus
  }

  export type PathWhereInput = {
    AND?: PathWhereInput | PathWhereInput[]
    OR?: PathWhereInput[]
    NOT?: PathWhereInput | PathWhereInput[]
    id?: StringFilter<"Path"> | string
    title?: StringFilter<"Path"> | string
    description?: StringNullableFilter<"Path"> | string | null
    level?: StringFilter<"Path"> | string
    completedTasks?: IntFilter<"Path"> | number
    remainingTime?: IntFilter<"Path"> | number
    studyTime?: IntFilter<"Path"> | number
    totalTasks?: IntFilter<"Path"> | number
    progress?: FloatFilter<"Path"> | number
    engagement?: FloatFilter<"Path"> | number
    createdAt?: DateTimeFilter<"Path"> | Date | string
    updatedAt?: DateTimeFilter<"Path"> | Date | string
    milestones?: MilestoneListRelationFilter
    courses?: CourseListRelationFilter
    peers?: UserListRelationFilter
  }

  export type PathOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    completedTasks?: SortOrder
    remainingTime?: SortOrder
    studyTime?: SortOrder
    totalTasks?: SortOrder
    progress?: SortOrder
    engagement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    milestones?: MilestoneOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    peers?: UserOrderByRelationAggregateInput
  }

  export type PathWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PathWhereInput | PathWhereInput[]
    OR?: PathWhereInput[]
    NOT?: PathWhereInput | PathWhereInput[]
    title?: StringFilter<"Path"> | string
    description?: StringNullableFilter<"Path"> | string | null
    level?: StringFilter<"Path"> | string
    completedTasks?: IntFilter<"Path"> | number
    remainingTime?: IntFilter<"Path"> | number
    studyTime?: IntFilter<"Path"> | number
    totalTasks?: IntFilter<"Path"> | number
    progress?: FloatFilter<"Path"> | number
    engagement?: FloatFilter<"Path"> | number
    createdAt?: DateTimeFilter<"Path"> | Date | string
    updatedAt?: DateTimeFilter<"Path"> | Date | string
    milestones?: MilestoneListRelationFilter
    courses?: CourseListRelationFilter
    peers?: UserListRelationFilter
  }, "id">

  export type PathOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    level?: SortOrder
    completedTasks?: SortOrder
    remainingTime?: SortOrder
    studyTime?: SortOrder
    totalTasks?: SortOrder
    progress?: SortOrder
    engagement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PathCountOrderByAggregateInput
    _avg?: PathAvgOrderByAggregateInput
    _max?: PathMaxOrderByAggregateInput
    _min?: PathMinOrderByAggregateInput
    _sum?: PathSumOrderByAggregateInput
  }

  export type PathScalarWhereWithAggregatesInput = {
    AND?: PathScalarWhereWithAggregatesInput | PathScalarWhereWithAggregatesInput[]
    OR?: PathScalarWhereWithAggregatesInput[]
    NOT?: PathScalarWhereWithAggregatesInput | PathScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Path"> | string
    title?: StringWithAggregatesFilter<"Path"> | string
    description?: StringNullableWithAggregatesFilter<"Path"> | string | null
    level?: StringWithAggregatesFilter<"Path"> | string
    completedTasks?: IntWithAggregatesFilter<"Path"> | number
    remainingTime?: IntWithAggregatesFilter<"Path"> | number
    studyTime?: IntWithAggregatesFilter<"Path"> | number
    totalTasks?: IntWithAggregatesFilter<"Path"> | number
    progress?: FloatWithAggregatesFilter<"Path"> | number
    engagement?: FloatWithAggregatesFilter<"Path"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Path"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Path"> | Date | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    status?: EnumMilestoneStatusFilter<"Milestone"> | $Enums.MilestoneStatus
    pathId?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    path?: XOR<PathScalarRelationFilter, PathWhereInput>
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    pathId?: SortOrder
    createdAt?: SortOrder
    path?: PathOrderByWithRelationInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    title?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    status?: EnumMilestoneStatusFilter<"Milestone"> | $Enums.MilestoneStatus
    pathId?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    path?: XOR<PathScalarRelationFilter, PathWhereInput>
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    pathId?: SortOrder
    createdAt?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    title?: StringWithAggregatesFilter<"Milestone"> | string
    description?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    status?: EnumMilestoneStatusWithAggregatesFilter<"Milestone"> | $Enums.MilestoneStatus
    pathId?: StringWithAggregatesFilter<"Milestone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    content?: StringFilter<"Lesson"> | string
    courseId?: StringFilter<"Lesson"> | string
    status?: EnumLessonStatusFilter<"Lesson"> | $Enums.LessonStatus
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    files?: FileListRelationFilter
    quizzes?: QuizListRelationFilter
    completedBy?: UserListRelationFilter
    Attendance?: AttendanceListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    course?: CourseOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
    quizzes?: QuizOrderByRelationAggregateInput
    completedBy?: UserOrderByRelationAggregateInput
    Attendance?: AttendanceOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    title?: StringFilter<"Lesson"> | string
    content?: StringFilter<"Lesson"> | string
    courseId?: StringFilter<"Lesson"> | string
    status?: EnumLessonStatusFilter<"Lesson"> | $Enums.LessonStatus
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    files?: FileListRelationFilter
    quizzes?: QuizListRelationFilter
    completedBy?: UserListRelationFilter
    Attendance?: AttendanceListRelationFilter
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    title?: StringWithAggregatesFilter<"Lesson"> | string
    content?: StringWithAggregatesFilter<"Lesson"> | string
    courseId?: StringWithAggregatesFilter<"Lesson"> | string
    status?: EnumLessonStatusWithAggregatesFilter<"Lesson"> | $Enums.LessonStatus
    createdAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    lessonId?: StringNullableFilter<"File"> | string | null
    accountingEntryId?: StringNullableFilter<"File"> | string | null
    prRecordId?: StringNullableFilter<"File"> | string | null
    meetingId?: StringNullableFilter<"File"> | string | null
    adminRoleId?: StringNullableFilter<"File"> | string | null
    legalCaseId?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    lesson?: XOR<LessonNullableScalarRelationFilter, LessonWhereInput> | null
    accountingEntry?: XOR<AccountingEntryNullableScalarRelationFilter, AccountingEntryWhereInput> | null
    prRecord?: XOR<PublicRelationsRecordNullableScalarRelationFilter, PublicRelationsRecordWhereInput> | null
    meeting?: XOR<MeetingNullableScalarRelationFilter, MeetingWhereInput> | null
    adminRole?: XOR<AdminRoleNullableScalarRelationFilter, AdminRoleWhereInput> | null
    legalCase?: XOR<LegalCaseNullableScalarRelationFilter, LegalCaseWhereInput> | null
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    lessonId?: SortOrderInput | SortOrder
    accountingEntryId?: SortOrderInput | SortOrder
    prRecordId?: SortOrderInput | SortOrder
    meetingId?: SortOrderInput | SortOrder
    adminRoleId?: SortOrderInput | SortOrder
    legalCaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    accountingEntry?: AccountingEntryOrderByWithRelationInput
    prRecord?: PublicRelationsRecordOrderByWithRelationInput
    meeting?: MeetingOrderByWithRelationInput
    adminRole?: AdminRoleOrderByWithRelationInput
    legalCase?: LegalCaseOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    name?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    lessonId?: StringNullableFilter<"File"> | string | null
    accountingEntryId?: StringNullableFilter<"File"> | string | null
    prRecordId?: StringNullableFilter<"File"> | string | null
    meetingId?: StringNullableFilter<"File"> | string | null
    adminRoleId?: StringNullableFilter<"File"> | string | null
    legalCaseId?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    lesson?: XOR<LessonNullableScalarRelationFilter, LessonWhereInput> | null
    accountingEntry?: XOR<AccountingEntryNullableScalarRelationFilter, AccountingEntryWhereInput> | null
    prRecord?: XOR<PublicRelationsRecordNullableScalarRelationFilter, PublicRelationsRecordWhereInput> | null
    meeting?: XOR<MeetingNullableScalarRelationFilter, MeetingWhereInput> | null
    adminRole?: XOR<AdminRoleNullableScalarRelationFilter, AdminRoleWhereInput> | null
    legalCase?: XOR<LegalCaseNullableScalarRelationFilter, LegalCaseWhereInput> | null
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    lessonId?: SortOrderInput | SortOrder
    accountingEntryId?: SortOrderInput | SortOrder
    prRecordId?: SortOrderInput | SortOrder
    meetingId?: SortOrderInput | SortOrder
    adminRoleId?: SortOrderInput | SortOrder
    legalCaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    name?: StringWithAggregatesFilter<"File"> | string
    url?: StringWithAggregatesFilter<"File"> | string
    type?: EnumFileTypeWithAggregatesFilter<"File"> | $Enums.FileType
    lessonId?: StringNullableWithAggregatesFilter<"File"> | string | null
    accountingEntryId?: StringNullableWithAggregatesFilter<"File"> | string | null
    prRecordId?: StringNullableWithAggregatesFilter<"File"> | string | null
    meetingId?: StringNullableWithAggregatesFilter<"File"> | string | null
    adminRoleId?: StringNullableWithAggregatesFilter<"File"> | string | null
    legalCaseId?: StringNullableWithAggregatesFilter<"File"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    userId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    progress?: FloatFilter<"Enrollment"> | number
    status?: StringFilter<"Enrollment"> | string
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    userId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    progress?: FloatFilter<"Enrollment"> | number
    status?: StringFilter<"Enrollment"> | string
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _avg?: EnrollmentAvgOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
    _sum?: EnrollmentSumOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enrollment"> | string
    userId?: StringWithAggregatesFilter<"Enrollment"> | string
    courseId?: StringWithAggregatesFilter<"Enrollment"> | string
    progress?: FloatWithAggregatesFilter<"Enrollment"> | number
    status?: StringWithAggregatesFilter<"Enrollment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: StringFilter<"Quiz"> | string
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    lessonId?: StringFilter<"Quiz"> | string
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    passingScore?: IntNullableFilter<"Quiz"> | number | null
    upComing?: BoolFilter<"Quiz"> | boolean
    isCompleted?: BoolFilter<"Quiz"> | boolean
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    questions?: QuestionListRelationFilter
    submissions?: SubmissionListRelationFilter
    Course?: CourseListRelationFilter
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    lessonId?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    passingScore?: SortOrderInput | SortOrder
    upComing?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    questions?: QuestionOrderByRelationAggregateInput
    submissions?: SubmissionOrderByRelationAggregateInput
    Course?: CourseOrderByRelationAggregateInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    lessonId?: StringFilter<"Quiz"> | string
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    passingScore?: IntNullableFilter<"Quiz"> | number | null
    upComing?: BoolFilter<"Quiz"> | boolean
    isCompleted?: BoolFilter<"Quiz"> | boolean
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    questions?: QuestionListRelationFilter
    submissions?: SubmissionListRelationFilter
    Course?: CourseListRelationFilter
  }, "id">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    lessonId?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    passingScore?: SortOrderInput | SortOrder
    upComing?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quiz"> | string
    title?: StringWithAggregatesFilter<"Quiz"> | string
    description?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    lessonId?: StringWithAggregatesFilter<"Quiz"> | string
    timeLimit?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    passingScore?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    upComing?: BoolWithAggregatesFilter<"Quiz"> | boolean
    isCompleted?: BoolWithAggregatesFilter<"Quiz"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    type?: StringFilter<"Question"> | string
    isMultiple?: BoolFilter<"Question"> | boolean
    points?: IntFilter<"Question"> | number
    isAnswered?: BoolFilter<"Question"> | boolean
    quizId?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    options?: OptionListRelationFilter
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    isMultiple?: SortOrder
    points?: SortOrder
    isAnswered?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    options?: OptionOrderByRelationAggregateInput
    quiz?: QuizOrderByWithRelationInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    text?: StringFilter<"Question"> | string
    type?: StringFilter<"Question"> | string
    isMultiple?: BoolFilter<"Question"> | boolean
    points?: IntFilter<"Question"> | number
    isAnswered?: BoolFilter<"Question"> | boolean
    quizId?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
    options?: OptionListRelationFilter
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    isMultiple?: SortOrder
    points?: SortOrder
    isAnswered?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    text?: StringWithAggregatesFilter<"Question"> | string
    type?: StringWithAggregatesFilter<"Question"> | string
    isMultiple?: BoolWithAggregatesFilter<"Question"> | boolean
    points?: IntWithAggregatesFilter<"Question"> | number
    isAnswered?: BoolWithAggregatesFilter<"Question"> | boolean
    quizId?: StringWithAggregatesFilter<"Question"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
  }

  export type OptionWhereInput = {
    AND?: OptionWhereInput | OptionWhereInput[]
    OR?: OptionWhereInput[]
    NOT?: OptionWhereInput | OptionWhereInput[]
    id?: StringFilter<"Option"> | string
    questionId?: StringFilter<"Option"> | string
    text?: StringFilter<"Option"> | string
    isCorrect?: BoolFilter<"Option"> | boolean
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }

  export type OptionOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: QuestionOrderByWithRelationInput
  }

  export type OptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OptionWhereInput | OptionWhereInput[]
    OR?: OptionWhereInput[]
    NOT?: OptionWhereInput | OptionWhereInput[]
    questionId?: StringFilter<"Option"> | string
    text?: StringFilter<"Option"> | string
    isCorrect?: BoolFilter<"Option"> | boolean
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }, "id">

  export type OptionOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OptionCountOrderByAggregateInput
    _max?: OptionMaxOrderByAggregateInput
    _min?: OptionMinOrderByAggregateInput
  }

  export type OptionScalarWhereWithAggregatesInput = {
    AND?: OptionScalarWhereWithAggregatesInput | OptionScalarWhereWithAggregatesInput[]
    OR?: OptionScalarWhereWithAggregatesInput[]
    NOT?: OptionScalarWhereWithAggregatesInput | OptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Option"> | string
    questionId?: StringWithAggregatesFilter<"Option"> | string
    text?: StringWithAggregatesFilter<"Option"> | string
    isCorrect?: BoolWithAggregatesFilter<"Option"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Option"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Option"> | Date | string
  }

  export type SubmissionWhereInput = {
    AND?: SubmissionWhereInput | SubmissionWhereInput[]
    OR?: SubmissionWhereInput[]
    NOT?: SubmissionWhereInput | SubmissionWhereInput[]
    id?: StringFilter<"Submission"> | string
    userId?: StringFilter<"Submission"> | string
    quizId?: StringFilter<"Submission"> | string
    answers?: JsonNullableListFilter<"Submission">
    score?: FloatNullableFilter<"Submission"> | number | null
    feedback?: StringNullableFilter<"Submission"> | string | null
    passed?: BoolNullableFilter<"Submission"> | boolean | null
    createdAt?: DateTimeFilter<"Submission"> | Date | string
    updatedAt?: DateTimeFilter<"Submission"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }

  export type SubmissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    quiz?: QuizOrderByWithRelationInput
  }

  export type SubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubmissionWhereInput | SubmissionWhereInput[]
    OR?: SubmissionWhereInput[]
    NOT?: SubmissionWhereInput | SubmissionWhereInput[]
    userId?: StringFilter<"Submission"> | string
    quizId?: StringFilter<"Submission"> | string
    answers?: JsonNullableListFilter<"Submission">
    score?: FloatNullableFilter<"Submission"> | number | null
    feedback?: StringNullableFilter<"Submission"> | string | null
    passed?: BoolNullableFilter<"Submission"> | boolean | null
    createdAt?: DateTimeFilter<"Submission"> | Date | string
    updatedAt?: DateTimeFilter<"Submission"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }, "id">

  export type SubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubmissionCountOrderByAggregateInput
    _avg?: SubmissionAvgOrderByAggregateInput
    _max?: SubmissionMaxOrderByAggregateInput
    _min?: SubmissionMinOrderByAggregateInput
    _sum?: SubmissionSumOrderByAggregateInput
  }

  export type SubmissionScalarWhereWithAggregatesInput = {
    AND?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[]
    OR?: SubmissionScalarWhereWithAggregatesInput[]
    NOT?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Submission"> | string
    userId?: StringWithAggregatesFilter<"Submission"> | string
    quizId?: StringWithAggregatesFilter<"Submission"> | string
    answers?: JsonNullableListFilter<"Submission">
    score?: FloatNullableWithAggregatesFilter<"Submission"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"Submission"> | string | null
    passed?: BoolNullableWithAggregatesFilter<"Submission"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Submission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Submission"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    userId?: StringFilter<"Achievement"> | string
    type?: StringFilter<"Achievement"> | string
    value?: JsonFilter<"Achievement">
    isNew?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isNew?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    userId?: StringFilter<"Achievement"> | string
    type?: StringFilter<"Achievement"> | string
    value?: JsonFilter<"Achievement">
    isNew?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isNew?: SortOrder
    createdAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    userId?: StringWithAggregatesFilter<"Achievement"> | string
    type?: StringWithAggregatesFilter<"Achievement"> | string
    value?: JsonWithAggregatesFilter<"Achievement">
    isNew?: BoolWithAggregatesFilter<"Achievement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    isImportant?: BoolFilter<"Notification"> | boolean
    urgent?: BoolFilter<"Notification"> | boolean
    title?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isImportant?: SortOrder
    urgent?: SortOrder
    title?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    isImportant?: BoolFilter<"Notification"> | boolean
    urgent?: BoolFilter<"Notification"> | boolean
    title?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isImportant?: SortOrder
    urgent?: SortOrder
    title?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    message?: StringWithAggregatesFilter<"Notification"> | string
    isImportant?: BoolWithAggregatesFilter<"Notification"> | boolean
    urgent?: BoolWithAggregatesFilter<"Notification"> | boolean
    title?: StringWithAggregatesFilter<"Notification"> | string
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    id?: StringFilter<"NotificationSettings"> | string
    userId?: StringFilter<"NotificationSettings"> | string
    assignments?: BoolFilter<"NotificationSettings"> | boolean
    grades?: BoolFilter<"NotificationSettings"> | boolean
    messages?: BoolFilter<"NotificationSettings"> | boolean
    achievements?: BoolFilter<"NotificationSettings"> | boolean
    urgent?: BoolFilter<"NotificationSettings"> | boolean
    email?: BoolFilter<"NotificationSettings"> | boolean
    push?: BoolFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    assignments?: SortOrder
    grades?: SortOrder
    messages?: SortOrder
    achievements?: SortOrder
    urgent?: SortOrder
    email?: SortOrder
    push?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    userId?: StringFilter<"NotificationSettings"> | string
    assignments?: BoolFilter<"NotificationSettings"> | boolean
    grades?: BoolFilter<"NotificationSettings"> | boolean
    messages?: BoolFilter<"NotificationSettings"> | boolean
    achievements?: BoolFilter<"NotificationSettings"> | boolean
    urgent?: BoolFilter<"NotificationSettings"> | boolean
    email?: BoolFilter<"NotificationSettings"> | boolean
    push?: BoolFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    assignments?: SortOrder
    grades?: SortOrder
    messages?: SortOrder
    achievements?: SortOrder
    urgent?: SortOrder
    email?: SortOrder
    push?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationSettingsCountOrderByAggregateInput
    _max?: NotificationSettingsMaxOrderByAggregateInput
    _min?: NotificationSettingsMinOrderByAggregateInput
  }

  export type NotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationSettings"> | string
    userId?: StringWithAggregatesFilter<"NotificationSettings"> | string
    assignments?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    grades?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    messages?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    achievements?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    urgent?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    email?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    push?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    isRead?: BoolFilter<"Message"> | boolean
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    Channel?: ChannelListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    sender?: UserOrderByWithRelationInput
    Channel?: ChannelOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    isRead?: BoolFilter<"Message"> | boolean
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    Channel?: ChannelListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    likesCount?: IntFilter<"Post"> | number
    publicRelationsRecordId?: StringNullableFilter<"Post"> | string | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    Group?: GroupListRelationFilter
    Community?: CommunityListRelationFilter
    Discussion?: DiscussionListRelationFilter
    PublicRelationsRecord?: XOR<PublicRelationsRecordNullableScalarRelationFilter, PublicRelationsRecordWhereInput> | null
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    likesCount?: SortOrder
    publicRelationsRecordId?: SortOrderInput | SortOrder
    author?: UserOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    Group?: GroupOrderByRelationAggregateInput
    Community?: CommunityOrderByRelationAggregateInput
    Discussion?: DiscussionOrderByRelationAggregateInput
    PublicRelationsRecord?: PublicRelationsRecordOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    authorId?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    likesCount?: IntFilter<"Post"> | number
    publicRelationsRecordId?: StringNullableFilter<"Post"> | string | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    Group?: GroupListRelationFilter
    Community?: CommunityListRelationFilter
    Discussion?: DiscussionListRelationFilter
    PublicRelationsRecord?: XOR<PublicRelationsRecordNullableScalarRelationFilter, PublicRelationsRecordWhereInput> | null
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    likesCount?: SortOrder
    publicRelationsRecordId?: SortOrderInput | SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    authorId?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    title?: StringWithAggregatesFilter<"Post"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    likesCount?: IntWithAggregatesFilter<"Post"> | number
    publicRelationsRecordId?: StringNullableWithAggregatesFilter<"Post"> | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type GroupWhereInput = {
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    subject?: StringFilter<"Group"> | string
    image?: StringNullableFilter<"Group"> | string | null
    adminId?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    members?: UserListRelationFilter
    posts?: PostListRelationFilter
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    Community?: CommunityListRelationFilter
  }

  export type GroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    image?: SortOrderInput | SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    members?: UserOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    admin?: AdminOrderByWithRelationInput
    Community?: CommunityOrderByRelationAggregateInput
  }

  export type GroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GroupWhereInput | GroupWhereInput[]
    OR?: GroupWhereInput[]
    NOT?: GroupWhereInput | GroupWhereInput[]
    name?: StringFilter<"Group"> | string
    subject?: StringFilter<"Group"> | string
    image?: StringNullableFilter<"Group"> | string | null
    adminId?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
    members?: UserListRelationFilter
    posts?: PostListRelationFilter
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    Community?: CommunityListRelationFilter
  }, "id">

  export type GroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    image?: SortOrderInput | SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    _count?: GroupCountOrderByAggregateInput
    _max?: GroupMaxOrderByAggregateInput
    _min?: GroupMinOrderByAggregateInput
  }

  export type GroupScalarWhereWithAggregatesInput = {
    AND?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    OR?: GroupScalarWhereWithAggregatesInput[]
    NOT?: GroupScalarWhereWithAggregatesInput | GroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Group"> | string
    name?: StringWithAggregatesFilter<"Group"> | string
    subject?: StringWithAggregatesFilter<"Group"> | string
    image?: StringNullableWithAggregatesFilter<"Group"> | string | null
    adminId?: StringWithAggregatesFilter<"Group"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Group"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Group?: GroupListRelationFilter
    accountingEntries?: AccountingEntryListRelationFilter
    prRecords?: PublicRelationsRecordListRelationFilter
    prResponses?: PRResponseListRelationFilter
    meetings?: MeetingListRelationFilter
    assignments?: AdminAssignmentListRelationFilter
    legalCases?: LegalCaseListRelationFilter
    AdminRole?: AdminRoleListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    Group?: GroupOrderByRelationAggregateInput
    accountingEntries?: AccountingEntryOrderByRelationAggregateInput
    prRecords?: PublicRelationsRecordOrderByRelationAggregateInput
    prResponses?: PRResponseOrderByRelationAggregateInput
    meetings?: MeetingOrderByRelationAggregateInput
    assignments?: AdminAssignmentOrderByRelationAggregateInput
    legalCases?: LegalCaseOrderByRelationAggregateInput
    AdminRole?: AdminRoleOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    userId?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Group?: GroupListRelationFilter
    accountingEntries?: AccountingEntryListRelationFilter
    prRecords?: PublicRelationsRecordListRelationFilter
    prResponses?: PRResponseListRelationFilter
    meetings?: MeetingListRelationFilter
    assignments?: AdminAssignmentListRelationFilter
    legalCases?: LegalCaseListRelationFilter
    AdminRole?: AdminRoleListRelationFilter
  }, "id">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type ChannelWhereInput = {
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    id?: StringFilter<"Channel"> | string
    name?: StringFilter<"Channel"> | string
    ownerId?: StringFilter<"Channel"> | string
    prRecordId?: StringNullableFilter<"Channel"> | string | null
    meetingId?: StringNullableFilter<"Channel"> | string | null
    adminRoleId?: StringNullableFilter<"Channel"> | string | null
    legalCaseId?: StringNullableFilter<"Channel"> | string | null
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    members?: UserListRelationFilter
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
    messages?: MessageListRelationFilter
    prRecord?: XOR<PublicRelationsRecordNullableScalarRelationFilter, PublicRelationsRecordWhereInput> | null
    meeting?: XOR<MeetingNullableScalarRelationFilter, MeetingWhereInput> | null
    adminRole?: XOR<AdminRoleNullableScalarRelationFilter, AdminRoleWhereInput> | null
    legalCase?: XOR<LegalCaseNullableScalarRelationFilter, LegalCaseWhereInput> | null
  }

  export type ChannelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    prRecordId?: SortOrderInput | SortOrder
    meetingId?: SortOrderInput | SortOrder
    adminRoleId?: SortOrderInput | SortOrder
    legalCaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    members?: UserOrderByRelationAggregateInput
    owner?: OwnerOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    prRecord?: PublicRelationsRecordOrderByWithRelationInput
    meeting?: MeetingOrderByWithRelationInput
    adminRole?: AdminRoleOrderByWithRelationInput
    legalCase?: LegalCaseOrderByWithRelationInput
  }

  export type ChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelWhereInput | ChannelWhereInput[]
    OR?: ChannelWhereInput[]
    NOT?: ChannelWhereInput | ChannelWhereInput[]
    name?: StringFilter<"Channel"> | string
    ownerId?: StringFilter<"Channel"> | string
    prRecordId?: StringNullableFilter<"Channel"> | string | null
    meetingId?: StringNullableFilter<"Channel"> | string | null
    adminRoleId?: StringNullableFilter<"Channel"> | string | null
    legalCaseId?: StringNullableFilter<"Channel"> | string | null
    createdAt?: DateTimeFilter<"Channel"> | Date | string
    members?: UserListRelationFilter
    owner?: XOR<OwnerScalarRelationFilter, OwnerWhereInput>
    messages?: MessageListRelationFilter
    prRecord?: XOR<PublicRelationsRecordNullableScalarRelationFilter, PublicRelationsRecordWhereInput> | null
    meeting?: XOR<MeetingNullableScalarRelationFilter, MeetingWhereInput> | null
    adminRole?: XOR<AdminRoleNullableScalarRelationFilter, AdminRoleWhereInput> | null
    legalCase?: XOR<LegalCaseNullableScalarRelationFilter, LegalCaseWhereInput> | null
  }, "id">

  export type ChannelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    prRecordId?: SortOrderInput | SortOrder
    meetingId?: SortOrderInput | SortOrder
    adminRoleId?: SortOrderInput | SortOrder
    legalCaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChannelCountOrderByAggregateInput
    _max?: ChannelMaxOrderByAggregateInput
    _min?: ChannelMinOrderByAggregateInput
  }

  export type ChannelScalarWhereWithAggregatesInput = {
    AND?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    OR?: ChannelScalarWhereWithAggregatesInput[]
    NOT?: ChannelScalarWhereWithAggregatesInput | ChannelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Channel"> | string
    name?: StringWithAggregatesFilter<"Channel"> | string
    ownerId?: StringWithAggregatesFilter<"Channel"> | string
    prRecordId?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    meetingId?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    adminRoleId?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    legalCaseId?: StringNullableWithAggregatesFilter<"Channel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Channel"> | Date | string
  }

  export type OwnerWhereInput = {
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    id?: StringFilter<"Owner"> | string
    userId?: StringFilter<"Owner"> | string
    createdAt?: DateTimeFilter<"Owner"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Channel?: ChannelListRelationFilter
  }

  export type OwnerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    Channel?: ChannelOrderByRelationAggregateInput
  }

  export type OwnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OwnerWhereInput | OwnerWhereInput[]
    OR?: OwnerWhereInput[]
    NOT?: OwnerWhereInput | OwnerWhereInput[]
    userId?: StringFilter<"Owner"> | string
    createdAt?: DateTimeFilter<"Owner"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Channel?: ChannelListRelationFilter
  }, "id">

  export type OwnerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: OwnerCountOrderByAggregateInput
    _max?: OwnerMaxOrderByAggregateInput
    _min?: OwnerMinOrderByAggregateInput
  }

  export type OwnerScalarWhereWithAggregatesInput = {
    AND?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    OR?: OwnerScalarWhereWithAggregatesInput[]
    NOT?: OwnerScalarWhereWithAggregatesInput | OwnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Owner"> | string
    userId?: StringWithAggregatesFilter<"Owner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Owner"> | Date | string
  }

  export type BookmarkWhereInput = {
    AND?: BookmarkWhereInput | BookmarkWhereInput[]
    OR?: BookmarkWhereInput[]
    NOT?: BookmarkWhereInput | BookmarkWhereInput[]
    id?: StringFilter<"Bookmark"> | string
    userId?: StringFilter<"Bookmark"> | string
    type?: StringFilter<"Bookmark"> | string
    itemId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BookmarkOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BookmarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookmarkWhereInput | BookmarkWhereInput[]
    OR?: BookmarkWhereInput[]
    NOT?: BookmarkWhereInput | BookmarkWhereInput[]
    userId?: StringFilter<"Bookmark"> | string
    type?: StringFilter<"Bookmark"> | string
    itemId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BookmarkOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    createdAt?: SortOrder
    _count?: BookmarkCountOrderByAggregateInput
    _max?: BookmarkMaxOrderByAggregateInput
    _min?: BookmarkMinOrderByAggregateInput
  }

  export type BookmarkScalarWhereWithAggregatesInput = {
    AND?: BookmarkScalarWhereWithAggregatesInput | BookmarkScalarWhereWithAggregatesInput[]
    OR?: BookmarkScalarWhereWithAggregatesInput[]
    NOT?: BookmarkScalarWhereWithAggregatesInput | BookmarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bookmark"> | string
    userId?: StringWithAggregatesFilter<"Bookmark"> | string
    type?: StringWithAggregatesFilter<"Bookmark"> | string
    itemId?: StringWithAggregatesFilter<"Bookmark"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Bookmark"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    academyId?: StringFilter<"Event"> | string
    prRecordId?: StringNullableFilter<"Event"> | string | null
    adminRoleId?: StringNullableFilter<"Event"> | string | null
    legalCaseId?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    prRecord?: XOR<PublicRelationsRecordNullableScalarRelationFilter, PublicRelationsRecordWhereInput> | null
    adminRole?: XOR<AdminRoleNullableScalarRelationFilter, AdminRoleWhereInput> | null
    legalCase?: XOR<LegalCaseNullableScalarRelationFilter, LegalCaseWhereInput> | null
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    academyId?: SortOrder
    prRecordId?: SortOrderInput | SortOrder
    adminRoleId?: SortOrderInput | SortOrder
    legalCaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academy?: AcademyOrderByWithRelationInput
    prRecord?: PublicRelationsRecordOrderByWithRelationInput
    adminRole?: AdminRoleOrderByWithRelationInput
    legalCase?: LegalCaseOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    academyId?: StringFilter<"Event"> | string
    prRecordId?: StringNullableFilter<"Event"> | string | null
    adminRoleId?: StringNullableFilter<"Event"> | string | null
    legalCaseId?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    prRecord?: XOR<PublicRelationsRecordNullableScalarRelationFilter, PublicRelationsRecordWhereInput> | null
    adminRole?: XOR<AdminRoleNullableScalarRelationFilter, AdminRoleWhereInput> | null
    legalCase?: XOR<LegalCaseNullableScalarRelationFilter, LegalCaseWhereInput> | null
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    academyId?: SortOrder
    prRecordId?: SortOrderInput | SortOrder
    adminRoleId?: SortOrderInput | SortOrder
    legalCaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    academyId?: StringWithAggregatesFilter<"Event"> | string
    prRecordId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    adminRoleId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    legalCaseId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    studentId?: StringFilter<"Attendance"> | string
    lessonId?: StringFilter<"Attendance"> | string
    status?: StringFilter<"Attendance"> | string
    method?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    lessonId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: UserOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    studentId?: StringFilter<"Attendance"> | string
    lessonId?: StringFilter<"Attendance"> | string
    status?: StringFilter<"Attendance"> | string
    method?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    student?: XOR<UserScalarRelationFilter, UserWhereInput>
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    lessonId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    studentId?: StringWithAggregatesFilter<"Attendance"> | string
    lessonId?: StringWithAggregatesFilter<"Attendance"> | string
    status?: StringWithAggregatesFilter<"Attendance"> | string
    method?: StringWithAggregatesFilter<"Attendance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    legalCaseId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    legalCase?: XOR<LegalCaseNullableScalarRelationFilter, LegalCaseWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    legalCaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    legalCase?: LegalCaseOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    legalCaseId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    legalCase?: XOR<LegalCaseNullableScalarRelationFilter, LegalCaseWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    legalCaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    legalCaseId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    userId?: StringFilter<"Report"> | string
    accountingEntryId?: StringNullableFilter<"Report"> | string | null
    meetingId?: StringNullableFilter<"Report"> | string | null
    adminRoleId?: StringNullableFilter<"Report"> | string | null
    legalCaseId?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    accountingEntry?: XOR<AccountingEntryNullableScalarRelationFilter, AccountingEntryWhereInput> | null
    meeting?: XOR<MeetingNullableScalarRelationFilter, MeetingWhereInput> | null
    adminRole?: XOR<AdminRoleNullableScalarRelationFilter, AdminRoleWhereInput> | null
    legalCase?: XOR<LegalCaseNullableScalarRelationFilter, LegalCaseWhereInput> | null
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountingEntryId?: SortOrderInput | SortOrder
    meetingId?: SortOrderInput | SortOrder
    adminRoleId?: SortOrderInput | SortOrder
    legalCaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    accountingEntry?: AccountingEntryOrderByWithRelationInput
    meeting?: MeetingOrderByWithRelationInput
    adminRole?: AdminRoleOrderByWithRelationInput
    legalCase?: LegalCaseOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    userId?: StringFilter<"Report"> | string
    accountingEntryId?: StringNullableFilter<"Report"> | string | null
    meetingId?: StringNullableFilter<"Report"> | string | null
    adminRoleId?: StringNullableFilter<"Report"> | string | null
    legalCaseId?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    accountingEntry?: XOR<AccountingEntryNullableScalarRelationFilter, AccountingEntryWhereInput> | null
    meeting?: XOR<MeetingNullableScalarRelationFilter, MeetingWhereInput> | null
    adminRole?: XOR<AdminRoleNullableScalarRelationFilter, AdminRoleWhereInput> | null
    legalCase?: XOR<LegalCaseNullableScalarRelationFilter, LegalCaseWhereInput> | null
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountingEntryId?: SortOrderInput | SortOrder
    meetingId?: SortOrderInput | SortOrder
    adminRoleId?: SortOrderInput | SortOrder
    legalCaseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    userId?: StringWithAggregatesFilter<"Report"> | string
    accountingEntryId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    meetingId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    adminRoleId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    legalCaseId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    userId?: StringFilter<"Badge"> | string
    title?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    image?: StringNullableFilter<"Badge"> | string | null
    points?: IntFilter<"Badge"> | number
    type?: StringFilter<"Badge"> | string
    earnedAt?: DateTimeFilter<"Badge"> | Date | string
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    points?: SortOrder
    type?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    userId?: StringFilter<"Badge"> | string
    title?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    image?: StringNullableFilter<"Badge"> | string | null
    points?: IntFilter<"Badge"> | number
    type?: StringFilter<"Badge"> | string
    earnedAt?: DateTimeFilter<"Badge"> | Date | string
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    points?: SortOrder
    type?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    userId?: StringWithAggregatesFilter<"Badge"> | string
    title?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    image?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    points?: IntWithAggregatesFilter<"Badge"> | number
    type?: StringWithAggregatesFilter<"Badge"> | string
    earnedAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: StringFilter<"Certificate"> | string
    name?: StringFilter<"Certificate"> | string
    address?: StringFilter<"Certificate"> | string
    phone?: StringFilter<"Certificate"> | string
    notes?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    title?: StringFilter<"Certificate"> | string
    description?: StringNullableFilter<"Certificate"> | string | null
    url?: StringNullableFilter<"Certificate"> | string | null
    image?: StringNullableFilter<"Certificate"> | string | null
    points?: IntFilter<"Certificate"> | number
    type?: StringFilter<"Certificate"> | string
    earnedAt?: DateTimeFilter<"Certificate"> | Date | string
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    points?: SortOrder
    type?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    name?: StringFilter<"Certificate"> | string
    address?: StringFilter<"Certificate"> | string
    phone?: StringFilter<"Certificate"> | string
    notes?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    title?: StringFilter<"Certificate"> | string
    description?: StringNullableFilter<"Certificate"> | string | null
    url?: StringNullableFilter<"Certificate"> | string | null
    image?: StringNullableFilter<"Certificate"> | string | null
    points?: IntFilter<"Certificate"> | number
    type?: StringFilter<"Certificate"> | string
    earnedAt?: DateTimeFilter<"Certificate"> | Date | string
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    points?: SortOrder
    type?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _avg?: CertificateAvgOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
    _sum?: CertificateSumOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certificate"> | string
    name?: StringWithAggregatesFilter<"Certificate"> | string
    address?: StringWithAggregatesFilter<"Certificate"> | string
    phone?: StringWithAggregatesFilter<"Certificate"> | string
    notes?: StringWithAggregatesFilter<"Certificate"> | string
    userId?: StringWithAggregatesFilter<"Certificate"> | string
    title?: StringWithAggregatesFilter<"Certificate"> | string
    description?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    url?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    image?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    points?: IntWithAggregatesFilter<"Certificate"> | number
    type?: StringWithAggregatesFilter<"Certificate"> | string
    earnedAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
  }

  export type CommunityWhereInput = {
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    id?: StringFilter<"Community"> | string
    name?: StringFilter<"Community"> | string
    image?: StringNullableFilter<"Community"> | string | null
    description?: StringNullableFilter<"Community"> | string | null
    type?: StringFilter<"Community"> | string
    likes?: IntFilter<"Community"> | number
    dislikes?: IntFilter<"Community"> | number
    views?: IntFilter<"Community"> | number
    createdAt?: DateTimeFilter<"Community"> | Date | string
    updatedAt?: DateTimeFilter<"Community"> | Date | string
    groups?: GroupListRelationFilter
    liveRoom?: LiveRoomListRelationFilter
    participants?: UserListRelationFilter
    posts?: PostListRelationFilter
    discussions?: DiscussionListRelationFilter
  }

  export type CommunityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    groups?: GroupOrderByRelationAggregateInput
    liveRoom?: LiveRoomOrderByRelationAggregateInput
    participants?: UserOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    discussions?: DiscussionOrderByRelationAggregateInput
  }

  export type CommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    name?: StringFilter<"Community"> | string
    image?: StringNullableFilter<"Community"> | string | null
    description?: StringNullableFilter<"Community"> | string | null
    type?: StringFilter<"Community"> | string
    likes?: IntFilter<"Community"> | number
    dislikes?: IntFilter<"Community"> | number
    views?: IntFilter<"Community"> | number
    createdAt?: DateTimeFilter<"Community"> | Date | string
    updatedAt?: DateTimeFilter<"Community"> | Date | string
    groups?: GroupListRelationFilter
    liveRoom?: LiveRoomListRelationFilter
    participants?: UserListRelationFilter
    posts?: PostListRelationFilter
    discussions?: DiscussionListRelationFilter
  }, "id">

  export type CommunityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityCountOrderByAggregateInput
    _avg?: CommunityAvgOrderByAggregateInput
    _max?: CommunityMaxOrderByAggregateInput
    _min?: CommunityMinOrderByAggregateInput
    _sum?: CommunitySumOrderByAggregateInput
  }

  export type CommunityScalarWhereWithAggregatesInput = {
    AND?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    OR?: CommunityScalarWhereWithAggregatesInput[]
    NOT?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Community"> | string
    name?: StringWithAggregatesFilter<"Community"> | string
    image?: StringNullableWithAggregatesFilter<"Community"> | string | null
    description?: StringNullableWithAggregatesFilter<"Community"> | string | null
    type?: StringWithAggregatesFilter<"Community"> | string
    likes?: IntWithAggregatesFilter<"Community"> | number
    dislikes?: IntWithAggregatesFilter<"Community"> | number
    views?: IntWithAggregatesFilter<"Community"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Community"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Community"> | Date | string
  }

  export type DiscussionWhereInput = {
    AND?: DiscussionWhereInput | DiscussionWhereInput[]
    OR?: DiscussionWhereInput[]
    NOT?: DiscussionWhereInput | DiscussionWhereInput[]
    id?: StringFilter<"Discussion"> | string
    communityId?: StringFilter<"Discussion"> | string
    postId?: StringNullableFilter<"Discussion"> | string | null
    createdAt?: DateTimeFilter<"Discussion"> | Date | string
    updatedAt?: DateTimeFilter<"Discussion"> | Date | string
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
  }

  export type DiscussionOrderByWithRelationInput = {
    id?: SortOrder
    communityId?: SortOrder
    postId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    community?: CommunityOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
  }

  export type DiscussionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiscussionWhereInput | DiscussionWhereInput[]
    OR?: DiscussionWhereInput[]
    NOT?: DiscussionWhereInput | DiscussionWhereInput[]
    communityId?: StringFilter<"Discussion"> | string
    postId?: StringNullableFilter<"Discussion"> | string | null
    createdAt?: DateTimeFilter<"Discussion"> | Date | string
    updatedAt?: DateTimeFilter<"Discussion"> | Date | string
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
  }, "id">

  export type DiscussionOrderByWithAggregationInput = {
    id?: SortOrder
    communityId?: SortOrder
    postId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiscussionCountOrderByAggregateInput
    _max?: DiscussionMaxOrderByAggregateInput
    _min?: DiscussionMinOrderByAggregateInput
  }

  export type DiscussionScalarWhereWithAggregatesInput = {
    AND?: DiscussionScalarWhereWithAggregatesInput | DiscussionScalarWhereWithAggregatesInput[]
    OR?: DiscussionScalarWhereWithAggregatesInput[]
    NOT?: DiscussionScalarWhereWithAggregatesInput | DiscussionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Discussion"> | string
    communityId?: StringWithAggregatesFilter<"Discussion"> | string
    postId?: StringNullableWithAggregatesFilter<"Discussion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Discussion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Discussion"> | Date | string
  }

  export type LiveRoomWhereInput = {
    AND?: LiveRoomWhereInput | LiveRoomWhereInput[]
    OR?: LiveRoomWhereInput[]
    NOT?: LiveRoomWhereInput | LiveRoomWhereInput[]
    id?: StringFilter<"LiveRoom"> | string
    title?: StringFilter<"LiveRoom"> | string
    topic?: StringNullableFilter<"LiveRoom"> | string | null
    participants?: IntFilter<"LiveRoom"> | number
    isLive?: BoolFilter<"LiveRoom"> | boolean
    isActive?: BoolFilter<"LiveRoom"> | boolean
    isPublic?: BoolFilter<"LiveRoom"> | boolean
    isPrivate?: BoolFilter<"LiveRoom"> | boolean
    isPasswordProtected?: BoolFilter<"LiveRoom"> | boolean
    createdAt?: DateTimeFilter<"LiveRoom"> | Date | string
    updatedAt?: DateTimeFilter<"LiveRoom"> | Date | string
    communityId?: StringFilter<"LiveRoom"> | string
    courseId?: StringNullableFilter<"LiveRoom"> | string | null
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    User?: UserListRelationFilter
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
  }

  export type LiveRoomOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    topic?: SortOrderInput | SortOrder
    participants?: SortOrder
    isLive?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    isPrivate?: SortOrder
    isPasswordProtected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    communityId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    community?: CommunityOrderByWithRelationInput
    User?: UserOrderByRelationAggregateInput
    course?: CourseOrderByWithRelationInput
  }

  export type LiveRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiveRoomWhereInput | LiveRoomWhereInput[]
    OR?: LiveRoomWhereInput[]
    NOT?: LiveRoomWhereInput | LiveRoomWhereInput[]
    title?: StringFilter<"LiveRoom"> | string
    topic?: StringNullableFilter<"LiveRoom"> | string | null
    participants?: IntFilter<"LiveRoom"> | number
    isLive?: BoolFilter<"LiveRoom"> | boolean
    isActive?: BoolFilter<"LiveRoom"> | boolean
    isPublic?: BoolFilter<"LiveRoom"> | boolean
    isPrivate?: BoolFilter<"LiveRoom"> | boolean
    isPasswordProtected?: BoolFilter<"LiveRoom"> | boolean
    createdAt?: DateTimeFilter<"LiveRoom"> | Date | string
    updatedAt?: DateTimeFilter<"LiveRoom"> | Date | string
    communityId?: StringFilter<"LiveRoom"> | string
    courseId?: StringNullableFilter<"LiveRoom"> | string | null
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    User?: UserListRelationFilter
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
  }, "id">

  export type LiveRoomOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    topic?: SortOrderInput | SortOrder
    participants?: SortOrder
    isLive?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    isPrivate?: SortOrder
    isPasswordProtected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    communityId?: SortOrder
    courseId?: SortOrderInput | SortOrder
    _count?: LiveRoomCountOrderByAggregateInput
    _avg?: LiveRoomAvgOrderByAggregateInput
    _max?: LiveRoomMaxOrderByAggregateInput
    _min?: LiveRoomMinOrderByAggregateInput
    _sum?: LiveRoomSumOrderByAggregateInput
  }

  export type LiveRoomScalarWhereWithAggregatesInput = {
    AND?: LiveRoomScalarWhereWithAggregatesInput | LiveRoomScalarWhereWithAggregatesInput[]
    OR?: LiveRoomScalarWhereWithAggregatesInput[]
    NOT?: LiveRoomScalarWhereWithAggregatesInput | LiveRoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LiveRoom"> | string
    title?: StringWithAggregatesFilter<"LiveRoom"> | string
    topic?: StringNullableWithAggregatesFilter<"LiveRoom"> | string | null
    participants?: IntWithAggregatesFilter<"LiveRoom"> | number
    isLive?: BoolWithAggregatesFilter<"LiveRoom"> | boolean
    isActive?: BoolWithAggregatesFilter<"LiveRoom"> | boolean
    isPublic?: BoolWithAggregatesFilter<"LiveRoom"> | boolean
    isPrivate?: BoolWithAggregatesFilter<"LiveRoom"> | boolean
    isPasswordProtected?: BoolWithAggregatesFilter<"LiveRoom"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LiveRoom"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LiveRoom"> | Date | string
    communityId?: StringWithAggregatesFilter<"LiveRoom"> | string
    courseId?: StringNullableWithAggregatesFilter<"LiveRoom"> | string | null
  }

  export type AccountingEntryWhereInput = {
    AND?: AccountingEntryWhereInput | AccountingEntryWhereInput[]
    OR?: AccountingEntryWhereInput[]
    NOT?: AccountingEntryWhereInput | AccountingEntryWhereInput[]
    id?: StringFilter<"AccountingEntry"> | string
    type?: EnumAccountingTypeFilter<"AccountingEntry"> | $Enums.AccountingType
    amount?: FloatFilter<"AccountingEntry"> | number
    description?: StringFilter<"AccountingEntry"> | string
    date?: DateTimeFilter<"AccountingEntry"> | Date | string
    createdByAdminId?: StringFilter<"AccountingEntry"> | string
    academyId?: StringFilter<"AccountingEntry"> | string
    createdAt?: DateTimeFilter<"AccountingEntry"> | Date | string
    updatedAt?: DateTimeFilter<"AccountingEntry"> | Date | string
    createdByAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    salaryPayment?: XOR<SalaryPaymentNullableScalarRelationFilter, SalaryPaymentWhereInput> | null
    files?: FileListRelationFilter
    reports?: ReportListRelationFilter
  }

  export type AccountingEntryOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByAdmin?: AdminOrderByWithRelationInput
    academy?: AcademyOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    salaryPayment?: SalaryPaymentOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type AccountingEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountingEntryWhereInput | AccountingEntryWhereInput[]
    OR?: AccountingEntryWhereInput[]
    NOT?: AccountingEntryWhereInput | AccountingEntryWhereInput[]
    type?: EnumAccountingTypeFilter<"AccountingEntry"> | $Enums.AccountingType
    amount?: FloatFilter<"AccountingEntry"> | number
    description?: StringFilter<"AccountingEntry"> | string
    date?: DateTimeFilter<"AccountingEntry"> | Date | string
    createdByAdminId?: StringFilter<"AccountingEntry"> | string
    academyId?: StringFilter<"AccountingEntry"> | string
    createdAt?: DateTimeFilter<"AccountingEntry"> | Date | string
    updatedAt?: DateTimeFilter<"AccountingEntry"> | Date | string
    createdByAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    salaryPayment?: XOR<SalaryPaymentNullableScalarRelationFilter, SalaryPaymentWhereInput> | null
    files?: FileListRelationFilter
    reports?: ReportListRelationFilter
  }, "id">

  export type AccountingEntryOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountingEntryCountOrderByAggregateInput
    _avg?: AccountingEntryAvgOrderByAggregateInput
    _max?: AccountingEntryMaxOrderByAggregateInput
    _min?: AccountingEntryMinOrderByAggregateInput
    _sum?: AccountingEntrySumOrderByAggregateInput
  }

  export type AccountingEntryScalarWhereWithAggregatesInput = {
    AND?: AccountingEntryScalarWhereWithAggregatesInput | AccountingEntryScalarWhereWithAggregatesInput[]
    OR?: AccountingEntryScalarWhereWithAggregatesInput[]
    NOT?: AccountingEntryScalarWhereWithAggregatesInput | AccountingEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountingEntry"> | string
    type?: EnumAccountingTypeWithAggregatesFilter<"AccountingEntry"> | $Enums.AccountingType
    amount?: FloatWithAggregatesFilter<"AccountingEntry"> | number
    description?: StringWithAggregatesFilter<"AccountingEntry"> | string
    date?: DateTimeWithAggregatesFilter<"AccountingEntry"> | Date | string
    createdByAdminId?: StringWithAggregatesFilter<"AccountingEntry"> | string
    academyId?: StringWithAggregatesFilter<"AccountingEntry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AccountingEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccountingEntry"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    description?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    accountingEntryId?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    accountingEntry?: XOR<AccountingEntryScalarRelationFilter, AccountingEntryWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    accountingEntryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountingEntry?: AccountingEntryOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    accountingEntryId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    amount?: FloatFilter<"Invoice"> | number
    description?: StringFilter<"Invoice"> | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    accountingEntry?: XOR<AccountingEntryScalarRelationFilter, AccountingEntryWhereInput>
  }, "id" | "invoiceNumber" | "accountingEntryId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    accountingEntryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: FloatWithAggregatesFilter<"Invoice"> | number
    description?: StringWithAggregatesFilter<"Invoice"> | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    accountingEntryId?: StringWithAggregatesFilter<"Invoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type SalaryPaymentWhereInput = {
    AND?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    OR?: SalaryPaymentWhereInput[]
    NOT?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    id?: StringFilter<"SalaryPayment"> | string
    employeeId?: StringFilter<"SalaryPayment"> | string
    amount?: FloatFilter<"SalaryPayment"> | number
    month?: IntFilter<"SalaryPayment"> | number
    year?: IntFilter<"SalaryPayment"> | number
    accountingEntryId?: StringFilter<"SalaryPayment"> | string
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    accountingEntry?: XOR<AccountingEntryScalarRelationFilter, AccountingEntryWhereInput>
  }

  export type SalaryPaymentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    month?: SortOrder
    year?: SortOrder
    accountingEntryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: UserOrderByWithRelationInput
    accountingEntry?: AccountingEntryOrderByWithRelationInput
  }

  export type SalaryPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountingEntryId?: string
    AND?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    OR?: SalaryPaymentWhereInput[]
    NOT?: SalaryPaymentWhereInput | SalaryPaymentWhereInput[]
    employeeId?: StringFilter<"SalaryPayment"> | string
    amount?: FloatFilter<"SalaryPayment"> | number
    month?: IntFilter<"SalaryPayment"> | number
    year?: IntFilter<"SalaryPayment"> | number
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    accountingEntry?: XOR<AccountingEntryScalarRelationFilter, AccountingEntryWhereInput>
  }, "id" | "accountingEntryId">

  export type SalaryPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    month?: SortOrder
    year?: SortOrder
    accountingEntryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalaryPaymentCountOrderByAggregateInput
    _avg?: SalaryPaymentAvgOrderByAggregateInput
    _max?: SalaryPaymentMaxOrderByAggregateInput
    _min?: SalaryPaymentMinOrderByAggregateInput
    _sum?: SalaryPaymentSumOrderByAggregateInput
  }

  export type SalaryPaymentScalarWhereWithAggregatesInput = {
    AND?: SalaryPaymentScalarWhereWithAggregatesInput | SalaryPaymentScalarWhereWithAggregatesInput[]
    OR?: SalaryPaymentScalarWhereWithAggregatesInput[]
    NOT?: SalaryPaymentScalarWhereWithAggregatesInput | SalaryPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalaryPayment"> | string
    employeeId?: StringWithAggregatesFilter<"SalaryPayment"> | string
    amount?: FloatWithAggregatesFilter<"SalaryPayment"> | number
    month?: IntWithAggregatesFilter<"SalaryPayment"> | number
    year?: IntWithAggregatesFilter<"SalaryPayment"> | number
    accountingEntryId?: StringWithAggregatesFilter<"SalaryPayment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalaryPayment"> | Date | string
  }

  export type PublicRelationsRecordWhereInput = {
    AND?: PublicRelationsRecordWhereInput | PublicRelationsRecordWhereInput[]
    OR?: PublicRelationsRecordWhereInput[]
    NOT?: PublicRelationsRecordWhereInput | PublicRelationsRecordWhereInput[]
    id?: StringFilter<"PublicRelationsRecord"> | string
    message?: StringFilter<"PublicRelationsRecord"> | string
    senderName?: StringFilter<"PublicRelationsRecord"> | string
    senderContact?: StringFilter<"PublicRelationsRecord"> | string
    status?: EnumPRRequestStatusFilter<"PublicRelationsRecord"> | $Enums.PRRequestStatus
    handledByAdminId?: StringFilter<"PublicRelationsRecord"> | string
    academyId?: StringFilter<"PublicRelationsRecord"> | string
    createdAt?: DateTimeFilter<"PublicRelationsRecord"> | Date | string
    updatedAt?: DateTimeFilter<"PublicRelationsRecord"> | Date | string
    handledByAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    responses?: PRResponseListRelationFilter
    events?: EventListRelationFilter
    posts?: PostListRelationFilter
    files?: FileListRelationFilter
    channels?: ChannelListRelationFilter
  }

  export type PublicRelationsRecordOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    senderName?: SortOrder
    senderContact?: SortOrder
    status?: SortOrder
    handledByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    handledByAdmin?: AdminOrderByWithRelationInput
    academy?: AcademyOrderByWithRelationInput
    responses?: PRResponseOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    channels?: ChannelOrderByRelationAggregateInput
  }

  export type PublicRelationsRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PublicRelationsRecordWhereInput | PublicRelationsRecordWhereInput[]
    OR?: PublicRelationsRecordWhereInput[]
    NOT?: PublicRelationsRecordWhereInput | PublicRelationsRecordWhereInput[]
    message?: StringFilter<"PublicRelationsRecord"> | string
    senderName?: StringFilter<"PublicRelationsRecord"> | string
    senderContact?: StringFilter<"PublicRelationsRecord"> | string
    status?: EnumPRRequestStatusFilter<"PublicRelationsRecord"> | $Enums.PRRequestStatus
    handledByAdminId?: StringFilter<"PublicRelationsRecord"> | string
    academyId?: StringFilter<"PublicRelationsRecord"> | string
    createdAt?: DateTimeFilter<"PublicRelationsRecord"> | Date | string
    updatedAt?: DateTimeFilter<"PublicRelationsRecord"> | Date | string
    handledByAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    responses?: PRResponseListRelationFilter
    events?: EventListRelationFilter
    posts?: PostListRelationFilter
    files?: FileListRelationFilter
    channels?: ChannelListRelationFilter
  }, "id">

  export type PublicRelationsRecordOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    senderName?: SortOrder
    senderContact?: SortOrder
    status?: SortOrder
    handledByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PublicRelationsRecordCountOrderByAggregateInput
    _max?: PublicRelationsRecordMaxOrderByAggregateInput
    _min?: PublicRelationsRecordMinOrderByAggregateInput
  }

  export type PublicRelationsRecordScalarWhereWithAggregatesInput = {
    AND?: PublicRelationsRecordScalarWhereWithAggregatesInput | PublicRelationsRecordScalarWhereWithAggregatesInput[]
    OR?: PublicRelationsRecordScalarWhereWithAggregatesInput[]
    NOT?: PublicRelationsRecordScalarWhereWithAggregatesInput | PublicRelationsRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PublicRelationsRecord"> | string
    message?: StringWithAggregatesFilter<"PublicRelationsRecord"> | string
    senderName?: StringWithAggregatesFilter<"PublicRelationsRecord"> | string
    senderContact?: StringWithAggregatesFilter<"PublicRelationsRecord"> | string
    status?: EnumPRRequestStatusWithAggregatesFilter<"PublicRelationsRecord"> | $Enums.PRRequestStatus
    handledByAdminId?: StringWithAggregatesFilter<"PublicRelationsRecord"> | string
    academyId?: StringWithAggregatesFilter<"PublicRelationsRecord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PublicRelationsRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PublicRelationsRecord"> | Date | string
  }

  export type PRResponseWhereInput = {
    AND?: PRResponseWhereInput | PRResponseWhereInput[]
    OR?: PRResponseWhereInput[]
    NOT?: PRResponseWhereInput | PRResponseWhereInput[]
    id?: StringFilter<"PRResponse"> | string
    response?: StringFilter<"PRResponse"> | string
    prRecordId?: StringFilter<"PRResponse"> | string
    respondedByAdminId?: StringFilter<"PRResponse"> | string
    createdAt?: DateTimeFilter<"PRResponse"> | Date | string
    prRecord?: XOR<PublicRelationsRecordScalarRelationFilter, PublicRelationsRecordWhereInput>
    respondedByAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type PRResponseOrderByWithRelationInput = {
    id?: SortOrder
    response?: SortOrder
    prRecordId?: SortOrder
    respondedByAdminId?: SortOrder
    createdAt?: SortOrder
    prRecord?: PublicRelationsRecordOrderByWithRelationInput
    respondedByAdmin?: AdminOrderByWithRelationInput
  }

  export type PRResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PRResponseWhereInput | PRResponseWhereInput[]
    OR?: PRResponseWhereInput[]
    NOT?: PRResponseWhereInput | PRResponseWhereInput[]
    response?: StringFilter<"PRResponse"> | string
    prRecordId?: StringFilter<"PRResponse"> | string
    respondedByAdminId?: StringFilter<"PRResponse"> | string
    createdAt?: DateTimeFilter<"PRResponse"> | Date | string
    prRecord?: XOR<PublicRelationsRecordScalarRelationFilter, PublicRelationsRecordWhereInput>
    respondedByAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type PRResponseOrderByWithAggregationInput = {
    id?: SortOrder
    response?: SortOrder
    prRecordId?: SortOrder
    respondedByAdminId?: SortOrder
    createdAt?: SortOrder
    _count?: PRResponseCountOrderByAggregateInput
    _max?: PRResponseMaxOrderByAggregateInput
    _min?: PRResponseMinOrderByAggregateInput
  }

  export type PRResponseScalarWhereWithAggregatesInput = {
    AND?: PRResponseScalarWhereWithAggregatesInput | PRResponseScalarWhereWithAggregatesInput[]
    OR?: PRResponseScalarWhereWithAggregatesInput[]
    NOT?: PRResponseScalarWhereWithAggregatesInput | PRResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PRResponse"> | string
    response?: StringWithAggregatesFilter<"PRResponse"> | string
    prRecordId?: StringWithAggregatesFilter<"PRResponse"> | string
    respondedByAdminId?: StringWithAggregatesFilter<"PRResponse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PRResponse"> | Date | string
  }

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    id?: StringFilter<"Meeting"> | string
    meetingTitle?: StringFilter<"Meeting"> | string
    meetingDate?: DateTimeFilter<"Meeting"> | Date | string
    location?: StringFilter<"Meeting"> | string
    notes?: StringNullableFilter<"Meeting"> | string | null
    createdByAdminId?: StringFilter<"Meeting"> | string
    academyId?: StringFilter<"Meeting"> | string
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    createdByAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    participants?: MeetingParticipantListRelationFilter
    files?: FileListRelationFilter
    reports?: ReportListRelationFilter
    channels?: ChannelListRelationFilter
  }

  export type MeetingOrderByWithRelationInput = {
    id?: SortOrder
    meetingTitle?: SortOrder
    meetingDate?: SortOrder
    location?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByAdmin?: AdminOrderByWithRelationInput
    academy?: AcademyOrderByWithRelationInput
    participants?: MeetingParticipantOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    channels?: ChannelOrderByRelationAggregateInput
  }

  export type MeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    meetingTitle?: StringFilter<"Meeting"> | string
    meetingDate?: DateTimeFilter<"Meeting"> | Date | string
    location?: StringFilter<"Meeting"> | string
    notes?: StringNullableFilter<"Meeting"> | string | null
    createdByAdminId?: StringFilter<"Meeting"> | string
    academyId?: StringFilter<"Meeting"> | string
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    createdByAdmin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    participants?: MeetingParticipantListRelationFilter
    files?: FileListRelationFilter
    reports?: ReportListRelationFilter
    channels?: ChannelListRelationFilter
  }, "id">

  export type MeetingOrderByWithAggregationInput = {
    id?: SortOrder
    meetingTitle?: SortOrder
    meetingDate?: SortOrder
    location?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MeetingCountOrderByAggregateInput
    _max?: MeetingMaxOrderByAggregateInput
    _min?: MeetingMinOrderByAggregateInput
  }

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    OR?: MeetingScalarWhereWithAggregatesInput[]
    NOT?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Meeting"> | string
    meetingTitle?: StringWithAggregatesFilter<"Meeting"> | string
    meetingDate?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    location?: StringWithAggregatesFilter<"Meeting"> | string
    notes?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    createdByAdminId?: StringWithAggregatesFilter<"Meeting"> | string
    academyId?: StringWithAggregatesFilter<"Meeting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
  }

  export type MeetingParticipantWhereInput = {
    AND?: MeetingParticipantWhereInput | MeetingParticipantWhereInput[]
    OR?: MeetingParticipantWhereInput[]
    NOT?: MeetingParticipantWhereInput | MeetingParticipantWhereInput[]
    id?: StringFilter<"MeetingParticipant"> | string
    meetingId?: StringFilter<"MeetingParticipant"> | string
    userId?: StringFilter<"MeetingParticipant"> | string
    isAttended?: BoolFilter<"MeetingParticipant"> | boolean
    createdAt?: DateTimeFilter<"MeetingParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingParticipant"> | Date | string
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MeetingParticipantOrderByWithRelationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    isAttended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meeting?: MeetingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MeetingParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeetingParticipantWhereInput | MeetingParticipantWhereInput[]
    OR?: MeetingParticipantWhereInput[]
    NOT?: MeetingParticipantWhereInput | MeetingParticipantWhereInput[]
    meetingId?: StringFilter<"MeetingParticipant"> | string
    userId?: StringFilter<"MeetingParticipant"> | string
    isAttended?: BoolFilter<"MeetingParticipant"> | boolean
    createdAt?: DateTimeFilter<"MeetingParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingParticipant"> | Date | string
    meeting?: XOR<MeetingScalarRelationFilter, MeetingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MeetingParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    isAttended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MeetingParticipantCountOrderByAggregateInput
    _max?: MeetingParticipantMaxOrderByAggregateInput
    _min?: MeetingParticipantMinOrderByAggregateInput
  }

  export type MeetingParticipantScalarWhereWithAggregatesInput = {
    AND?: MeetingParticipantScalarWhereWithAggregatesInput | MeetingParticipantScalarWhereWithAggregatesInput[]
    OR?: MeetingParticipantScalarWhereWithAggregatesInput[]
    NOT?: MeetingParticipantScalarWhereWithAggregatesInput | MeetingParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MeetingParticipant"> | string
    meetingId?: StringWithAggregatesFilter<"MeetingParticipant"> | string
    userId?: StringWithAggregatesFilter<"MeetingParticipant"> | string
    isAttended?: BoolWithAggregatesFilter<"MeetingParticipant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MeetingParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MeetingParticipant"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    isActive?: BoolFilter<"Permission"> | boolean
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    AdminRole?: AdminRoleListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    AdminRole?: AdminRoleOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    isActive?: BoolFilter<"Permission"> | boolean
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    AdminRole?: AdminRoleListRelationFilter
  }, "id">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    name?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    isActive?: BoolWithAggregatesFilter<"Permission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type AdminRoleWhereInput = {
    AND?: AdminRoleWhereInput | AdminRoleWhereInput[]
    OR?: AdminRoleWhereInput[]
    NOT?: AdminRoleWhereInput | AdminRoleWhereInput[]
    id?: StringFilter<"AdminRole"> | string
    name?: EnumAdminRoleTypeFilter<"AdminRole"> | $Enums.AdminRoleType
    description?: StringNullableFilter<"AdminRole"> | string | null
    adminId?: StringFilter<"AdminRole"> | string
    createdAt?: DateTimeFilter<"AdminRole"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRole"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    assignments?: AdminAssignmentListRelationFilter
    permissions?: PermissionListRelationFilter
    reports?: ReportListRelationFilter
    files?: FileListRelationFilter
    events?: EventListRelationFilter
    channels?: ChannelListRelationFilter
  }

  export type AdminRoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    assignments?: AdminAssignmentOrderByRelationAggregateInput
    permissions?: PermissionOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    channels?: ChannelOrderByRelationAggregateInput
  }

  export type AdminRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminRoleWhereInput | AdminRoleWhereInput[]
    OR?: AdminRoleWhereInput[]
    NOT?: AdminRoleWhereInput | AdminRoleWhereInput[]
    name?: EnumAdminRoleTypeFilter<"AdminRole"> | $Enums.AdminRoleType
    description?: StringNullableFilter<"AdminRole"> | string | null
    adminId?: StringFilter<"AdminRole"> | string
    createdAt?: DateTimeFilter<"AdminRole"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRole"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    assignments?: AdminAssignmentListRelationFilter
    permissions?: PermissionListRelationFilter
    reports?: ReportListRelationFilter
    files?: FileListRelationFilter
    events?: EventListRelationFilter
    channels?: ChannelListRelationFilter
  }, "id">

  export type AdminRoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminRoleCountOrderByAggregateInput
    _max?: AdminRoleMaxOrderByAggregateInput
    _min?: AdminRoleMinOrderByAggregateInput
  }

  export type AdminRoleScalarWhereWithAggregatesInput = {
    AND?: AdminRoleScalarWhereWithAggregatesInput | AdminRoleScalarWhereWithAggregatesInput[]
    OR?: AdminRoleScalarWhereWithAggregatesInput[]
    NOT?: AdminRoleScalarWhereWithAggregatesInput | AdminRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminRole"> | string
    name?: EnumAdminRoleTypeWithAggregatesFilter<"AdminRole"> | $Enums.AdminRoleType
    description?: StringNullableWithAggregatesFilter<"AdminRole"> | string | null
    adminId?: StringWithAggregatesFilter<"AdminRole"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminRole"> | Date | string
  }

  export type AdminAssignmentWhereInput = {
    AND?: AdminAssignmentWhereInput | AdminAssignmentWhereInput[]
    OR?: AdminAssignmentWhereInput[]
    NOT?: AdminAssignmentWhereInput | AdminAssignmentWhereInput[]
    id?: StringFilter<"AdminAssignment"> | string
    adminId?: StringFilter<"AdminAssignment"> | string
    roleId?: StringFilter<"AdminAssignment"> | string
    startDate?: DateTimeFilter<"AdminAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"AdminAssignment"> | Date | string | null
    status?: StringFilter<"AdminAssignment"> | string
    createdAt?: DateTimeFilter<"AdminAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"AdminAssignment"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    role?: XOR<AdminRoleScalarRelationFilter, AdminRoleWhereInput>
  }

  export type AdminAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    role?: AdminRoleOrderByWithRelationInput
  }

  export type AdminAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAssignmentWhereInput | AdminAssignmentWhereInput[]
    OR?: AdminAssignmentWhereInput[]
    NOT?: AdminAssignmentWhereInput | AdminAssignmentWhereInput[]
    adminId?: StringFilter<"AdminAssignment"> | string
    roleId?: StringFilter<"AdminAssignment"> | string
    startDate?: DateTimeFilter<"AdminAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"AdminAssignment"> | Date | string | null
    status?: StringFilter<"AdminAssignment"> | string
    createdAt?: DateTimeFilter<"AdminAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"AdminAssignment"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    role?: XOR<AdminRoleScalarRelationFilter, AdminRoleWhereInput>
  }, "id">

  export type AdminAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminAssignmentCountOrderByAggregateInput
    _max?: AdminAssignmentMaxOrderByAggregateInput
    _min?: AdminAssignmentMinOrderByAggregateInput
  }

  export type AdminAssignmentScalarWhereWithAggregatesInput = {
    AND?: AdminAssignmentScalarWhereWithAggregatesInput | AdminAssignmentScalarWhereWithAggregatesInput[]
    OR?: AdminAssignmentScalarWhereWithAggregatesInput[]
    NOT?: AdminAssignmentScalarWhereWithAggregatesInput | AdminAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAssignment"> | string
    adminId?: StringWithAggregatesFilter<"AdminAssignment"> | string
    roleId?: StringWithAggregatesFilter<"AdminAssignment"> | string
    startDate?: DateTimeWithAggregatesFilter<"AdminAssignment"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"AdminAssignment"> | Date | string | null
    status?: StringWithAggregatesFilter<"AdminAssignment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminAssignment"> | Date | string
  }

  export type LegalCaseWhereInput = {
    AND?: LegalCaseWhereInput | LegalCaseWhereInput[]
    OR?: LegalCaseWhereInput[]
    NOT?: LegalCaseWhereInput | LegalCaseWhereInput[]
    id?: StringFilter<"LegalCase"> | string
    caseTitle?: StringFilter<"LegalCase"> | string
    caseType?: EnumLegalCaseTypeFilter<"LegalCase"> | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFilter<"LegalCase"> | $Enums.LegalCaseStatus
    description?: StringFilter<"LegalCase"> | string
    courtDate?: DateTimeNullableFilter<"LegalCase"> | Date | string | null
    assignedLawyerId?: StringFilter<"LegalCase"> | string
    academyId?: StringFilter<"LegalCase"> | string
    relatedUserId?: StringNullableFilter<"LegalCase"> | string | null
    createdAt?: DateTimeFilter<"LegalCase"> | Date | string
    updatedAt?: DateTimeFilter<"LegalCase"> | Date | string
    assignedLawyer?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    relatedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    files?: FileListRelationFilter
    reports?: ReportListRelationFilter
    events?: EventListRelationFilter
    channels?: ChannelListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type LegalCaseOrderByWithRelationInput = {
    id?: SortOrder
    caseTitle?: SortOrder
    caseType?: SortOrder
    status?: SortOrder
    description?: SortOrder
    courtDate?: SortOrderInput | SortOrder
    assignedLawyerId?: SortOrder
    academyId?: SortOrder
    relatedUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedLawyer?: AdminOrderByWithRelationInput
    academy?: AcademyOrderByWithRelationInput
    relatedUser?: UserOrderByWithRelationInput
    files?: FileOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    channels?: ChannelOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type LegalCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LegalCaseWhereInput | LegalCaseWhereInput[]
    OR?: LegalCaseWhereInput[]
    NOT?: LegalCaseWhereInput | LegalCaseWhereInput[]
    caseTitle?: StringFilter<"LegalCase"> | string
    caseType?: EnumLegalCaseTypeFilter<"LegalCase"> | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFilter<"LegalCase"> | $Enums.LegalCaseStatus
    description?: StringFilter<"LegalCase"> | string
    courtDate?: DateTimeNullableFilter<"LegalCase"> | Date | string | null
    assignedLawyerId?: StringFilter<"LegalCase"> | string
    academyId?: StringFilter<"LegalCase"> | string
    relatedUserId?: StringNullableFilter<"LegalCase"> | string | null
    createdAt?: DateTimeFilter<"LegalCase"> | Date | string
    updatedAt?: DateTimeFilter<"LegalCase"> | Date | string
    assignedLawyer?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    academy?: XOR<AcademyScalarRelationFilter, AcademyWhereInput>
    relatedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    files?: FileListRelationFilter
    reports?: ReportListRelationFilter
    events?: EventListRelationFilter
    channels?: ChannelListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id">

  export type LegalCaseOrderByWithAggregationInput = {
    id?: SortOrder
    caseTitle?: SortOrder
    caseType?: SortOrder
    status?: SortOrder
    description?: SortOrder
    courtDate?: SortOrderInput | SortOrder
    assignedLawyerId?: SortOrder
    academyId?: SortOrder
    relatedUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LegalCaseCountOrderByAggregateInput
    _max?: LegalCaseMaxOrderByAggregateInput
    _min?: LegalCaseMinOrderByAggregateInput
  }

  export type LegalCaseScalarWhereWithAggregatesInput = {
    AND?: LegalCaseScalarWhereWithAggregatesInput | LegalCaseScalarWhereWithAggregatesInput[]
    OR?: LegalCaseScalarWhereWithAggregatesInput[]
    NOT?: LegalCaseScalarWhereWithAggregatesInput | LegalCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LegalCase"> | string
    caseTitle?: StringWithAggregatesFilter<"LegalCase"> | string
    caseType?: EnumLegalCaseTypeWithAggregatesFilter<"LegalCase"> | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusWithAggregatesFilter<"LegalCase"> | $Enums.LegalCaseStatus
    description?: StringWithAggregatesFilter<"LegalCase"> | string
    courtDate?: DateTimeNullableWithAggregatesFilter<"LegalCase"> | Date | string | null
    assignedLawyerId?: StringWithAggregatesFilter<"LegalCase"> | string
    academyId?: StringWithAggregatesFilter<"LegalCase"> | string
    relatedUserId?: StringNullableWithAggregatesFilter<"LegalCase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LegalCase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LegalCase"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LoginHistoryCreateInput = {
    id?: string
    success?: boolean
    ip?: string | null
    device?: $Enums.LoginDevice | null
    location?: string | null
    browser?: string | null
    os?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLoginHistoryInput
  }

  export type LoginHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    success?: boolean
    ip?: string | null
    device?: $Enums.LoginDevice | null
    location?: string | null
    browser?: string | null
    os?: string | null
    createdAt?: Date | string
  }

  export type LoginHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableEnumLoginDeviceFieldUpdateOperationsInput | $Enums.LoginDevice | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLoginHistoryNestedInput
  }

  export type LoginHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableEnumLoginDeviceFieldUpdateOperationsInput | $Enums.LoginDevice | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryCreateManyInput = {
    id?: string
    userId: string
    success?: boolean
    ip?: string | null
    device?: $Enums.LoginDevice | null
    location?: string | null
    browser?: string | null
    os?: string | null
    createdAt?: Date | string
  }

  export type LoginHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableEnumLoginDeviceFieldUpdateOperationsInput | $Enums.LoginDevice | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableEnumLoginDeviceFieldUpdateOperationsInput | $Enums.LoginDevice | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorCreateInput = {
    id?: string
    email?: boolean
    sms?: boolean
    authenticator?: boolean
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTwoFactorInput
  }

  export type TwoFactorUncheckedCreateInput = {
    id?: string
    userId: string
    email?: boolean
    sms?: boolean
    authenticator?: boolean
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: BoolFieldUpdateOperationsInput | boolean
    sms?: BoolFieldUpdateOperationsInput | boolean
    authenticator?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTwoFactorNestedInput
  }

  export type TwoFactorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: BoolFieldUpdateOperationsInput | boolean
    sms?: BoolFieldUpdateOperationsInput | boolean
    authenticator?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorCreateManyInput = {
    id?: string
    userId: string
    email?: boolean
    sms?: boolean
    authenticator?: boolean
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: BoolFieldUpdateOperationsInput | boolean
    sms?: BoolFieldUpdateOperationsInput | boolean
    authenticator?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: BoolFieldUpdateOperationsInput | boolean
    sms?: BoolFieldUpdateOperationsInput | boolean
    authenticator?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    bio?: string | null
    phone?: string | null
    address?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    bio?: string | null
    phone?: string | null
    address?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    bio?: string | null
    phone?: string | null
    address?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserAcademyCEOCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserAcademyCEOInput
    academy: AcademyCreateNestedOneWithoutCeosInput
  }

  export type UserAcademyCEOUncheckedCreateInput = {
    id?: string
    userId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAcademyCEOUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserAcademyCEONestedInput
    academy?: AcademyUpdateOneRequiredWithoutCeosNestedInput
  }

  export type UserAcademyCEOUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAcademyCEOCreateManyInput = {
    id?: string
    userId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAcademyCEOUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAcademyCEOUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademyCreateInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOCreateNestedManyWithoutAcademyInput
    courses?: CourseCreateNestedManyWithoutAcademyInput
    instructors?: InstructorCreateNestedManyWithoutAcademyInput
    events?: EventCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOUncheckedCreateNestedManyWithoutAcademyInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademyInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutAcademyInput
    events?: EventUncheckedCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryUncheckedCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUpdateManyWithoutAcademyNestedInput
    courses?: CourseUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUpdateManyWithoutAcademyNestedInput
    events?: EventUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUncheckedUpdateManyWithoutAcademyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutAcademyNestedInput
    events?: EventUncheckedUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUncheckedUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorCreateInput = {
    id?: string
    user: UserCreateNestedOneWithoutInstructorInput
    academy: AcademyCreateNestedOneWithoutInstructorsInput
    courses?: CourseCreateNestedManyWithoutInstructorsInput
  }

  export type InstructorUncheckedCreateInput = {
    id?: string
    userId: string
    academyId: string
    courses?: CourseUncheckedCreateNestedManyWithoutInstructorsInput
  }

  export type InstructorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInstructorNestedInput
    academy?: AcademyUpdateOneRequiredWithoutInstructorsNestedInput
    courses?: CourseUpdateManyWithoutInstructorsNestedInput
  }

  export type InstructorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    courses?: CourseUncheckedUpdateManyWithoutInstructorsNestedInput
  }

  export type InstructorCreateManyInput = {
    id?: string
    userId: string
    academyId: string
  }

  export type InstructorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type InstructorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    description: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    academy: AcademyCreateNestedOneWithoutCoursesInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    instructors?: InstructorCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCourseInput
    Path?: PathCreateNestedManyWithoutCoursesInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    academyId: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCourseInput
    Path?: PathUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    academy?: AcademyUpdateOneRequiredWithoutCoursesNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCourseNestedInput
    Path?: PathUpdateManyWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCourseNestedInput
    Path?: PathUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    description: string
    academyId: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
  }

  export type PathCreateInput = {
    id?: string
    title: string
    description?: string | null
    level: string
    completedTasks?: number
    remainingTime?: number
    studyTime?: number
    totalTasks?: number
    progress?: number
    engagement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: MilestoneCreateNestedManyWithoutPathInput
    courses?: CourseCreateNestedManyWithoutPathInput
    peers?: UserCreateNestedManyWithoutPathInput
  }

  export type PathUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    level: string
    completedTasks?: number
    remainingTime?: number
    studyTime?: number
    totalTasks?: number
    progress?: number
    engagement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: MilestoneUncheckedCreateNestedManyWithoutPathInput
    courses?: CourseUncheckedCreateNestedManyWithoutPathInput
    peers?: UserUncheckedCreateNestedManyWithoutPathInput
  }

  export type PathUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUpdateManyWithoutPathNestedInput
    courses?: CourseUpdateManyWithoutPathNestedInput
    peers?: UserUpdateManyWithoutPathNestedInput
  }

  export type PathUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUncheckedUpdateManyWithoutPathNestedInput
    courses?: CourseUncheckedUpdateManyWithoutPathNestedInput
    peers?: UserUncheckedUpdateManyWithoutPathNestedInput
  }

  export type PathCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    level: string
    completedTasks?: number
    remainingTime?: number
    studyTime?: number
    totalTasks?: number
    progress?: number
    engagement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PathUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    createdAt?: Date | string
    path: PathCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    pathId: string
    createdAt?: Date | string
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    path?: PathUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    pathId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    pathId: string
    createdAt?: Date | string
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    pathId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateInput = {
    id?: string
    title: string
    content: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutLessonsInput
    files?: FileCreateNestedManyWithoutLessonInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    completedBy?: UserCreateNestedManyWithoutLessonInput
    Attendance?: AttendanceCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    courseId: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLessonInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    completedBy?: UserUncheckedCreateNestedManyWithoutLessonInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutLessonsNestedInput
    files?: FileUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    completedBy?: UserUpdateManyWithoutLessonNestedInput
    Attendance?: AttendanceUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    completedBy?: UserUncheckedUpdateManyWithoutLessonNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    title: string
    content: string
    courseId: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    lesson?: LessonCreateNestedOneWithoutFilesInput
    accountingEntry?: AccountingEntryCreateNestedOneWithoutFilesInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutFilesInput
    meeting?: MeetingCreateNestedOneWithoutFilesInput
    adminRole?: AdminRoleCreateNestedOneWithoutFilesInput
    legalCase?: LegalCaseCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    accountingEntryId?: string | null
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneWithoutFilesNestedInput
    accountingEntry?: AccountingEntryUpdateOneWithoutFilesNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutFilesNestedInput
    meeting?: MeetingUpdateOneWithoutFilesNestedInput
    adminRole?: AdminRoleUpdateOneWithoutFilesNestedInput
    legalCase?: LegalCaseUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateManyInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    accountingEntryId?: string | null
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateInput = {
    id?: string
    progress?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEnrollmentsInput
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    progress?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    progress?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutQuizzesInput
    questions?: QuestionCreateNestedManyWithoutQuizInput
    submissions?: SubmissionCreateNestedManyWithoutQuizInput
    Course?: CourseCreateNestedManyWithoutQuizzesInput
  }

  export type QuizUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    lessonId: string
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutQuizInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutQuizInput
    Course?: CourseUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type QuizUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
    questions?: QuestionUpdateManyWithoutQuizNestedInput
    submissions?: SubmissionUpdateManyWithoutQuizNestedInput
    Course?: CourseUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: StringFieldUpdateOperationsInput | string
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutQuizNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutQuizNestedInput
    Course?: CourseUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    lessonId: string
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: StringFieldUpdateOperationsInput | string
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    id?: string
    text: string
    type: string
    isMultiple?: boolean
    points: number
    isAnswered?: boolean
    createdAt?: Date | string
    options?: OptionCreateNestedManyWithoutQuestionInput
    quiz: QuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    text: string
    type: string
    isMultiple?: boolean
    points: number
    isAnswered?: boolean
    quizId: string
    createdAt?: Date | string
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    isAnswered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OptionUpdateManyWithoutQuestionNestedInput
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    isAnswered?: BoolFieldUpdateOperationsInput | boolean
    quizId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: string
    text: string
    type: string
    isMultiple?: boolean
    points: number
    isAnswered?: boolean
    quizId: string
    createdAt?: Date | string
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    isAnswered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    isAnswered?: BoolFieldUpdateOperationsInput | boolean
    quizId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionCreateInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutOptionsInput
  }

  export type OptionUncheckedCreateInput = {
    id?: string
    questionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type OptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionCreateManyInput = {
    id?: string
    questionId: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionCreateInput = {
    id?: string
    answers?: SubmissionCreateanswersInput | InputJsonValue[]
    score?: number | null
    feedback?: string | null
    passed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubmissionInput
    quiz: QuizCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateInput = {
    id?: string
    userId: string
    quizId: string
    answers?: SubmissionCreateanswersInput | InputJsonValue[]
    score?: number | null
    feedback?: string | null
    passed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: SubmissionUpdateanswersInput | InputJsonValue[]
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubmissionNestedInput
    quiz?: QuizUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    answers?: SubmissionUpdateanswersInput | InputJsonValue[]
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionCreateManyInput = {
    id?: string
    userId: string
    quizId: string
    answers?: SubmissionCreateanswersInput | InputJsonValue[]
    score?: number | null
    feedback?: string | null
    passed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: SubmissionUpdateanswersInput | InputJsonValue[]
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    answers?: SubmissionUpdateanswersInput | InputJsonValue[]
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    type: string
    value: JsonNullValueInput | InputJsonValue
    isNew?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    value: JsonNullValueInput | InputJsonValue
    isNew?: boolean
    createdAt?: Date | string
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isNew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isNew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateManyInput = {
    id?: string
    userId: string
    type: string
    value: JsonNullValueInput | InputJsonValue
    isNew?: boolean
    createdAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isNew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isNew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type?: $Enums.NotificationType
    message: string
    isImportant?: boolean
    urgent?: boolean
    title: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type?: $Enums.NotificationType
    message: string
    isImportant?: boolean
    urgent?: boolean
    title: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type?: $Enums.NotificationType
    message: string
    isImportant?: boolean
    urgent?: boolean
    title: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateInput = {
    id?: string
    assignments?: boolean
    grades?: boolean
    messages?: boolean
    achievements?: boolean
    urgent?: boolean
    email?: boolean
    push?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationSettingsInput
  }

  export type NotificationSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    assignments?: boolean
    grades?: boolean
    messages?: boolean
    achievements?: boolean
    urgent?: boolean
    email?: boolean
    push?: boolean
    createdAt?: Date | string
  }

  export type NotificationSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignments?: BoolFieldUpdateOperationsInput | boolean
    grades?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    achievements?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    push?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationSettingsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignments?: BoolFieldUpdateOperationsInput | boolean
    grades?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    achievements?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    push?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateManyInput = {
    id?: string
    userId: string
    assignments?: boolean
    grades?: boolean
    messages?: boolean
    achievements?: boolean
    urgent?: boolean
    email?: boolean
    push?: boolean
    createdAt?: Date | string
  }

  export type NotificationSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignments?: BoolFieldUpdateOperationsInput | boolean
    grades?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    achievements?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    push?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    assignments?: BoolFieldUpdateOperationsInput | boolean
    grades?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    achievements?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    push?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    sender: UserCreateNestedOneWithoutMessagesInput
    Channel?: ChannelCreateNestedManyWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    Channel?: ChannelUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
    Channel?: ChannelUpdateManyWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    Channel?: ChannelUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostCreateInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    author: UserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    Group?: GroupCreateNestedManyWithoutPostsInput
    Community?: CommunityCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionCreateNestedManyWithoutPostInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    authorId: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    publicRelationsRecordId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    Group?: GroupUncheckedCreateNestedManyWithoutPostsInput
    Community?: CommunityUncheckedCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    Group?: GroupUpdateManyWithoutPostsNestedInput
    Community?: CommunityUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUpdateManyWithoutPostNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    publicRelationsRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Group?: GroupUncheckedUpdateManyWithoutPostsNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    authorId: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    publicRelationsRecordId?: string | null
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    publicRelationsRecordId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    content: string
    createdAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutGroupsInput
    posts?: PostCreateNestedManyWithoutGroupInput
    admin: AdminCreateNestedOneWithoutGroupInput
    Community?: CommunityCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    adminId: string
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutGroupsInput
    posts?: PostUncheckedCreateNestedManyWithoutGroupInput
    Community?: CommunityUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutGroupsNestedInput
    posts?: PostUpdateManyWithoutGroupNestedInput
    admin?: AdminUpdateOneRequiredWithoutGroupNestedInput
    Community?: CommunityUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutGroupsNestedInput
    posts?: PostUncheckedUpdateManyWithoutGroupNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupCreateManyInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    adminId: string
    createdAt?: Date | string
  }

  export type GroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
    Group?: GroupCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    Group?: GroupUncheckedCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordUncheckedCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseUncheckedCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseUncheckedCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    Group?: GroupUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Group?: GroupUncheckedUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUncheckedUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUncheckedUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutChannelsInput
    owner: OwnerCreateNestedOneWithoutChannelInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutChannelsInput
    meeting?: MeetingCreateNestedOneWithoutChannelsInput
    adminRole?: AdminRoleCreateNestedOneWithoutChannelsInput
    legalCase?: LegalCaseCreateNestedOneWithoutChannelsInput
  }

  export type ChannelUncheckedCreateInput = {
    id?: string
    name: string
    ownerId: string
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutChannelsInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutChannelsNestedInput
    owner?: OwnerUpdateOneRequiredWithoutChannelNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutChannelsNestedInput
    meeting?: MeetingUpdateOneWithoutChannelsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutChannelsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutChannelsNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelCreateManyInput = {
    id?: string
    name: string
    ownerId: string
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOwnerInput
    Channel?: ChannelCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    Channel?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOwnerNestedInput
    Channel?: ChannelUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Channel?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerCreateManyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type OwnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateInput = {
    id?: string
    type: string
    itemId: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    itemId: string
    createdAt?: Date | string
  }

  export type BookmarkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateManyInput = {
    id?: string
    userId: string
    type: string
    itemId: string
    createdAt?: Date | string
  }

  export type BookmarkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    academy: AcademyCreateNestedOneWithoutEventsInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutEventsInput
    adminRole?: AdminRoleCreateNestedOneWithoutEventsInput
    legalCase?: LegalCaseCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    academyId: string
    prRecordId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academy?: AcademyUpdateOneRequiredWithoutEventsNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutEventsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutEventsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    academyId: string
    prRecordId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    status: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: UserCreateNestedOneWithoutAttendanceInput
    lesson: LessonCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    studentId: string
    lessonId: string
    status: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutAttendanceNestedInput
    lesson?: LessonUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    studentId: string
    lessonId: string
    status: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentInput
    legalCase?: LegalCaseCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentNestedInput
    legalCase?: LegalCaseUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    amount: number
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReportInput
    accountingEntry?: AccountingEntryCreateNestedOneWithoutReportsInput
    meeting?: MeetingCreateNestedOneWithoutReportsInput
    adminRole?: AdminRoleCreateNestedOneWithoutReportsInput
    legalCase?: LegalCaseCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    userId: string
    accountingEntryId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportNestedInput
    accountingEntry?: AccountingEntryUpdateOneWithoutReportsNestedInput
    meeting?: MeetingUpdateOneWithoutReportsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutReportsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    userId: string
    accountingEntryId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateManyInput = {
    id?: string
    userId: string
    title: string
    description?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    notes: string
    title: string
    description?: string | null
    url?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCertificateInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    phone: string
    notes: string
    userId: string
    title: string
    description?: string | null
    url?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
  }

  export type CertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateManyInput = {
    id?: string
    name: string
    address: string
    phone: string
    notes: string
    userId: string
    title: string
    description?: string | null
    url?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
  }

  export type CertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCreateInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupCreateNestedManyWithoutCommunityInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCommunityInput
    participants?: UserCreateNestedManyWithoutCommunityInput
    posts?: PostCreateNestedManyWithoutCommunityInput
    discussions?: DiscussionCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupUncheckedCreateNestedManyWithoutCommunityInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCommunityInput
    participants?: UserUncheckedCreateNestedManyWithoutCommunityInput
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
    discussions?: DiscussionUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUpdateManyWithoutCommunityNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCommunityNestedInput
    participants?: UserUpdateManyWithoutCommunityNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
    discussions?: DiscussionUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUncheckedUpdateManyWithoutCommunityNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCommunityNestedInput
    participants?: UserUncheckedUpdateManyWithoutCommunityNestedInput
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    discussions?: DiscussionUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateManyInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutDiscussionsInput
    post?: PostCreateNestedOneWithoutDiscussionInput
  }

  export type DiscussionUncheckedCreateInput = {
    id?: string
    communityId: string
    postId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscussionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutDiscussionsNestedInput
    post?: PostUpdateOneWithoutDiscussionNestedInput
  }

  export type DiscussionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionCreateManyInput = {
    id?: string
    communityId: string
    postId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscussionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveRoomCreateInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutLiveRoomInput
    User?: UserCreateNestedManyWithoutLiveRoomInput
    course?: CourseCreateNestedOneWithoutLiveRoomInput
  }

  export type LiveRoomUncheckedCreateInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    communityId: string
    courseId?: string | null
    User?: UserUncheckedCreateNestedManyWithoutLiveRoomInput
  }

  export type LiveRoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutLiveRoomNestedInput
    User?: UserUpdateManyWithoutLiveRoomNestedInput
    course?: CourseUpdateOneWithoutLiveRoomNestedInput
  }

  export type LiveRoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUncheckedUpdateManyWithoutLiveRoomNestedInput
  }

  export type LiveRoomCreateManyInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    communityId: string
    courseId?: string | null
  }

  export type LiveRoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveRoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountingEntryCreateInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutAccountingEntriesInput
    academy: AcademyCreateNestedOneWithoutAccountingEntryInput
    invoice?: InvoiceCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentCreateNestedOneWithoutAccountingEntryInput
    files?: FileCreateNestedManyWithoutAccountingEntryInput
    reports?: ReportCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryUncheckedCreateInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentUncheckedCreateNestedOneWithoutAccountingEntryInput
    files?: FileUncheckedCreateNestedManyWithoutAccountingEntryInput
    reports?: ReportUncheckedCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutAccountingEntriesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutAccountingEntryNestedInput
    invoice?: InvoiceUpdateOneWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUpdateManyWithoutAccountingEntryNestedInput
    reports?: ReportUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AccountingEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUncheckedUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUncheckedUpdateManyWithoutAccountingEntryNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AccountingEntryCreateManyInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountingEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountingEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    amount: number
    description: string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingEntry: AccountingEntryCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    amount: number
    description: string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    accountingEntryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingEntry?: AccountingEntryUpdateOneRequiredWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    accountingEntryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    amount: number
    description: string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    accountingEntryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    accountingEntryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentCreateInput = {
    id?: string
    amount: number
    month: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutSalaryPaymentInput
    accountingEntry: AccountingEntryCreateNestedOneWithoutSalaryPaymentInput
  }

  export type SalaryPaymentUncheckedCreateInput = {
    id?: string
    employeeId: string
    amount: number
    month: number
    year: number
    accountingEntryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutSalaryPaymentNestedInput
    accountingEntry?: AccountingEntryUpdateOneRequiredWithoutSalaryPaymentNestedInput
  }

  export type SalaryPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    accountingEntryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentCreateManyInput = {
    id?: string
    employeeId: string
    amount: number
    month: number
    year: number
    accountingEntryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    accountingEntryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicRelationsRecordCreateInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    handledByAdmin: AdminCreateNestedOneWithoutPrRecordsInput
    academy: AcademyCreateNestedOneWithoutPublicRelationsRecordInput
    responses?: PRResponseCreateNestedManyWithoutPrRecordInput
    events?: EventCreateNestedManyWithoutPrRecordInput
    posts?: PostCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileCreateNestedManyWithoutPrRecordInput
    channels?: ChannelCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordUncheckedCreateInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    handledByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: PRResponseUncheckedCreateNestedManyWithoutPrRecordInput
    events?: EventUncheckedCreateNestedManyWithoutPrRecordInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileUncheckedCreateNestedManyWithoutPrRecordInput
    channels?: ChannelUncheckedCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledByAdmin?: AdminUpdateOneRequiredWithoutPrRecordsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutPublicRelationsRecordNestedInput
    responses?: PRResponseUpdateManyWithoutPrRecordNestedInput
    events?: EventUpdateManyWithoutPrRecordNestedInput
    posts?: PostUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    handledByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PRResponseUncheckedUpdateManyWithoutPrRecordNestedInput
    events?: EventUncheckedUpdateManyWithoutPrRecordNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUncheckedUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordCreateManyInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    handledByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicRelationsRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicRelationsRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    handledByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PRResponseCreateInput = {
    id?: string
    response: string
    createdAt?: Date | string
    prRecord: PublicRelationsRecordCreateNestedOneWithoutResponsesInput
    respondedByAdmin: AdminCreateNestedOneWithoutPrResponsesInput
  }

  export type PRResponseUncheckedCreateInput = {
    id?: string
    response: string
    prRecordId: string
    respondedByAdminId: string
    createdAt?: Date | string
  }

  export type PRResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prRecord?: PublicRelationsRecordUpdateOneRequiredWithoutResponsesNestedInput
    respondedByAdmin?: AdminUpdateOneRequiredWithoutPrResponsesNestedInput
  }

  export type PRResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    prRecordId?: StringFieldUpdateOperationsInput | string
    respondedByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PRResponseCreateManyInput = {
    id?: string
    response: string
    prRecordId: string
    respondedByAdminId: string
    createdAt?: Date | string
  }

  export type PRResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PRResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    prRecordId?: StringFieldUpdateOperationsInput | string
    respondedByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingCreateInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutMeetingsInput
    academy: AcademyCreateNestedOneWithoutMeetingInput
    participants?: MeetingParticipantCreateNestedManyWithoutMeetingInput
    files?: FileCreateNestedManyWithoutMeetingInput
    reports?: ReportCreateNestedManyWithoutMeetingInput
    channels?: ChannelCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: MeetingParticipantUncheckedCreateNestedManyWithoutMeetingInput
    files?: FileUncheckedCreateNestedManyWithoutMeetingInput
    reports?: ReportUncheckedCreateNestedManyWithoutMeetingInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutMeetingsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutMeetingNestedInput
    participants?: MeetingParticipantUpdateManyWithoutMeetingNestedInput
    files?: FileUpdateManyWithoutMeetingNestedInput
    reports?: ReportUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MeetingParticipantUncheckedUpdateManyWithoutMeetingNestedInput
    files?: FileUncheckedUpdateManyWithoutMeetingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingCreateManyInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingParticipantCreateInput = {
    id?: string
    isAttended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutMeetingParticipantInput
  }

  export type MeetingParticipantUncheckedCreateInput = {
    id?: string
    meetingId: string
    userId: string
    isAttended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAttended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutMeetingParticipantNestedInput
  }

  export type MeetingParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isAttended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingParticipantCreateManyInput = {
    id?: string
    meetingId: string
    userId: string
    isAttended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAttended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isAttended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    AdminRole?: AdminRoleCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    AdminRole?: AdminRoleUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AdminRole?: AdminRoleUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AdminRole?: AdminRoleUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleCreateInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutAdminRoleInput
    assignments?: AdminAssignmentCreateNestedManyWithoutRoleInput
    permissions?: PermissionCreateNestedManyWithoutAdminRoleInput
    reports?: ReportCreateNestedManyWithoutAdminRoleInput
    files?: FileCreateNestedManyWithoutAdminRoleInput
    events?: EventCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleUncheckedCreateInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutRoleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutAdminRoleInput
    reports?: ReportUncheckedCreateNestedManyWithoutAdminRoleInput
    files?: FileUncheckedCreateNestedManyWithoutAdminRoleInput
    events?: EventUncheckedCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelUncheckedCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutAdminRoleNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUpdateManyWithoutAdminRoleNestedInput
    files?: FileUpdateManyWithoutAdminRoleNestedInput
    events?: EventUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAdminRoleNestedInput
    files?: FileUncheckedUpdateManyWithoutAdminRoleNestedInput
    events?: EventUncheckedUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleCreateManyInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAssignmentCreateInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutAssignmentsInput
    role: AdminRoleCreateNestedOneWithoutAssignmentsInput
  }

  export type AdminAssignmentUncheckedCreateInput = {
    id?: string
    adminId: string
    roleId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutAssignmentsNestedInput
    role?: AdminRoleUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AdminAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAssignmentCreateManyInput = {
    id?: string
    adminId: string
    roleId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalCaseCreateInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedLawyer: AdminCreateNestedOneWithoutLegalCasesInput
    academy: AcademyCreateNestedOneWithoutLegalCaseInput
    relatedUser?: UserCreateNestedOneWithoutLegalCaseInput
    files?: FileCreateNestedManyWithoutLegalCaseInput
    reports?: ReportCreateNestedManyWithoutLegalCaseInput
    events?: EventCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseUncheckedCreateInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    academyId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLegalCaseInput
    reports?: ReportUncheckedCreateNestedManyWithoutLegalCaseInput
    events?: EventUncheckedCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelUncheckedCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedLawyer?: AdminUpdateOneRequiredWithoutLegalCasesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutLegalCaseNestedInput
    relatedUser?: UserUpdateOneWithoutLegalCaseNestedInput
    files?: FileUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUpdateManyWithoutLegalCaseNestedInput
    events?: EventUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLegalCaseNestedInput
    events?: EventUncheckedUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseCreateManyInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    academyId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LegalCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AcademyNullableScalarRelationFilter = {
    is?: AcademyWhereInput | null
    isNot?: AcademyWhereInput | null
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type GroupListRelationFilter = {
    every?: GroupWhereInput
    some?: GroupWhereInput
    none?: GroupWhereInput
  }

  export type ChannelListRelationFilter = {
    every?: ChannelWhereInput
    some?: ChannelWhereInput
    none?: ChannelWhereInput
  }

  export type BookmarkListRelationFilter = {
    every?: BookmarkWhereInput
    some?: BookmarkWhereInput
    none?: BookmarkWhereInput
  }

  export type SubmissionListRelationFilter = {
    every?: SubmissionWhereInput
    some?: SubmissionWhereInput
    none?: SubmissionWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type InstructorListRelationFilter = {
    every?: InstructorWhereInput
    some?: InstructorWhereInput
    none?: InstructorWhereInput
  }

  export type OwnerListRelationFilter = {
    every?: OwnerWhereInput
    some?: OwnerWhereInput
    none?: OwnerWhereInput
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type BadgeListRelationFilter = {
    every?: BadgeWhereInput
    some?: BadgeWhereInput
    none?: BadgeWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type CommunityListRelationFilter = {
    every?: CommunityWhereInput
    some?: CommunityWhereInput
    none?: CommunityWhereInput
  }

  export type LiveRoomListRelationFilter = {
    every?: LiveRoomWhereInput
    some?: LiveRoomWhereInput
    none?: LiveRoomWhereInput
  }

  export type NotificationSettingsListRelationFilter = {
    every?: NotificationSettingsWhereInput
    some?: NotificationSettingsWhereInput
    none?: NotificationSettingsWhereInput
  }

  export type PathListRelationFilter = {
    every?: PathWhereInput
    some?: PathWhereInput
    none?: PathWhereInput
  }

  export type LoginHistoryListRelationFilter = {
    every?: LoginHistoryWhereInput
    some?: LoginHistoryWhereInput
    none?: LoginHistoryWhereInput
  }

  export type TwoFactorListRelationFilter = {
    every?: TwoFactorWhereInput
    some?: TwoFactorWhereInput
    none?: TwoFactorWhereInput
  }

  export type UserAcademyCEOListRelationFilter = {
    every?: UserAcademyCEOWhereInput
    some?: UserAcademyCEOWhereInput
    none?: UserAcademyCEOWhereInput
  }

  export type SalaryPaymentListRelationFilter = {
    every?: SalaryPaymentWhereInput
    some?: SalaryPaymentWhereInput
    none?: SalaryPaymentWhereInput
  }

  export type MeetingParticipantListRelationFilter = {
    every?: MeetingParticipantWhereInput
    some?: MeetingParticipantWhereInput
    none?: MeetingParticipantWhereInput
  }

  export type LegalCaseListRelationFilter = {
    every?: LegalCaseWhereInput
    some?: LegalCaseWhereInput
    none?: LegalCaseWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookmarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstructorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OwnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LiveRoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationSettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PathOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoginHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwoFactorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAcademyCEOOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LegalCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    subRole?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academyId?: SortOrder
    isOnline?: SortOrder
    isVerified?: SortOrder
    age?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    subRole?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academyId?: SortOrder
    isOnline?: SortOrder
    isVerified?: SortOrder
    age?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    subRole?: SortOrder
    avatar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    academyId?: SortOrder
    isOnline?: SortOrder
    isVerified?: SortOrder
    age?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumLoginDeviceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginDevice | EnumLoginDeviceFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoginDevice[] | ListEnumLoginDeviceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoginDevice[] | ListEnumLoginDeviceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoginDeviceNullableFilter<$PrismaModel> | $Enums.LoginDevice | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type LoginHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    success?: SortOrder
    ip?: SortOrder
    device?: SortOrder
    location?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    success?: SortOrder
    ip?: SortOrder
    device?: SortOrder
    location?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    success?: SortOrder
    ip?: SortOrder
    device?: SortOrder
    location?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLoginDeviceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginDevice | EnumLoginDeviceFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoginDevice[] | ListEnumLoginDeviceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoginDevice[] | ListEnumLoginDeviceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoginDeviceNullableWithAggregatesFilter<$PrismaModel> | $Enums.LoginDevice | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLoginDeviceNullableFilter<$PrismaModel>
    _max?: NestedEnumLoginDeviceNullableFilter<$PrismaModel>
  }

  export type TwoFactorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    sms?: SortOrder
    authenticator?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    sms?: SortOrder
    authenticator?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TwoFactorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    sms?: SortOrder
    authenticator?: SortOrder
    secret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    preferences?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    phone?: SortOrder
    address?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AcademyScalarRelationFilter = {
    is?: AcademyWhereInput
    isNot?: AcademyWhereInput
  }

  export type UserAcademyCEOCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAcademyCEOMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAcademyCEOMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type AccountingEntryListRelationFilter = {
    every?: AccountingEntryWhereInput
    some?: AccountingEntryWhereInput
    none?: AccountingEntryWhereInput
  }

  export type PublicRelationsRecordListRelationFilter = {
    every?: PublicRelationsRecordWhereInput
    some?: PublicRelationsRecordWhereInput
    none?: PublicRelationsRecordWhereInput
  }

  export type MeetingListRelationFilter = {
    every?: MeetingWhereInput
    some?: MeetingWhereInput
    none?: MeetingWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountingEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublicRelationsRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstructorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    academyId?: SortOrder
  }

  export type InstructorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    academyId?: SortOrder
  }

  export type InstructorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    academyId?: SortOrder
  }

  export type EnumCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusFilter<$PrismaModel> | $Enums.CourseStatus
  }

  export type QuizListRelationFilter = {
    every?: QuizWhereInput
    some?: QuizWhereInput
    none?: QuizWhereInput
  }

  export type QuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academyId?: SortOrder
    image?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academyId?: SortOrder
    image?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    academyId?: SortOrder
    image?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
  }

  export type EnumCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PathCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    completedTasks?: SortOrder
    remainingTime?: SortOrder
    studyTime?: SortOrder
    totalTasks?: SortOrder
    progress?: SortOrder
    engagement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PathAvgOrderByAggregateInput = {
    completedTasks?: SortOrder
    remainingTime?: SortOrder
    studyTime?: SortOrder
    totalTasks?: SortOrder
    progress?: SortOrder
    engagement?: SortOrder
  }

  export type PathMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    completedTasks?: SortOrder
    remainingTime?: SortOrder
    studyTime?: SortOrder
    totalTasks?: SortOrder
    progress?: SortOrder
    engagement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PathMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    completedTasks?: SortOrder
    remainingTime?: SortOrder
    studyTime?: SortOrder
    totalTasks?: SortOrder
    progress?: SortOrder
    engagement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PathSumOrderByAggregateInput = {
    completedTasks?: SortOrder
    remainingTime?: SortOrder
    studyTime?: SortOrder
    totalTasks?: SortOrder
    progress?: SortOrder
    engagement?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumMilestoneStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusFilter<$PrismaModel> | $Enums.MilestoneStatus
  }

  export type PathScalarRelationFilter = {
    is?: PathWhereInput
    isNot?: PathWhereInput
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    pathId?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    pathId?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    pathId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMilestoneStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel> | $Enums.MilestoneStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMilestoneStatusFilter<$PrismaModel>
    _max?: NestedEnumMilestoneStatusFilter<$PrismaModel>
  }

  export type EnumLessonStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusFilter<$PrismaModel> | $Enums.LessonStatus
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    courseId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLessonStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusWithAggregatesFilter<$PrismaModel> | $Enums.LessonStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonStatusFilter<$PrismaModel>
    _max?: NestedEnumLessonStatusFilter<$PrismaModel>
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type LessonNullableScalarRelationFilter = {
    is?: LessonWhereInput | null
    isNot?: LessonWhereInput | null
  }

  export type AccountingEntryNullableScalarRelationFilter = {
    is?: AccountingEntryWhereInput | null
    isNot?: AccountingEntryWhereInput | null
  }

  export type PublicRelationsRecordNullableScalarRelationFilter = {
    is?: PublicRelationsRecordWhereInput | null
    isNot?: PublicRelationsRecordWhereInput | null
  }

  export type MeetingNullableScalarRelationFilter = {
    is?: MeetingWhereInput | null
    isNot?: MeetingWhereInput | null
  }

  export type AdminRoleNullableScalarRelationFilter = {
    is?: AdminRoleWhereInput | null
    isNot?: AdminRoleWhereInput | null
  }

  export type LegalCaseNullableScalarRelationFilter = {
    is?: LegalCaseWhereInput | null
    isNot?: LegalCaseWhereInput | null
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    lessonId?: SortOrder
    accountingEntryId?: SortOrder
    prRecordId?: SortOrder
    meetingId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    lessonId?: SortOrder
    accountingEntryId?: SortOrder
    prRecordId?: SortOrder
    meetingId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    type?: SortOrder
    lessonId?: SortOrder
    accountingEntryId?: SortOrder
    prRecordId?: SortOrder
    meetingId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    progress?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnrollmentSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    lessonId?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    upComing?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    timeLimit?: SortOrder
    passingScore?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    lessonId?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    upComing?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    lessonId?: SortOrder
    timeLimit?: SortOrder
    passingScore?: SortOrder
    upComing?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    timeLimit?: SortOrder
    passingScore?: SortOrder
  }

  export type OptionListRelationFilter = {
    every?: OptionWhereInput
    some?: OptionWhereInput
    none?: OptionWhereInput
  }

  export type QuizScalarRelationFilter = {
    is?: QuizWhereInput
    isNot?: QuizWhereInput
  }

  export type OptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    isMultiple?: SortOrder
    points?: SortOrder
    isAnswered?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    isMultiple?: SortOrder
    points?: SortOrder
    isAnswered?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    isMultiple?: SortOrder
    points?: SortOrder
    isAnswered?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type QuestionScalarRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type OptionCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OptionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OptionMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableListFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    passed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubmissionAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type SubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    passed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    quizId?: SortOrder
    score?: SortOrder
    feedback?: SortOrder
    passed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubmissionSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    value?: SortOrder
    isNew?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    isNew?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    isNew?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isImportant?: SortOrder
    urgent?: SortOrder
    title?: SortOrder
    actionUrl?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isImportant?: SortOrder
    urgent?: SortOrder
    title?: SortOrder
    actionUrl?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    isImportant?: SortOrder
    urgent?: SortOrder
    title?: SortOrder
    actionUrl?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignments?: SortOrder
    grades?: SortOrder
    messages?: SortOrder
    achievements?: SortOrder
    urgent?: SortOrder
    email?: SortOrder
    push?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignments?: SortOrder
    grades?: SortOrder
    messages?: SortOrder
    achievements?: SortOrder
    urgent?: SortOrder
    email?: SortOrder
    push?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignments?: SortOrder
    grades?: SortOrder
    messages?: SortOrder
    achievements?: SortOrder
    urgent?: SortOrder
    email?: SortOrder
    push?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type DiscussionListRelationFilter = {
    every?: DiscussionWhereInput
    some?: DiscussionWhereInput
    none?: DiscussionWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscussionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    likesCount?: SortOrder
    publicRelationsRecordId?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    likesCount?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    likesCount?: SortOrder
    publicRelationsRecordId?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    likesCount?: SortOrder
    publicRelationsRecordId?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    likesCount?: SortOrder
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type GroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    image?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    image?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
  }

  export type GroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    image?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
  }

  export type PRResponseListRelationFilter = {
    every?: PRResponseWhereInput
    some?: PRResponseWhereInput
    none?: PRResponseWhereInput
  }

  export type AdminAssignmentListRelationFilter = {
    every?: AdminAssignmentWhereInput
    some?: AdminAssignmentWhereInput
    none?: AdminAssignmentWhereInput
  }

  export type AdminRoleListRelationFilter = {
    every?: AdminRoleWhereInput
    some?: AdminRoleWhereInput
    none?: AdminRoleWhereInput
  }

  export type PRResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type OwnerScalarRelationFilter = {
    is?: OwnerWhereInput
    isNot?: OwnerWhereInput
  }

  export type ChannelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    prRecordId?: SortOrder
    meetingId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    prRecordId?: SortOrder
    meetingId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChannelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ownerId?: SortOrder
    prRecordId?: SortOrder
    meetingId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type OwnerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type OwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type OwnerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    academyId?: SortOrder
    prRecordId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    academyId?: SortOrder
    prRecordId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    academyId?: SortOrder
    prRecordId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    lessonId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    lessonId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    lessonId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountingEntryId?: SortOrder
    meetingId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountingEntryId?: SortOrder
    meetingId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountingEntryId?: SortOrder
    meetingId?: SortOrder
    adminRoleId?: SortOrder
    legalCaseId?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    points?: SortOrder
    type?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    points?: SortOrder
    type?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    points?: SortOrder
    type?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    image?: SortOrder
    points?: SortOrder
    type?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    image?: SortOrder
    points?: SortOrder
    type?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    notes?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    url?: SortOrder
    image?: SortOrder
    points?: SortOrder
    type?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CertificateSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type CommunityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    type?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityAvgOrderByAggregateInput = {
    likes?: SortOrder
    dislikes?: SortOrder
    views?: SortOrder
  }

  export type CommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    type?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    type?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunitySumOrderByAggregateInput = {
    likes?: SortOrder
    dislikes?: SortOrder
    views?: SortOrder
  }

  export type CommunityScalarRelationFilter = {
    is?: CommunityWhereInput
    isNot?: CommunityWhereInput
  }

  export type PostNullableScalarRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type DiscussionCountOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscussionMaxOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscussionMinOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    postId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type LiveRoomCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    topic?: SortOrder
    participants?: SortOrder
    isLive?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    isPrivate?: SortOrder
    isPasswordProtected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    communityId?: SortOrder
    courseId?: SortOrder
  }

  export type LiveRoomAvgOrderByAggregateInput = {
    participants?: SortOrder
  }

  export type LiveRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    topic?: SortOrder
    participants?: SortOrder
    isLive?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    isPrivate?: SortOrder
    isPasswordProtected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    communityId?: SortOrder
    courseId?: SortOrder
  }

  export type LiveRoomMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    topic?: SortOrder
    participants?: SortOrder
    isLive?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    isPrivate?: SortOrder
    isPasswordProtected?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    communityId?: SortOrder
    courseId?: SortOrder
  }

  export type LiveRoomSumOrderByAggregateInput = {
    participants?: SortOrder
  }

  export type EnumAccountingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingType | EnumAccountingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingType[] | ListEnumAccountingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingType[] | ListEnumAccountingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingTypeFilter<$PrismaModel> | $Enums.AccountingType
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type SalaryPaymentNullableScalarRelationFilter = {
    is?: SalaryPaymentWhereInput | null
    isNot?: SalaryPaymentWhereInput | null
  }

  export type AccountingEntryCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountingEntryAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AccountingEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountingEntryMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountingEntrySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumAccountingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingType | EnumAccountingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingType[] | ListEnumAccountingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingType[] | ListEnumAccountingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountingTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountingTypeFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type AccountingEntryScalarRelationFilter = {
    is?: AccountingEntryWhereInput
    isNot?: AccountingEntryWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    accountingEntryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    accountingEntryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    accountingEntryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type SalaryPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    month?: SortOrder
    year?: SortOrder
    accountingEntryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    month?: SortOrder
    year?: SortOrder
  }

  export type SalaryPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    month?: SortOrder
    year?: SortOrder
    accountingEntryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    month?: SortOrder
    year?: SortOrder
    accountingEntryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    month?: SortOrder
    year?: SortOrder
  }

  export type EnumPRRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PRRequestStatus | EnumPRRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PRRequestStatus[] | ListEnumPRRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PRRequestStatus[] | ListEnumPRRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPRRequestStatusFilter<$PrismaModel> | $Enums.PRRequestStatus
  }

  export type PublicRelationsRecordCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    senderName?: SortOrder
    senderContact?: SortOrder
    status?: SortOrder
    handledByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicRelationsRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    senderName?: SortOrder
    senderContact?: SortOrder
    status?: SortOrder
    handledByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicRelationsRecordMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    senderName?: SortOrder
    senderContact?: SortOrder
    status?: SortOrder
    handledByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPRRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PRRequestStatus | EnumPRRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PRRequestStatus[] | ListEnumPRRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PRRequestStatus[] | ListEnumPRRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPRRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.PRRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPRRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumPRRequestStatusFilter<$PrismaModel>
  }

  export type PublicRelationsRecordScalarRelationFilter = {
    is?: PublicRelationsRecordWhereInput
    isNot?: PublicRelationsRecordWhereInput
  }

  export type PRResponseCountOrderByAggregateInput = {
    id?: SortOrder
    response?: SortOrder
    prRecordId?: SortOrder
    respondedByAdminId?: SortOrder
    createdAt?: SortOrder
  }

  export type PRResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    response?: SortOrder
    prRecordId?: SortOrder
    respondedByAdminId?: SortOrder
    createdAt?: SortOrder
  }

  export type PRResponseMinOrderByAggregateInput = {
    id?: SortOrder
    response?: SortOrder
    prRecordId?: SortOrder
    respondedByAdminId?: SortOrder
    createdAt?: SortOrder
  }

  export type MeetingCountOrderByAggregateInput = {
    id?: SortOrder
    meetingTitle?: SortOrder
    meetingDate?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    meetingTitle?: SortOrder
    meetingDate?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingMinOrderByAggregateInput = {
    id?: SortOrder
    meetingTitle?: SortOrder
    meetingDate?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdByAdminId?: SortOrder
    academyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingScalarRelationFilter = {
    is?: MeetingWhereInput
    isNot?: MeetingWhereInput
  }

  export type MeetingParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    isAttended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    isAttended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    isAttended?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAdminRoleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRoleType | EnumAdminRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRoleType[] | ListEnumAdminRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRoleType[] | ListEnumAdminRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleTypeFilter<$PrismaModel> | $Enums.AdminRoleType
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminRoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminRoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    adminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdminRoleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRoleType | EnumAdminRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRoleType[] | ListEnumAdminRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRoleType[] | ListEnumAdminRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdminRoleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleTypeFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AdminRoleScalarRelationFilter = {
    is?: AdminRoleWhereInput
    isNot?: AdminRoleWhereInput
  }

  export type AdminAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    roleId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumLegalCaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalCaseType | EnumLegalCaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalCaseType[] | ListEnumLegalCaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalCaseType[] | ListEnumLegalCaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalCaseTypeFilter<$PrismaModel> | $Enums.LegalCaseType
  }

  export type EnumLegalCaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalCaseStatus | EnumLegalCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LegalCaseStatus[] | ListEnumLegalCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalCaseStatus[] | ListEnumLegalCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalCaseStatusFilter<$PrismaModel> | $Enums.LegalCaseStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LegalCaseCountOrderByAggregateInput = {
    id?: SortOrder
    caseTitle?: SortOrder
    caseType?: SortOrder
    status?: SortOrder
    description?: SortOrder
    courtDate?: SortOrder
    assignedLawyerId?: SortOrder
    academyId?: SortOrder
    relatedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LegalCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    caseTitle?: SortOrder
    caseType?: SortOrder
    status?: SortOrder
    description?: SortOrder
    courtDate?: SortOrder
    assignedLawyerId?: SortOrder
    academyId?: SortOrder
    relatedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LegalCaseMinOrderByAggregateInput = {
    id?: SortOrder
    caseTitle?: SortOrder
    caseType?: SortOrder
    status?: SortOrder
    description?: SortOrder
    courtDate?: SortOrder
    assignedLawyerId?: SortOrder
    academyId?: SortOrder
    relatedUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLegalCaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalCaseType | EnumLegalCaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalCaseType[] | ListEnumLegalCaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalCaseType[] | ListEnumLegalCaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalCaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.LegalCaseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLegalCaseTypeFilter<$PrismaModel>
    _max?: NestedEnumLegalCaseTypeFilter<$PrismaModel>
  }

  export type EnumLegalCaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalCaseStatus | EnumLegalCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LegalCaseStatus[] | ListEnumLegalCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalCaseStatus[] | ListEnumLegalCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalCaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LegalCaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLegalCaseStatusFilter<$PrismaModel>
    _max?: NestedEnumLegalCaseStatusFilter<$PrismaModel>
  }

  export type AcademyCreateNestedOneWithoutUsersInput = {
    create?: XOR<AcademyCreateWithoutUsersInput, AcademyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutUsersInput
    connect?: AcademyWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput> | GroupCreateWithoutMembersInput[] | GroupUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput | GroupCreateOrConnectWithoutMembersInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ChannelCreateNestedManyWithoutMembersInput = {
    create?: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput> | ChannelCreateWithoutMembersInput[] | ChannelUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMembersInput | ChannelCreateOrConnectWithoutMembersInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type BookmarkCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type SubmissionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type InstructorCreateNestedManyWithoutUserInput = {
    create?: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput> | InstructorCreateWithoutUserInput[] | InstructorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutUserInput | InstructorCreateOrConnectWithoutUserInput[]
    createMany?: InstructorCreateManyUserInputEnvelope
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
  }

  export type OwnerCreateNestedManyWithoutUserInput = {
    create?: XOR<OwnerCreateWithoutUserInput, OwnerUncheckedCreateWithoutUserInput> | OwnerCreateWithoutUserInput[] | OwnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutUserInput | OwnerCreateOrConnectWithoutUserInput[]
    createMany?: OwnerCreateManyUserInputEnvelope
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutCompletedByInput = {
    create?: XOR<LessonCreateWithoutCompletedByInput, LessonUncheckedCreateWithoutCompletedByInput> | LessonCreateWithoutCompletedByInput[] | LessonUncheckedCreateWithoutCompletedByInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCompletedByInput | LessonCreateOrConnectWithoutCompletedByInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type BadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CommunityCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<CommunityCreateWithoutParticipantsInput, CommunityUncheckedCreateWithoutParticipantsInput> | CommunityCreateWithoutParticipantsInput[] | CommunityUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutParticipantsInput | CommunityCreateOrConnectWithoutParticipantsInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
  }

  export type LiveRoomCreateNestedManyWithoutUserInput = {
    create?: XOR<LiveRoomCreateWithoutUserInput, LiveRoomUncheckedCreateWithoutUserInput> | LiveRoomCreateWithoutUserInput[] | LiveRoomUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutUserInput | LiveRoomCreateOrConnectWithoutUserInput[]
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
  }

  export type NotificationSettingsCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput> | NotificationSettingsCreateWithoutUserInput[] | NotificationSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput | NotificationSettingsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationSettingsCreateManyUserInputEnvelope
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
  }

  export type PathCreateNestedManyWithoutPeersInput = {
    create?: XOR<PathCreateWithoutPeersInput, PathUncheckedCreateWithoutPeersInput> | PathCreateWithoutPeersInput[] | PathUncheckedCreateWithoutPeersInput[]
    connectOrCreate?: PathCreateOrConnectWithoutPeersInput | PathCreateOrConnectWithoutPeersInput[]
    connect?: PathWhereUniqueInput | PathWhereUniqueInput[]
  }

  export type LoginHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput> | LoginHistoryCreateWithoutUserInput[] | LoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginHistoryCreateOrConnectWithoutUserInput | LoginHistoryCreateOrConnectWithoutUserInput[]
    createMany?: LoginHistoryCreateManyUserInputEnvelope
    connect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
  }

  export type TwoFactorCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
  }

  export type UserAcademyCEOCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAcademyCEOCreateWithoutUserInput, UserAcademyCEOUncheckedCreateWithoutUserInput> | UserAcademyCEOCreateWithoutUserInput[] | UserAcademyCEOUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAcademyCEOCreateOrConnectWithoutUserInput | UserAcademyCEOCreateOrConnectWithoutUserInput[]
    createMany?: UserAcademyCEOCreateManyUserInputEnvelope
    connect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
  }

  export type SalaryPaymentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput> | SalaryPaymentCreateWithoutEmployeeInput[] | SalaryPaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutEmployeeInput | SalaryPaymentCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryPaymentCreateManyEmployeeInputEnvelope
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
  }

  export type MeetingParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<MeetingParticipantCreateWithoutUserInput, MeetingParticipantUncheckedCreateWithoutUserInput> | MeetingParticipantCreateWithoutUserInput[] | MeetingParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingParticipantCreateOrConnectWithoutUserInput | MeetingParticipantCreateOrConnectWithoutUserInput[]
    createMany?: MeetingParticipantCreateManyUserInputEnvelope
    connect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
  }

  export type LegalCaseCreateNestedManyWithoutRelatedUserInput = {
    create?: XOR<LegalCaseCreateWithoutRelatedUserInput, LegalCaseUncheckedCreateWithoutRelatedUserInput> | LegalCaseCreateWithoutRelatedUserInput[] | LegalCaseUncheckedCreateWithoutRelatedUserInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutRelatedUserInput | LegalCaseCreateOrConnectWithoutRelatedUserInput[]
    createMany?: LegalCaseCreateManyRelatedUserInputEnvelope
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type AchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutMembersInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput> | GroupCreateWithoutMembersInput[] | GroupUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput | GroupCreateOrConnectWithoutMembersInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutMembersInput = {
    create?: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput> | ChannelCreateWithoutMembersInput[] | ChannelUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMembersInput | ChannelCreateOrConnectWithoutMembersInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type BookmarkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type SubmissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type InstructorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput> | InstructorCreateWithoutUserInput[] | InstructorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutUserInput | InstructorCreateOrConnectWithoutUserInput[]
    createMany?: InstructorCreateManyUserInputEnvelope
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
  }

  export type OwnerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OwnerCreateWithoutUserInput, OwnerUncheckedCreateWithoutUserInput> | OwnerCreateWithoutUserInput[] | OwnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutUserInput | OwnerCreateOrConnectWithoutUserInput[]
    createMany?: OwnerCreateManyUserInputEnvelope
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutCompletedByInput = {
    create?: XOR<LessonCreateWithoutCompletedByInput, LessonUncheckedCreateWithoutCompletedByInput> | LessonCreateWithoutCompletedByInput[] | LessonUncheckedCreateWithoutCompletedByInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCompletedByInput | LessonCreateOrConnectWithoutCompletedByInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type BadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type CommunityUncheckedCreateNestedManyWithoutParticipantsInput = {
    create?: XOR<CommunityCreateWithoutParticipantsInput, CommunityUncheckedCreateWithoutParticipantsInput> | CommunityCreateWithoutParticipantsInput[] | CommunityUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutParticipantsInput | CommunityCreateOrConnectWithoutParticipantsInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
  }

  export type LiveRoomUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LiveRoomCreateWithoutUserInput, LiveRoomUncheckedCreateWithoutUserInput> | LiveRoomCreateWithoutUserInput[] | LiveRoomUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutUserInput | LiveRoomCreateOrConnectWithoutUserInput[]
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
  }

  export type NotificationSettingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput> | NotificationSettingsCreateWithoutUserInput[] | NotificationSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput | NotificationSettingsCreateOrConnectWithoutUserInput[]
    createMany?: NotificationSettingsCreateManyUserInputEnvelope
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
  }

  export type PathUncheckedCreateNestedManyWithoutPeersInput = {
    create?: XOR<PathCreateWithoutPeersInput, PathUncheckedCreateWithoutPeersInput> | PathCreateWithoutPeersInput[] | PathUncheckedCreateWithoutPeersInput[]
    connectOrCreate?: PathCreateOrConnectWithoutPeersInput | PathCreateOrConnectWithoutPeersInput[]
    connect?: PathWhereUniqueInput | PathWhereUniqueInput[]
  }

  export type LoginHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput> | LoginHistoryCreateWithoutUserInput[] | LoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginHistoryCreateOrConnectWithoutUserInput | LoginHistoryCreateOrConnectWithoutUserInput[]
    createMany?: LoginHistoryCreateManyUserInputEnvelope
    connect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
  }

  export type TwoFactorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
  }

  export type UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAcademyCEOCreateWithoutUserInput, UserAcademyCEOUncheckedCreateWithoutUserInput> | UserAcademyCEOCreateWithoutUserInput[] | UserAcademyCEOUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAcademyCEOCreateOrConnectWithoutUserInput | UserAcademyCEOCreateOrConnectWithoutUserInput[]
    createMany?: UserAcademyCEOCreateManyUserInputEnvelope
    connect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
  }

  export type SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput> | SalaryPaymentCreateWithoutEmployeeInput[] | SalaryPaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutEmployeeInput | SalaryPaymentCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryPaymentCreateManyEmployeeInputEnvelope
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
  }

  export type MeetingParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MeetingParticipantCreateWithoutUserInput, MeetingParticipantUncheckedCreateWithoutUserInput> | MeetingParticipantCreateWithoutUserInput[] | MeetingParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingParticipantCreateOrConnectWithoutUserInput | MeetingParticipantCreateOrConnectWithoutUserInput[]
    createMany?: MeetingParticipantCreateManyUserInputEnvelope
    connect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
  }

  export type LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput = {
    create?: XOR<LegalCaseCreateWithoutRelatedUserInput, LegalCaseUncheckedCreateWithoutRelatedUserInput> | LegalCaseCreateWithoutRelatedUserInput[] | LegalCaseUncheckedCreateWithoutRelatedUserInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutRelatedUserInput | LegalCaseCreateOrConnectWithoutRelatedUserInput[]
    createMany?: LegalCaseCreateManyRelatedUserInputEnvelope
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AcademyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<AcademyCreateWithoutUsersInput, AcademyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutUsersInput
    upsert?: AcademyUpsertWithoutUsersInput
    disconnect?: AcademyWhereInput | boolean
    delete?: AcademyWhereInput | boolean
    connect?: AcademyWhereUniqueInput
    update?: XOR<XOR<AcademyUpdateToOneWithWhereWithoutUsersInput, AcademyUpdateWithoutUsersInput>, AcademyUncheckedUpdateWithoutUsersInput>
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type EnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput> | GroupCreateWithoutMembersInput[] | GroupUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput | GroupCreateOrConnectWithoutMembersInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutMembersInput | GroupUpsertWithWhereUniqueWithoutMembersInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutMembersInput | GroupUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutMembersInput | GroupUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type ChannelUpdateManyWithoutMembersNestedInput = {
    create?: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput> | ChannelCreateWithoutMembersInput[] | ChannelUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMembersInput | ChannelCreateOrConnectWithoutMembersInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutMembersInput | ChannelUpsertWithWhereUniqueWithoutMembersInput[]
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutMembersInput | ChannelUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutMembersInput | ChannelUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type BookmarkUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutUserInput | BookmarkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutUserInput | BookmarkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutUserInput | BookmarkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type SubmissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutUserInput | SubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutUserInput | SubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutUserInput | SubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type InstructorUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput> | InstructorCreateWithoutUserInput[] | InstructorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutUserInput | InstructorCreateOrConnectWithoutUserInput[]
    upsert?: InstructorUpsertWithWhereUniqueWithoutUserInput | InstructorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstructorCreateManyUserInputEnvelope
    set?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    disconnect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    delete?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    update?: InstructorUpdateWithWhereUniqueWithoutUserInput | InstructorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstructorUpdateManyWithWhereWithoutUserInput | InstructorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
  }

  export type OwnerUpdateManyWithoutUserNestedInput = {
    create?: XOR<OwnerCreateWithoutUserInput, OwnerUncheckedCreateWithoutUserInput> | OwnerCreateWithoutUserInput[] | OwnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutUserInput | OwnerCreateOrConnectWithoutUserInput[]
    upsert?: OwnerUpsertWithWhereUniqueWithoutUserInput | OwnerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OwnerCreateManyUserInputEnvelope
    set?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    disconnect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    delete?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    update?: OwnerUpdateWithWhereUniqueWithoutUserInput | OwnerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OwnerUpdateManyWithWhereWithoutUserInput | OwnerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutUserInput | AdminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutUserInput | AdminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutUserInput | AdminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutCompletedByNestedInput = {
    create?: XOR<LessonCreateWithoutCompletedByInput, LessonUncheckedCreateWithoutCompletedByInput> | LessonCreateWithoutCompletedByInput[] | LessonUncheckedCreateWithoutCompletedByInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCompletedByInput | LessonCreateOrConnectWithoutCompletedByInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutCompletedByInput | LessonUpsertWithWhereUniqueWithoutCompletedByInput[]
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutCompletedByInput | LessonUpdateWithWhereUniqueWithoutCompletedByInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutCompletedByInput | LessonUpdateManyWithWhereWithoutCompletedByInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUserInput | ReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUserInput | ReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUserInput | ReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type BadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutUserInput | BadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutUserInput | BadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutUserInput | BadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CommunityUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<CommunityCreateWithoutParticipantsInput, CommunityUncheckedCreateWithoutParticipantsInput> | CommunityCreateWithoutParticipantsInput[] | CommunityUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutParticipantsInput | CommunityCreateOrConnectWithoutParticipantsInput[]
    upsert?: CommunityUpsertWithWhereUniqueWithoutParticipantsInput | CommunityUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    disconnect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    delete?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    update?: CommunityUpdateWithWhereUniqueWithoutParticipantsInput | CommunityUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: CommunityUpdateManyWithWhereWithoutParticipantsInput | CommunityUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
  }

  export type LiveRoomUpdateManyWithoutUserNestedInput = {
    create?: XOR<LiveRoomCreateWithoutUserInput, LiveRoomUncheckedCreateWithoutUserInput> | LiveRoomCreateWithoutUserInput[] | LiveRoomUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutUserInput | LiveRoomCreateOrConnectWithoutUserInput[]
    upsert?: LiveRoomUpsertWithWhereUniqueWithoutUserInput | LiveRoomUpsertWithWhereUniqueWithoutUserInput[]
    set?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    disconnect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    delete?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    update?: LiveRoomUpdateWithWhereUniqueWithoutUserInput | LiveRoomUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LiveRoomUpdateManyWithWhereWithoutUserInput | LiveRoomUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LiveRoomScalarWhereInput | LiveRoomScalarWhereInput[]
  }

  export type NotificationSettingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput> | NotificationSettingsCreateWithoutUserInput[] | NotificationSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput | NotificationSettingsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationSettingsUpsertWithWhereUniqueWithoutUserInput | NotificationSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationSettingsCreateManyUserInputEnvelope
    set?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    disconnect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    delete?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    update?: NotificationSettingsUpdateWithWhereUniqueWithoutUserInput | NotificationSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationSettingsUpdateManyWithWhereWithoutUserInput | NotificationSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
  }

  export type PathUpdateManyWithoutPeersNestedInput = {
    create?: XOR<PathCreateWithoutPeersInput, PathUncheckedCreateWithoutPeersInput> | PathCreateWithoutPeersInput[] | PathUncheckedCreateWithoutPeersInput[]
    connectOrCreate?: PathCreateOrConnectWithoutPeersInput | PathCreateOrConnectWithoutPeersInput[]
    upsert?: PathUpsertWithWhereUniqueWithoutPeersInput | PathUpsertWithWhereUniqueWithoutPeersInput[]
    set?: PathWhereUniqueInput | PathWhereUniqueInput[]
    disconnect?: PathWhereUniqueInput | PathWhereUniqueInput[]
    delete?: PathWhereUniqueInput | PathWhereUniqueInput[]
    connect?: PathWhereUniqueInput | PathWhereUniqueInput[]
    update?: PathUpdateWithWhereUniqueWithoutPeersInput | PathUpdateWithWhereUniqueWithoutPeersInput[]
    updateMany?: PathUpdateManyWithWhereWithoutPeersInput | PathUpdateManyWithWhereWithoutPeersInput[]
    deleteMany?: PathScalarWhereInput | PathScalarWhereInput[]
  }

  export type LoginHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput> | LoginHistoryCreateWithoutUserInput[] | LoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginHistoryCreateOrConnectWithoutUserInput | LoginHistoryCreateOrConnectWithoutUserInput[]
    upsert?: LoginHistoryUpsertWithWhereUniqueWithoutUserInput | LoginHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoginHistoryCreateManyUserInputEnvelope
    set?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    disconnect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    delete?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    connect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    update?: LoginHistoryUpdateWithWhereUniqueWithoutUserInput | LoginHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoginHistoryUpdateManyWithWhereWithoutUserInput | LoginHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoginHistoryScalarWhereInput | LoginHistoryScalarWhereInput[]
  }

  export type TwoFactorUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorUpsertWithWhereUniqueWithoutUserInput | TwoFactorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    set?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    disconnect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    delete?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    update?: TwoFactorUpdateWithWhereUniqueWithoutUserInput | TwoFactorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorUpdateManyWithWhereWithoutUserInput | TwoFactorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
  }

  export type UserAcademyCEOUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAcademyCEOCreateWithoutUserInput, UserAcademyCEOUncheckedCreateWithoutUserInput> | UserAcademyCEOCreateWithoutUserInput[] | UserAcademyCEOUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAcademyCEOCreateOrConnectWithoutUserInput | UserAcademyCEOCreateOrConnectWithoutUserInput[]
    upsert?: UserAcademyCEOUpsertWithWhereUniqueWithoutUserInput | UserAcademyCEOUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAcademyCEOCreateManyUserInputEnvelope
    set?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    disconnect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    delete?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    connect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    update?: UserAcademyCEOUpdateWithWhereUniqueWithoutUserInput | UserAcademyCEOUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAcademyCEOUpdateManyWithWhereWithoutUserInput | UserAcademyCEOUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAcademyCEOScalarWhereInput | UserAcademyCEOScalarWhereInput[]
  }

  export type SalaryPaymentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput> | SalaryPaymentCreateWithoutEmployeeInput[] | SalaryPaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutEmployeeInput | SalaryPaymentCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryPaymentUpsertWithWhereUniqueWithoutEmployeeInput | SalaryPaymentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryPaymentCreateManyEmployeeInputEnvelope
    set?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    disconnect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    delete?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    update?: SalaryPaymentUpdateWithWhereUniqueWithoutEmployeeInput | SalaryPaymentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryPaymentUpdateManyWithWhereWithoutEmployeeInput | SalaryPaymentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
  }

  export type MeetingParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeetingParticipantCreateWithoutUserInput, MeetingParticipantUncheckedCreateWithoutUserInput> | MeetingParticipantCreateWithoutUserInput[] | MeetingParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingParticipantCreateOrConnectWithoutUserInput | MeetingParticipantCreateOrConnectWithoutUserInput[]
    upsert?: MeetingParticipantUpsertWithWhereUniqueWithoutUserInput | MeetingParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeetingParticipantCreateManyUserInputEnvelope
    set?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    disconnect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    delete?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    connect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    update?: MeetingParticipantUpdateWithWhereUniqueWithoutUserInput | MeetingParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeetingParticipantUpdateManyWithWhereWithoutUserInput | MeetingParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeetingParticipantScalarWhereInput | MeetingParticipantScalarWhereInput[]
  }

  export type LegalCaseUpdateManyWithoutRelatedUserNestedInput = {
    create?: XOR<LegalCaseCreateWithoutRelatedUserInput, LegalCaseUncheckedCreateWithoutRelatedUserInput> | LegalCaseCreateWithoutRelatedUserInput[] | LegalCaseUncheckedCreateWithoutRelatedUserInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutRelatedUserInput | LegalCaseCreateOrConnectWithoutRelatedUserInput[]
    upsert?: LegalCaseUpsertWithWhereUniqueWithoutRelatedUserInput | LegalCaseUpsertWithWhereUniqueWithoutRelatedUserInput[]
    createMany?: LegalCaseCreateManyRelatedUserInputEnvelope
    set?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    disconnect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    delete?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    update?: LegalCaseUpdateWithWhereUniqueWithoutRelatedUserInput | LegalCaseUpdateWithWhereUniqueWithoutRelatedUserInput[]
    updateMany?: LegalCaseUpdateManyWithWhereWithoutRelatedUserInput | LegalCaseUpdateManyWithWhereWithoutRelatedUserInput[]
    deleteMany?: LegalCaseScalarWhereInput | LegalCaseScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput> | EnrollmentCreateWithoutUserInput[] | EnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutUserInput | EnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutUserInput | EnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EnrollmentCreateManyUserInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutUserInput | EnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutUserInput | EnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type AchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutMembersNestedInput = {
    create?: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput> | GroupCreateWithoutMembersInput[] | GroupUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutMembersInput | GroupCreateOrConnectWithoutMembersInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutMembersInput | GroupUpsertWithWhereUniqueWithoutMembersInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutMembersInput | GroupUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutMembersInput | GroupUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutMembersNestedInput = {
    create?: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput> | ChannelCreateWithoutMembersInput[] | ChannelUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMembersInput | ChannelCreateOrConnectWithoutMembersInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutMembersInput | ChannelUpsertWithWhereUniqueWithoutMembersInput[]
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutMembersInput | ChannelUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutMembersInput | ChannelUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type BookmarkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutUserInput | BookmarkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutUserInput | BookmarkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutUserInput | BookmarkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type SubmissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutUserInput | SubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutUserInput | SubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutUserInput | SubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type InstructorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput> | InstructorCreateWithoutUserInput[] | InstructorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutUserInput | InstructorCreateOrConnectWithoutUserInput[]
    upsert?: InstructorUpsertWithWhereUniqueWithoutUserInput | InstructorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InstructorCreateManyUserInputEnvelope
    set?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    disconnect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    delete?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    update?: InstructorUpdateWithWhereUniqueWithoutUserInput | InstructorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InstructorUpdateManyWithWhereWithoutUserInput | InstructorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
  }

  export type OwnerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OwnerCreateWithoutUserInput, OwnerUncheckedCreateWithoutUserInput> | OwnerCreateWithoutUserInput[] | OwnerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OwnerCreateOrConnectWithoutUserInput | OwnerCreateOrConnectWithoutUserInput[]
    upsert?: OwnerUpsertWithWhereUniqueWithoutUserInput | OwnerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OwnerCreateManyUserInputEnvelope
    set?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    disconnect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    delete?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    connect?: OwnerWhereUniqueInput | OwnerWhereUniqueInput[]
    update?: OwnerUpdateWithWhereUniqueWithoutUserInput | OwnerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OwnerUpdateManyWithWhereWithoutUserInput | OwnerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutUserInput | AdminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutUserInput | AdminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutUserInput | AdminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutCompletedByNestedInput = {
    create?: XOR<LessonCreateWithoutCompletedByInput, LessonUncheckedCreateWithoutCompletedByInput> | LessonCreateWithoutCompletedByInput[] | LessonUncheckedCreateWithoutCompletedByInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCompletedByInput | LessonCreateOrConnectWithoutCompletedByInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutCompletedByInput | LessonUpsertWithWhereUniqueWithoutCompletedByInput[]
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutCompletedByInput | LessonUpdateWithWhereUniqueWithoutCompletedByInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutCompletedByInput | LessonUpdateManyWithWhereWithoutCompletedByInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUserInput | ReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUserInput | ReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUserInput | ReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type BadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput> | BadgeCreateWithoutUserInput[] | BadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutUserInput | BadgeCreateOrConnectWithoutUserInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutUserInput | BadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BadgeCreateManyUserInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutUserInput | BadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutUserInput | BadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type CommunityUncheckedUpdateManyWithoutParticipantsNestedInput = {
    create?: XOR<CommunityCreateWithoutParticipantsInput, CommunityUncheckedCreateWithoutParticipantsInput> | CommunityCreateWithoutParticipantsInput[] | CommunityUncheckedCreateWithoutParticipantsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutParticipantsInput | CommunityCreateOrConnectWithoutParticipantsInput[]
    upsert?: CommunityUpsertWithWhereUniqueWithoutParticipantsInput | CommunityUpsertWithWhereUniqueWithoutParticipantsInput[]
    set?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    disconnect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    delete?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    update?: CommunityUpdateWithWhereUniqueWithoutParticipantsInput | CommunityUpdateWithWhereUniqueWithoutParticipantsInput[]
    updateMany?: CommunityUpdateManyWithWhereWithoutParticipantsInput | CommunityUpdateManyWithWhereWithoutParticipantsInput[]
    deleteMany?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
  }

  export type LiveRoomUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LiveRoomCreateWithoutUserInput, LiveRoomUncheckedCreateWithoutUserInput> | LiveRoomCreateWithoutUserInput[] | LiveRoomUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutUserInput | LiveRoomCreateOrConnectWithoutUserInput[]
    upsert?: LiveRoomUpsertWithWhereUniqueWithoutUserInput | LiveRoomUpsertWithWhereUniqueWithoutUserInput[]
    set?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    disconnect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    delete?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    update?: LiveRoomUpdateWithWhereUniqueWithoutUserInput | LiveRoomUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LiveRoomUpdateManyWithWhereWithoutUserInput | LiveRoomUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LiveRoomScalarWhereInput | LiveRoomScalarWhereInput[]
  }

  export type NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput> | NotificationSettingsCreateWithoutUserInput[] | NotificationSettingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput | NotificationSettingsCreateOrConnectWithoutUserInput[]
    upsert?: NotificationSettingsUpsertWithWhereUniqueWithoutUserInput | NotificationSettingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationSettingsCreateManyUserInputEnvelope
    set?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    disconnect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    delete?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    connect?: NotificationSettingsWhereUniqueInput | NotificationSettingsWhereUniqueInput[]
    update?: NotificationSettingsUpdateWithWhereUniqueWithoutUserInput | NotificationSettingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationSettingsUpdateManyWithWhereWithoutUserInput | NotificationSettingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
  }

  export type PathUncheckedUpdateManyWithoutPeersNestedInput = {
    create?: XOR<PathCreateWithoutPeersInput, PathUncheckedCreateWithoutPeersInput> | PathCreateWithoutPeersInput[] | PathUncheckedCreateWithoutPeersInput[]
    connectOrCreate?: PathCreateOrConnectWithoutPeersInput | PathCreateOrConnectWithoutPeersInput[]
    upsert?: PathUpsertWithWhereUniqueWithoutPeersInput | PathUpsertWithWhereUniqueWithoutPeersInput[]
    set?: PathWhereUniqueInput | PathWhereUniqueInput[]
    disconnect?: PathWhereUniqueInput | PathWhereUniqueInput[]
    delete?: PathWhereUniqueInput | PathWhereUniqueInput[]
    connect?: PathWhereUniqueInput | PathWhereUniqueInput[]
    update?: PathUpdateWithWhereUniqueWithoutPeersInput | PathUpdateWithWhereUniqueWithoutPeersInput[]
    updateMany?: PathUpdateManyWithWhereWithoutPeersInput | PathUpdateManyWithWhereWithoutPeersInput[]
    deleteMany?: PathScalarWhereInput | PathScalarWhereInput[]
  }

  export type LoginHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput> | LoginHistoryCreateWithoutUserInput[] | LoginHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginHistoryCreateOrConnectWithoutUserInput | LoginHistoryCreateOrConnectWithoutUserInput[]
    upsert?: LoginHistoryUpsertWithWhereUniqueWithoutUserInput | LoginHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoginHistoryCreateManyUserInputEnvelope
    set?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    disconnect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    delete?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    connect?: LoginHistoryWhereUniqueInput | LoginHistoryWhereUniqueInput[]
    update?: LoginHistoryUpdateWithWhereUniqueWithoutUserInput | LoginHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoginHistoryUpdateManyWithWhereWithoutUserInput | LoginHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoginHistoryScalarWhereInput | LoginHistoryScalarWhereInput[]
  }

  export type TwoFactorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput> | TwoFactorCreateWithoutUserInput[] | TwoFactorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwoFactorCreateOrConnectWithoutUserInput | TwoFactorCreateOrConnectWithoutUserInput[]
    upsert?: TwoFactorUpsertWithWhereUniqueWithoutUserInput | TwoFactorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwoFactorCreateManyUserInputEnvelope
    set?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    disconnect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    delete?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    connect?: TwoFactorWhereUniqueInput | TwoFactorWhereUniqueInput[]
    update?: TwoFactorUpdateWithWhereUniqueWithoutUserInput | TwoFactorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwoFactorUpdateManyWithWhereWithoutUserInput | TwoFactorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
  }

  export type UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAcademyCEOCreateWithoutUserInput, UserAcademyCEOUncheckedCreateWithoutUserInput> | UserAcademyCEOCreateWithoutUserInput[] | UserAcademyCEOUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAcademyCEOCreateOrConnectWithoutUserInput | UserAcademyCEOCreateOrConnectWithoutUserInput[]
    upsert?: UserAcademyCEOUpsertWithWhereUniqueWithoutUserInput | UserAcademyCEOUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAcademyCEOCreateManyUserInputEnvelope
    set?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    disconnect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    delete?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    connect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    update?: UserAcademyCEOUpdateWithWhereUniqueWithoutUserInput | UserAcademyCEOUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAcademyCEOUpdateManyWithWhereWithoutUserInput | UserAcademyCEOUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAcademyCEOScalarWhereInput | UserAcademyCEOScalarWhereInput[]
  }

  export type SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput> | SalaryPaymentCreateWithoutEmployeeInput[] | SalaryPaymentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutEmployeeInput | SalaryPaymentCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryPaymentUpsertWithWhereUniqueWithoutEmployeeInput | SalaryPaymentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryPaymentCreateManyEmployeeInputEnvelope
    set?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    disconnect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    delete?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    connect?: SalaryPaymentWhereUniqueInput | SalaryPaymentWhereUniqueInput[]
    update?: SalaryPaymentUpdateWithWhereUniqueWithoutEmployeeInput | SalaryPaymentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryPaymentUpdateManyWithWhereWithoutEmployeeInput | SalaryPaymentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
  }

  export type MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeetingParticipantCreateWithoutUserInput, MeetingParticipantUncheckedCreateWithoutUserInput> | MeetingParticipantCreateWithoutUserInput[] | MeetingParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingParticipantCreateOrConnectWithoutUserInput | MeetingParticipantCreateOrConnectWithoutUserInput[]
    upsert?: MeetingParticipantUpsertWithWhereUniqueWithoutUserInput | MeetingParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeetingParticipantCreateManyUserInputEnvelope
    set?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    disconnect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    delete?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    connect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    update?: MeetingParticipantUpdateWithWhereUniqueWithoutUserInput | MeetingParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeetingParticipantUpdateManyWithWhereWithoutUserInput | MeetingParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeetingParticipantScalarWhereInput | MeetingParticipantScalarWhereInput[]
  }

  export type LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput = {
    create?: XOR<LegalCaseCreateWithoutRelatedUserInput, LegalCaseUncheckedCreateWithoutRelatedUserInput> | LegalCaseCreateWithoutRelatedUserInput[] | LegalCaseUncheckedCreateWithoutRelatedUserInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutRelatedUserInput | LegalCaseCreateOrConnectWithoutRelatedUserInput[]
    upsert?: LegalCaseUpsertWithWhereUniqueWithoutRelatedUserInput | LegalCaseUpsertWithWhereUniqueWithoutRelatedUserInput[]
    createMany?: LegalCaseCreateManyRelatedUserInputEnvelope
    set?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    disconnect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    delete?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    update?: LegalCaseUpdateWithWhereUniqueWithoutRelatedUserInput | LegalCaseUpdateWithWhereUniqueWithoutRelatedUserInput[]
    updateMany?: LegalCaseUpdateManyWithWhereWithoutRelatedUserInput | LegalCaseUpdateManyWithWhereWithoutRelatedUserInput[]
    deleteMany?: LegalCaseScalarWhereInput | LegalCaseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLoginHistoryInput = {
    create?: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumLoginDeviceFieldUpdateOperationsInput = {
    set?: $Enums.LoginDevice | null
  }

  export type UserUpdateOneRequiredWithoutLoginHistoryNestedInput = {
    create?: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginHistoryInput
    upsert?: UserUpsertWithoutLoginHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLoginHistoryInput, UserUpdateWithoutLoginHistoryInput>, UserUncheckedUpdateWithoutLoginHistoryInput>
  }

  export type UserCreateNestedOneWithoutTwoFactorInput = {
    create?: XOR<UserCreateWithoutTwoFactorInput, UserUncheckedCreateWithoutTwoFactorInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTwoFactorNestedInput = {
    create?: XOR<UserCreateWithoutTwoFactorInput, UserUncheckedCreateWithoutTwoFactorInput>
    connectOrCreate?: UserCreateOrConnectWithoutTwoFactorInput
    upsert?: UserUpsertWithoutTwoFactorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTwoFactorInput, UserUpdateWithoutTwoFactorInput>, UserUncheckedUpdateWithoutTwoFactorInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutUserAcademyCEOInput = {
    create?: XOR<UserCreateWithoutUserAcademyCEOInput, UserUncheckedCreateWithoutUserAcademyCEOInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAcademyCEOInput
    connect?: UserWhereUniqueInput
  }

  export type AcademyCreateNestedOneWithoutCeosInput = {
    create?: XOR<AcademyCreateWithoutCeosInput, AcademyUncheckedCreateWithoutCeosInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutCeosInput
    connect?: AcademyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserAcademyCEONestedInput = {
    create?: XOR<UserCreateWithoutUserAcademyCEOInput, UserUncheckedCreateWithoutUserAcademyCEOInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserAcademyCEOInput
    upsert?: UserUpsertWithoutUserAcademyCEOInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserAcademyCEOInput, UserUpdateWithoutUserAcademyCEOInput>, UserUncheckedUpdateWithoutUserAcademyCEOInput>
  }

  export type AcademyUpdateOneRequiredWithoutCeosNestedInput = {
    create?: XOR<AcademyCreateWithoutCeosInput, AcademyUncheckedCreateWithoutCeosInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutCeosInput
    upsert?: AcademyUpsertWithoutCeosInput
    connect?: AcademyWhereUniqueInput
    update?: XOR<XOR<AcademyUpdateToOneWithWhereWithoutCeosInput, AcademyUpdateWithoutCeosInput>, AcademyUncheckedUpdateWithoutCeosInput>
  }

  export type UserCreateNestedManyWithoutAcademyInput = {
    create?: XOR<UserCreateWithoutAcademyInput, UserUncheckedCreateWithoutAcademyInput> | UserCreateWithoutAcademyInput[] | UserUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAcademyInput | UserCreateOrConnectWithoutAcademyInput[]
    createMany?: UserCreateManyAcademyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserAcademyCEOCreateNestedManyWithoutAcademyInput = {
    create?: XOR<UserAcademyCEOCreateWithoutAcademyInput, UserAcademyCEOUncheckedCreateWithoutAcademyInput> | UserAcademyCEOCreateWithoutAcademyInput[] | UserAcademyCEOUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: UserAcademyCEOCreateOrConnectWithoutAcademyInput | UserAcademyCEOCreateOrConnectWithoutAcademyInput[]
    createMany?: UserAcademyCEOCreateManyAcademyInputEnvelope
    connect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutAcademyInput = {
    create?: XOR<CourseCreateWithoutAcademyInput, CourseUncheckedCreateWithoutAcademyInput> | CourseCreateWithoutAcademyInput[] | CourseUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademyInput | CourseCreateOrConnectWithoutAcademyInput[]
    createMany?: CourseCreateManyAcademyInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type InstructorCreateNestedManyWithoutAcademyInput = {
    create?: XOR<InstructorCreateWithoutAcademyInput, InstructorUncheckedCreateWithoutAcademyInput> | InstructorCreateWithoutAcademyInput[] | InstructorUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutAcademyInput | InstructorCreateOrConnectWithoutAcademyInput[]
    createMany?: InstructorCreateManyAcademyInputEnvelope
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutAcademyInput = {
    create?: XOR<EventCreateWithoutAcademyInput, EventUncheckedCreateWithoutAcademyInput> | EventCreateWithoutAcademyInput[] | EventUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAcademyInput | EventCreateOrConnectWithoutAcademyInput[]
    createMany?: EventCreateManyAcademyInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type AccountingEntryCreateNestedManyWithoutAcademyInput = {
    create?: XOR<AccountingEntryCreateWithoutAcademyInput, AccountingEntryUncheckedCreateWithoutAcademyInput> | AccountingEntryCreateWithoutAcademyInput[] | AccountingEntryUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutAcademyInput | AccountingEntryCreateOrConnectWithoutAcademyInput[]
    createMany?: AccountingEntryCreateManyAcademyInputEnvelope
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
  }

  export type PublicRelationsRecordCreateNestedManyWithoutAcademyInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutAcademyInput, PublicRelationsRecordUncheckedCreateWithoutAcademyInput> | PublicRelationsRecordCreateWithoutAcademyInput[] | PublicRelationsRecordUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutAcademyInput | PublicRelationsRecordCreateOrConnectWithoutAcademyInput[]
    createMany?: PublicRelationsRecordCreateManyAcademyInputEnvelope
    connect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutAcademyInput = {
    create?: XOR<MeetingCreateWithoutAcademyInput, MeetingUncheckedCreateWithoutAcademyInput> | MeetingCreateWithoutAcademyInput[] | MeetingUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutAcademyInput | MeetingCreateOrConnectWithoutAcademyInput[]
    createMany?: MeetingCreateManyAcademyInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type LegalCaseCreateNestedManyWithoutAcademyInput = {
    create?: XOR<LegalCaseCreateWithoutAcademyInput, LegalCaseUncheckedCreateWithoutAcademyInput> | LegalCaseCreateWithoutAcademyInput[] | LegalCaseUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutAcademyInput | LegalCaseCreateOrConnectWithoutAcademyInput[]
    createMany?: LegalCaseCreateManyAcademyInputEnvelope
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAcademyInput = {
    create?: XOR<UserCreateWithoutAcademyInput, UserUncheckedCreateWithoutAcademyInput> | UserCreateWithoutAcademyInput[] | UserUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAcademyInput | UserCreateOrConnectWithoutAcademyInput[]
    createMany?: UserCreateManyAcademyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserAcademyCEOUncheckedCreateNestedManyWithoutAcademyInput = {
    create?: XOR<UserAcademyCEOCreateWithoutAcademyInput, UserAcademyCEOUncheckedCreateWithoutAcademyInput> | UserAcademyCEOCreateWithoutAcademyInput[] | UserAcademyCEOUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: UserAcademyCEOCreateOrConnectWithoutAcademyInput | UserAcademyCEOCreateOrConnectWithoutAcademyInput[]
    createMany?: UserAcademyCEOCreateManyAcademyInputEnvelope
    connect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutAcademyInput = {
    create?: XOR<CourseCreateWithoutAcademyInput, CourseUncheckedCreateWithoutAcademyInput> | CourseCreateWithoutAcademyInput[] | CourseUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademyInput | CourseCreateOrConnectWithoutAcademyInput[]
    createMany?: CourseCreateManyAcademyInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type InstructorUncheckedCreateNestedManyWithoutAcademyInput = {
    create?: XOR<InstructorCreateWithoutAcademyInput, InstructorUncheckedCreateWithoutAcademyInput> | InstructorCreateWithoutAcademyInput[] | InstructorUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutAcademyInput | InstructorCreateOrConnectWithoutAcademyInput[]
    createMany?: InstructorCreateManyAcademyInputEnvelope
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutAcademyInput = {
    create?: XOR<EventCreateWithoutAcademyInput, EventUncheckedCreateWithoutAcademyInput> | EventCreateWithoutAcademyInput[] | EventUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAcademyInput | EventCreateOrConnectWithoutAcademyInput[]
    createMany?: EventCreateManyAcademyInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type AccountingEntryUncheckedCreateNestedManyWithoutAcademyInput = {
    create?: XOR<AccountingEntryCreateWithoutAcademyInput, AccountingEntryUncheckedCreateWithoutAcademyInput> | AccountingEntryCreateWithoutAcademyInput[] | AccountingEntryUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutAcademyInput | AccountingEntryCreateOrConnectWithoutAcademyInput[]
    createMany?: AccountingEntryCreateManyAcademyInputEnvelope
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
  }

  export type PublicRelationsRecordUncheckedCreateNestedManyWithoutAcademyInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutAcademyInput, PublicRelationsRecordUncheckedCreateWithoutAcademyInput> | PublicRelationsRecordCreateWithoutAcademyInput[] | PublicRelationsRecordUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutAcademyInput | PublicRelationsRecordCreateOrConnectWithoutAcademyInput[]
    createMany?: PublicRelationsRecordCreateManyAcademyInputEnvelope
    connect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutAcademyInput = {
    create?: XOR<MeetingCreateWithoutAcademyInput, MeetingUncheckedCreateWithoutAcademyInput> | MeetingCreateWithoutAcademyInput[] | MeetingUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutAcademyInput | MeetingCreateOrConnectWithoutAcademyInput[]
    createMany?: MeetingCreateManyAcademyInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type LegalCaseUncheckedCreateNestedManyWithoutAcademyInput = {
    create?: XOR<LegalCaseCreateWithoutAcademyInput, LegalCaseUncheckedCreateWithoutAcademyInput> | LegalCaseCreateWithoutAcademyInput[] | LegalCaseUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutAcademyInput | LegalCaseCreateOrConnectWithoutAcademyInput[]
    createMany?: LegalCaseCreateManyAcademyInputEnvelope
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<UserCreateWithoutAcademyInput, UserUncheckedCreateWithoutAcademyInput> | UserCreateWithoutAcademyInput[] | UserUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAcademyInput | UserCreateOrConnectWithoutAcademyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAcademyInput | UserUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: UserCreateManyAcademyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAcademyInput | UserUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAcademyInput | UserUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserAcademyCEOUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<UserAcademyCEOCreateWithoutAcademyInput, UserAcademyCEOUncheckedCreateWithoutAcademyInput> | UserAcademyCEOCreateWithoutAcademyInput[] | UserAcademyCEOUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: UserAcademyCEOCreateOrConnectWithoutAcademyInput | UserAcademyCEOCreateOrConnectWithoutAcademyInput[]
    upsert?: UserAcademyCEOUpsertWithWhereUniqueWithoutAcademyInput | UserAcademyCEOUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: UserAcademyCEOCreateManyAcademyInputEnvelope
    set?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    disconnect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    delete?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    connect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    update?: UserAcademyCEOUpdateWithWhereUniqueWithoutAcademyInput | UserAcademyCEOUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: UserAcademyCEOUpdateManyWithWhereWithoutAcademyInput | UserAcademyCEOUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: UserAcademyCEOScalarWhereInput | UserAcademyCEOScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<CourseCreateWithoutAcademyInput, CourseUncheckedCreateWithoutAcademyInput> | CourseCreateWithoutAcademyInput[] | CourseUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademyInput | CourseCreateOrConnectWithoutAcademyInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutAcademyInput | CourseUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: CourseCreateManyAcademyInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutAcademyInput | CourseUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutAcademyInput | CourseUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type InstructorUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<InstructorCreateWithoutAcademyInput, InstructorUncheckedCreateWithoutAcademyInput> | InstructorCreateWithoutAcademyInput[] | InstructorUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutAcademyInput | InstructorCreateOrConnectWithoutAcademyInput[]
    upsert?: InstructorUpsertWithWhereUniqueWithoutAcademyInput | InstructorUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: InstructorCreateManyAcademyInputEnvelope
    set?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    disconnect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    delete?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    update?: InstructorUpdateWithWhereUniqueWithoutAcademyInput | InstructorUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: InstructorUpdateManyWithWhereWithoutAcademyInput | InstructorUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
  }

  export type EventUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<EventCreateWithoutAcademyInput, EventUncheckedCreateWithoutAcademyInput> | EventCreateWithoutAcademyInput[] | EventUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAcademyInput | EventCreateOrConnectWithoutAcademyInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutAcademyInput | EventUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: EventCreateManyAcademyInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutAcademyInput | EventUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: EventUpdateManyWithWhereWithoutAcademyInput | EventUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type AccountingEntryUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<AccountingEntryCreateWithoutAcademyInput, AccountingEntryUncheckedCreateWithoutAcademyInput> | AccountingEntryCreateWithoutAcademyInput[] | AccountingEntryUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutAcademyInput | AccountingEntryCreateOrConnectWithoutAcademyInput[]
    upsert?: AccountingEntryUpsertWithWhereUniqueWithoutAcademyInput | AccountingEntryUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: AccountingEntryCreateManyAcademyInputEnvelope
    set?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    disconnect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    delete?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    update?: AccountingEntryUpdateWithWhereUniqueWithoutAcademyInput | AccountingEntryUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: AccountingEntryUpdateManyWithWhereWithoutAcademyInput | AccountingEntryUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: AccountingEntryScalarWhereInput | AccountingEntryScalarWhereInput[]
  }

  export type PublicRelationsRecordUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutAcademyInput, PublicRelationsRecordUncheckedCreateWithoutAcademyInput> | PublicRelationsRecordCreateWithoutAcademyInput[] | PublicRelationsRecordUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutAcademyInput | PublicRelationsRecordCreateOrConnectWithoutAcademyInput[]
    upsert?: PublicRelationsRecordUpsertWithWhereUniqueWithoutAcademyInput | PublicRelationsRecordUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: PublicRelationsRecordCreateManyAcademyInputEnvelope
    set?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    disconnect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    delete?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    connect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    update?: PublicRelationsRecordUpdateWithWhereUniqueWithoutAcademyInput | PublicRelationsRecordUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: PublicRelationsRecordUpdateManyWithWhereWithoutAcademyInput | PublicRelationsRecordUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: PublicRelationsRecordScalarWhereInput | PublicRelationsRecordScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<MeetingCreateWithoutAcademyInput, MeetingUncheckedCreateWithoutAcademyInput> | MeetingCreateWithoutAcademyInput[] | MeetingUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutAcademyInput | MeetingCreateOrConnectWithoutAcademyInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutAcademyInput | MeetingUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: MeetingCreateManyAcademyInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutAcademyInput | MeetingUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutAcademyInput | MeetingUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type LegalCaseUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<LegalCaseCreateWithoutAcademyInput, LegalCaseUncheckedCreateWithoutAcademyInput> | LegalCaseCreateWithoutAcademyInput[] | LegalCaseUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutAcademyInput | LegalCaseCreateOrConnectWithoutAcademyInput[]
    upsert?: LegalCaseUpsertWithWhereUniqueWithoutAcademyInput | LegalCaseUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: LegalCaseCreateManyAcademyInputEnvelope
    set?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    disconnect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    delete?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    update?: LegalCaseUpdateWithWhereUniqueWithoutAcademyInput | LegalCaseUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: LegalCaseUpdateManyWithWhereWithoutAcademyInput | LegalCaseUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: LegalCaseScalarWhereInput | LegalCaseScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<UserCreateWithoutAcademyInput, UserUncheckedCreateWithoutAcademyInput> | UserCreateWithoutAcademyInput[] | UserUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAcademyInput | UserCreateOrConnectWithoutAcademyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAcademyInput | UserUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: UserCreateManyAcademyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAcademyInput | UserUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAcademyInput | UserUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserAcademyCEOUncheckedUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<UserAcademyCEOCreateWithoutAcademyInput, UserAcademyCEOUncheckedCreateWithoutAcademyInput> | UserAcademyCEOCreateWithoutAcademyInput[] | UserAcademyCEOUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: UserAcademyCEOCreateOrConnectWithoutAcademyInput | UserAcademyCEOCreateOrConnectWithoutAcademyInput[]
    upsert?: UserAcademyCEOUpsertWithWhereUniqueWithoutAcademyInput | UserAcademyCEOUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: UserAcademyCEOCreateManyAcademyInputEnvelope
    set?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    disconnect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    delete?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    connect?: UserAcademyCEOWhereUniqueInput | UserAcademyCEOWhereUniqueInput[]
    update?: UserAcademyCEOUpdateWithWhereUniqueWithoutAcademyInput | UserAcademyCEOUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: UserAcademyCEOUpdateManyWithWhereWithoutAcademyInput | UserAcademyCEOUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: UserAcademyCEOScalarWhereInput | UserAcademyCEOScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<CourseCreateWithoutAcademyInput, CourseUncheckedCreateWithoutAcademyInput> | CourseCreateWithoutAcademyInput[] | CourseUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutAcademyInput | CourseCreateOrConnectWithoutAcademyInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutAcademyInput | CourseUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: CourseCreateManyAcademyInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutAcademyInput | CourseUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutAcademyInput | CourseUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type InstructorUncheckedUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<InstructorCreateWithoutAcademyInput, InstructorUncheckedCreateWithoutAcademyInput> | InstructorCreateWithoutAcademyInput[] | InstructorUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutAcademyInput | InstructorCreateOrConnectWithoutAcademyInput[]
    upsert?: InstructorUpsertWithWhereUniqueWithoutAcademyInput | InstructorUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: InstructorCreateManyAcademyInputEnvelope
    set?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    disconnect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    delete?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    update?: InstructorUpdateWithWhereUniqueWithoutAcademyInput | InstructorUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: InstructorUpdateManyWithWhereWithoutAcademyInput | InstructorUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<EventCreateWithoutAcademyInput, EventUncheckedCreateWithoutAcademyInput> | EventCreateWithoutAcademyInput[] | EventUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAcademyInput | EventCreateOrConnectWithoutAcademyInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutAcademyInput | EventUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: EventCreateManyAcademyInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutAcademyInput | EventUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: EventUpdateManyWithWhereWithoutAcademyInput | EventUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type AccountingEntryUncheckedUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<AccountingEntryCreateWithoutAcademyInput, AccountingEntryUncheckedCreateWithoutAcademyInput> | AccountingEntryCreateWithoutAcademyInput[] | AccountingEntryUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutAcademyInput | AccountingEntryCreateOrConnectWithoutAcademyInput[]
    upsert?: AccountingEntryUpsertWithWhereUniqueWithoutAcademyInput | AccountingEntryUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: AccountingEntryCreateManyAcademyInputEnvelope
    set?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    disconnect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    delete?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    update?: AccountingEntryUpdateWithWhereUniqueWithoutAcademyInput | AccountingEntryUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: AccountingEntryUpdateManyWithWhereWithoutAcademyInput | AccountingEntryUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: AccountingEntryScalarWhereInput | AccountingEntryScalarWhereInput[]
  }

  export type PublicRelationsRecordUncheckedUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutAcademyInput, PublicRelationsRecordUncheckedCreateWithoutAcademyInput> | PublicRelationsRecordCreateWithoutAcademyInput[] | PublicRelationsRecordUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutAcademyInput | PublicRelationsRecordCreateOrConnectWithoutAcademyInput[]
    upsert?: PublicRelationsRecordUpsertWithWhereUniqueWithoutAcademyInput | PublicRelationsRecordUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: PublicRelationsRecordCreateManyAcademyInputEnvelope
    set?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    disconnect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    delete?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    connect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    update?: PublicRelationsRecordUpdateWithWhereUniqueWithoutAcademyInput | PublicRelationsRecordUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: PublicRelationsRecordUpdateManyWithWhereWithoutAcademyInput | PublicRelationsRecordUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: PublicRelationsRecordScalarWhereInput | PublicRelationsRecordScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<MeetingCreateWithoutAcademyInput, MeetingUncheckedCreateWithoutAcademyInput> | MeetingCreateWithoutAcademyInput[] | MeetingUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutAcademyInput | MeetingCreateOrConnectWithoutAcademyInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutAcademyInput | MeetingUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: MeetingCreateManyAcademyInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutAcademyInput | MeetingUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutAcademyInput | MeetingUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type LegalCaseUncheckedUpdateManyWithoutAcademyNestedInput = {
    create?: XOR<LegalCaseCreateWithoutAcademyInput, LegalCaseUncheckedCreateWithoutAcademyInput> | LegalCaseCreateWithoutAcademyInput[] | LegalCaseUncheckedCreateWithoutAcademyInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutAcademyInput | LegalCaseCreateOrConnectWithoutAcademyInput[]
    upsert?: LegalCaseUpsertWithWhereUniqueWithoutAcademyInput | LegalCaseUpsertWithWhereUniqueWithoutAcademyInput[]
    createMany?: LegalCaseCreateManyAcademyInputEnvelope
    set?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    disconnect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    delete?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    update?: LegalCaseUpdateWithWhereUniqueWithoutAcademyInput | LegalCaseUpdateWithWhereUniqueWithoutAcademyInput[]
    updateMany?: LegalCaseUpdateManyWithWhereWithoutAcademyInput | LegalCaseUpdateManyWithWhereWithoutAcademyInput[]
    deleteMany?: LegalCaseScalarWhereInput | LegalCaseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInstructorInput = {
    create?: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstructorInput
    connect?: UserWhereUniqueInput
  }

  export type AcademyCreateNestedOneWithoutInstructorsInput = {
    create?: XOR<AcademyCreateWithoutInstructorsInput, AcademyUncheckedCreateWithoutInstructorsInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutInstructorsInput
    connect?: AcademyWhereUniqueInput
  }

  export type CourseCreateNestedManyWithoutInstructorsInput = {
    create?: XOR<CourseCreateWithoutInstructorsInput, CourseUncheckedCreateWithoutInstructorsInput> | CourseCreateWithoutInstructorsInput[] | CourseUncheckedCreateWithoutInstructorsInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutInstructorsInput | CourseCreateOrConnectWithoutInstructorsInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutInstructorsInput = {
    create?: XOR<CourseCreateWithoutInstructorsInput, CourseUncheckedCreateWithoutInstructorsInput> | CourseCreateWithoutInstructorsInput[] | CourseUncheckedCreateWithoutInstructorsInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutInstructorsInput | CourseCreateOrConnectWithoutInstructorsInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutInstructorNestedInput = {
    create?: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
    connectOrCreate?: UserCreateOrConnectWithoutInstructorInput
    upsert?: UserUpsertWithoutInstructorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInstructorInput, UserUpdateWithoutInstructorInput>, UserUncheckedUpdateWithoutInstructorInput>
  }

  export type AcademyUpdateOneRequiredWithoutInstructorsNestedInput = {
    create?: XOR<AcademyCreateWithoutInstructorsInput, AcademyUncheckedCreateWithoutInstructorsInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutInstructorsInput
    upsert?: AcademyUpsertWithoutInstructorsInput
    connect?: AcademyWhereUniqueInput
    update?: XOR<XOR<AcademyUpdateToOneWithWhereWithoutInstructorsInput, AcademyUpdateWithoutInstructorsInput>, AcademyUncheckedUpdateWithoutInstructorsInput>
  }

  export type CourseUpdateManyWithoutInstructorsNestedInput = {
    create?: XOR<CourseCreateWithoutInstructorsInput, CourseUncheckedCreateWithoutInstructorsInput> | CourseCreateWithoutInstructorsInput[] | CourseUncheckedCreateWithoutInstructorsInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutInstructorsInput | CourseCreateOrConnectWithoutInstructorsInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutInstructorsInput | CourseUpsertWithWhereUniqueWithoutInstructorsInput[]
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutInstructorsInput | CourseUpdateWithWhereUniqueWithoutInstructorsInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutInstructorsInput | CourseUpdateManyWithWhereWithoutInstructorsInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutInstructorsNestedInput = {
    create?: XOR<CourseCreateWithoutInstructorsInput, CourseUncheckedCreateWithoutInstructorsInput> | CourseCreateWithoutInstructorsInput[] | CourseUncheckedCreateWithoutInstructorsInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutInstructorsInput | CourseCreateOrConnectWithoutInstructorsInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutInstructorsInput | CourseUpsertWithWhereUniqueWithoutInstructorsInput[]
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutInstructorsInput | CourseUpdateWithWhereUniqueWithoutInstructorsInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutInstructorsInput | CourseUpdateManyWithWhereWithoutInstructorsInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type AcademyCreateNestedOneWithoutCoursesInput = {
    create?: XOR<AcademyCreateWithoutCoursesInput, AcademyUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutCoursesInput
    connect?: AcademyWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutCourseInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type QuizCreateNestedManyWithoutCourseInput = {
    create?: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput> | QuizCreateWithoutCourseInput[] | QuizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCourseInput | QuizCreateOrConnectWithoutCourseInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type InstructorCreateNestedManyWithoutCoursesInput = {
    create?: XOR<InstructorCreateWithoutCoursesInput, InstructorUncheckedCreateWithoutCoursesInput> | InstructorCreateWithoutCoursesInput[] | InstructorUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutCoursesInput | InstructorCreateOrConnectWithoutCoursesInput[]
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
  }

  export type LiveRoomCreateNestedManyWithoutCourseInput = {
    create?: XOR<LiveRoomCreateWithoutCourseInput, LiveRoomUncheckedCreateWithoutCourseInput> | LiveRoomCreateWithoutCourseInput[] | LiveRoomUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutCourseInput | LiveRoomCreateOrConnectWithoutCourseInput[]
    createMany?: LiveRoomCreateManyCourseInputEnvelope
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
  }

  export type PathCreateNestedManyWithoutCoursesInput = {
    create?: XOR<PathCreateWithoutCoursesInput, PathUncheckedCreateWithoutCoursesInput> | PathCreateWithoutCoursesInput[] | PathUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: PathCreateOrConnectWithoutCoursesInput | PathCreateOrConnectWithoutCoursesInput[]
    connect?: PathWhereUniqueInput | PathWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput> | QuizCreateWithoutCourseInput[] | QuizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCourseInput | QuizCreateOrConnectWithoutCourseInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type InstructorUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<InstructorCreateWithoutCoursesInput, InstructorUncheckedCreateWithoutCoursesInput> | InstructorCreateWithoutCoursesInput[] | InstructorUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutCoursesInput | InstructorCreateOrConnectWithoutCoursesInput[]
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
  }

  export type LiveRoomUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LiveRoomCreateWithoutCourseInput, LiveRoomUncheckedCreateWithoutCourseInput> | LiveRoomCreateWithoutCourseInput[] | LiveRoomUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutCourseInput | LiveRoomCreateOrConnectWithoutCourseInput[]
    createMany?: LiveRoomCreateManyCourseInputEnvelope
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
  }

  export type PathUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<PathCreateWithoutCoursesInput, PathUncheckedCreateWithoutCoursesInput> | PathCreateWithoutCoursesInput[] | PathUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: PathCreateOrConnectWithoutCoursesInput | PathCreateOrConnectWithoutCoursesInput[]
    connect?: PathWhereUniqueInput | PathWhereUniqueInput[]
  }

  export type EnumCourseStatusFieldUpdateOperationsInput = {
    set?: $Enums.CourseStatus
  }

  export type AcademyUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<AcademyCreateWithoutCoursesInput, AcademyUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutCoursesInput
    upsert?: AcademyUpsertWithoutCoursesInput
    connect?: AcademyWhereUniqueInput
    update?: XOR<XOR<AcademyUpdateToOneWithWhereWithoutCoursesInput, AcademyUpdateWithoutCoursesInput>, AcademyUncheckedUpdateWithoutCoursesInput>
  }

  export type LessonUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutCourseInput | LessonUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutCourseInput | LessonUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutCourseInput | LessonUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type QuizUpdateManyWithoutCourseNestedInput = {
    create?: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput> | QuizCreateWithoutCourseInput[] | QuizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCourseInput | QuizCreateOrConnectWithoutCourseInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutCourseInput | QuizUpsertWithWhereUniqueWithoutCourseInput[]
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutCourseInput | QuizUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutCourseInput | QuizUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type InstructorUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<InstructorCreateWithoutCoursesInput, InstructorUncheckedCreateWithoutCoursesInput> | InstructorCreateWithoutCoursesInput[] | InstructorUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutCoursesInput | InstructorCreateOrConnectWithoutCoursesInput[]
    upsert?: InstructorUpsertWithWhereUniqueWithoutCoursesInput | InstructorUpsertWithWhereUniqueWithoutCoursesInput[]
    set?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    disconnect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    delete?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    update?: InstructorUpdateWithWhereUniqueWithoutCoursesInput | InstructorUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: InstructorUpdateManyWithWhereWithoutCoursesInput | InstructorUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
  }

  export type LiveRoomUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LiveRoomCreateWithoutCourseInput, LiveRoomUncheckedCreateWithoutCourseInput> | LiveRoomCreateWithoutCourseInput[] | LiveRoomUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutCourseInput | LiveRoomCreateOrConnectWithoutCourseInput[]
    upsert?: LiveRoomUpsertWithWhereUniqueWithoutCourseInput | LiveRoomUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LiveRoomCreateManyCourseInputEnvelope
    set?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    disconnect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    delete?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    update?: LiveRoomUpdateWithWhereUniqueWithoutCourseInput | LiveRoomUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LiveRoomUpdateManyWithWhereWithoutCourseInput | LiveRoomUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LiveRoomScalarWhereInput | LiveRoomScalarWhereInput[]
  }

  export type PathUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<PathCreateWithoutCoursesInput, PathUncheckedCreateWithoutCoursesInput> | PathCreateWithoutCoursesInput[] | PathUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: PathCreateOrConnectWithoutCoursesInput | PathCreateOrConnectWithoutCoursesInput[]
    upsert?: PathUpsertWithWhereUniqueWithoutCoursesInput | PathUpsertWithWhereUniqueWithoutCoursesInput[]
    set?: PathWhereUniqueInput | PathWhereUniqueInput[]
    disconnect?: PathWhereUniqueInput | PathWhereUniqueInput[]
    delete?: PathWhereUniqueInput | PathWhereUniqueInput[]
    connect?: PathWhereUniqueInput | PathWhereUniqueInput[]
    update?: PathUpdateWithWhereUniqueWithoutCoursesInput | PathUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: PathUpdateManyWithWhereWithoutCoursesInput | PathUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: PathScalarWhereInput | PathScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput> | LessonCreateWithoutCourseInput[] | LessonUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutCourseInput | LessonCreateOrConnectWithoutCourseInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutCourseInput | LessonUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LessonCreateManyCourseInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutCourseInput | LessonUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutCourseInput | LessonUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput> | EnrollmentCreateWithoutCourseInput[] | EnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutCourseInput | EnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutCourseInput | EnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnrollmentCreateManyCourseInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutCourseInput | EnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutCourseInput | EnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput> | QuizCreateWithoutCourseInput[] | QuizUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutCourseInput | QuizCreateOrConnectWithoutCourseInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutCourseInput | QuizUpsertWithWhereUniqueWithoutCourseInput[]
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutCourseInput | QuizUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutCourseInput | QuizUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type InstructorUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<InstructorCreateWithoutCoursesInput, InstructorUncheckedCreateWithoutCoursesInput> | InstructorCreateWithoutCoursesInput[] | InstructorUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: InstructorCreateOrConnectWithoutCoursesInput | InstructorCreateOrConnectWithoutCoursesInput[]
    upsert?: InstructorUpsertWithWhereUniqueWithoutCoursesInput | InstructorUpsertWithWhereUniqueWithoutCoursesInput[]
    set?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    disconnect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    delete?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    connect?: InstructorWhereUniqueInput | InstructorWhereUniqueInput[]
    update?: InstructorUpdateWithWhereUniqueWithoutCoursesInput | InstructorUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: InstructorUpdateManyWithWhereWithoutCoursesInput | InstructorUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
  }

  export type LiveRoomUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LiveRoomCreateWithoutCourseInput, LiveRoomUncheckedCreateWithoutCourseInput> | LiveRoomCreateWithoutCourseInput[] | LiveRoomUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutCourseInput | LiveRoomCreateOrConnectWithoutCourseInput[]
    upsert?: LiveRoomUpsertWithWhereUniqueWithoutCourseInput | LiveRoomUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LiveRoomCreateManyCourseInputEnvelope
    set?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    disconnect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    delete?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    update?: LiveRoomUpdateWithWhereUniqueWithoutCourseInput | LiveRoomUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LiveRoomUpdateManyWithWhereWithoutCourseInput | LiveRoomUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LiveRoomScalarWhereInput | LiveRoomScalarWhereInput[]
  }

  export type PathUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<PathCreateWithoutCoursesInput, PathUncheckedCreateWithoutCoursesInput> | PathCreateWithoutCoursesInput[] | PathUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: PathCreateOrConnectWithoutCoursesInput | PathCreateOrConnectWithoutCoursesInput[]
    upsert?: PathUpsertWithWhereUniqueWithoutCoursesInput | PathUpsertWithWhereUniqueWithoutCoursesInput[]
    set?: PathWhereUniqueInput | PathWhereUniqueInput[]
    disconnect?: PathWhereUniqueInput | PathWhereUniqueInput[]
    delete?: PathWhereUniqueInput | PathWhereUniqueInput[]
    connect?: PathWhereUniqueInput | PathWhereUniqueInput[]
    update?: PathUpdateWithWhereUniqueWithoutCoursesInput | PathUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: PathUpdateManyWithWhereWithoutCoursesInput | PathUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: PathScalarWhereInput | PathScalarWhereInput[]
  }

  export type MilestoneCreateNestedManyWithoutPathInput = {
    create?: XOR<MilestoneCreateWithoutPathInput, MilestoneUncheckedCreateWithoutPathInput> | MilestoneCreateWithoutPathInput[] | MilestoneUncheckedCreateWithoutPathInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutPathInput | MilestoneCreateOrConnectWithoutPathInput[]
    createMany?: MilestoneCreateManyPathInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutPathInput = {
    create?: XOR<CourseCreateWithoutPathInput, CourseUncheckedCreateWithoutPathInput> | CourseCreateWithoutPathInput[] | CourseUncheckedCreateWithoutPathInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutPathInput | CourseCreateOrConnectWithoutPathInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutPathInput = {
    create?: XOR<UserCreateWithoutPathInput, UserUncheckedCreateWithoutPathInput> | UserCreateWithoutPathInput[] | UserUncheckedCreateWithoutPathInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPathInput | UserCreateOrConnectWithoutPathInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutPathInput = {
    create?: XOR<MilestoneCreateWithoutPathInput, MilestoneUncheckedCreateWithoutPathInput> | MilestoneCreateWithoutPathInput[] | MilestoneUncheckedCreateWithoutPathInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutPathInput | MilestoneCreateOrConnectWithoutPathInput[]
    createMany?: MilestoneCreateManyPathInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutPathInput = {
    create?: XOR<CourseCreateWithoutPathInput, CourseUncheckedCreateWithoutPathInput> | CourseCreateWithoutPathInput[] | CourseUncheckedCreateWithoutPathInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutPathInput | CourseCreateOrConnectWithoutPathInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutPathInput = {
    create?: XOR<UserCreateWithoutPathInput, UserUncheckedCreateWithoutPathInput> | UserCreateWithoutPathInput[] | UserUncheckedCreateWithoutPathInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPathInput | UserCreateOrConnectWithoutPathInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MilestoneUpdateManyWithoutPathNestedInput = {
    create?: XOR<MilestoneCreateWithoutPathInput, MilestoneUncheckedCreateWithoutPathInput> | MilestoneCreateWithoutPathInput[] | MilestoneUncheckedCreateWithoutPathInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutPathInput | MilestoneCreateOrConnectWithoutPathInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutPathInput | MilestoneUpsertWithWhereUniqueWithoutPathInput[]
    createMany?: MilestoneCreateManyPathInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutPathInput | MilestoneUpdateWithWhereUniqueWithoutPathInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutPathInput | MilestoneUpdateManyWithWhereWithoutPathInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutPathNestedInput = {
    create?: XOR<CourseCreateWithoutPathInput, CourseUncheckedCreateWithoutPathInput> | CourseCreateWithoutPathInput[] | CourseUncheckedCreateWithoutPathInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutPathInput | CourseCreateOrConnectWithoutPathInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutPathInput | CourseUpsertWithWhereUniqueWithoutPathInput[]
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutPathInput | CourseUpdateWithWhereUniqueWithoutPathInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutPathInput | CourseUpdateManyWithWhereWithoutPathInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserUpdateManyWithoutPathNestedInput = {
    create?: XOR<UserCreateWithoutPathInput, UserUncheckedCreateWithoutPathInput> | UserCreateWithoutPathInput[] | UserUncheckedCreateWithoutPathInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPathInput | UserCreateOrConnectWithoutPathInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPathInput | UserUpsertWithWhereUniqueWithoutPathInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPathInput | UserUpdateWithWhereUniqueWithoutPathInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPathInput | UserUpdateManyWithWhereWithoutPathInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutPathNestedInput = {
    create?: XOR<MilestoneCreateWithoutPathInput, MilestoneUncheckedCreateWithoutPathInput> | MilestoneCreateWithoutPathInput[] | MilestoneUncheckedCreateWithoutPathInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutPathInput | MilestoneCreateOrConnectWithoutPathInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutPathInput | MilestoneUpsertWithWhereUniqueWithoutPathInput[]
    createMany?: MilestoneCreateManyPathInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutPathInput | MilestoneUpdateWithWhereUniqueWithoutPathInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutPathInput | MilestoneUpdateManyWithWhereWithoutPathInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutPathNestedInput = {
    create?: XOR<CourseCreateWithoutPathInput, CourseUncheckedCreateWithoutPathInput> | CourseCreateWithoutPathInput[] | CourseUncheckedCreateWithoutPathInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutPathInput | CourseCreateOrConnectWithoutPathInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutPathInput | CourseUpsertWithWhereUniqueWithoutPathInput[]
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutPathInput | CourseUpdateWithWhereUniqueWithoutPathInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutPathInput | CourseUpdateManyWithWhereWithoutPathInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutPathNestedInput = {
    create?: XOR<UserCreateWithoutPathInput, UserUncheckedCreateWithoutPathInput> | UserCreateWithoutPathInput[] | UserUncheckedCreateWithoutPathInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPathInput | UserCreateOrConnectWithoutPathInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPathInput | UserUpsertWithWhereUniqueWithoutPathInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPathInput | UserUpdateWithWhereUniqueWithoutPathInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPathInput | UserUpdateManyWithWhereWithoutPathInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PathCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<PathCreateWithoutMilestonesInput, PathUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: PathCreateOrConnectWithoutMilestonesInput
    connect?: PathWhereUniqueInput
  }

  export type EnumMilestoneStatusFieldUpdateOperationsInput = {
    set?: $Enums.MilestoneStatus
  }

  export type PathUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<PathCreateWithoutMilestonesInput, PathUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: PathCreateOrConnectWithoutMilestonesInput
    upsert?: PathUpsertWithoutMilestonesInput
    connect?: PathWhereUniqueInput
    update?: XOR<XOR<PathUpdateToOneWithWhereWithoutMilestonesInput, PathUpdateWithoutMilestonesInput>, PathUncheckedUpdateWithoutMilestonesInput>
  }

  export type CourseCreateNestedOneWithoutLessonsInput = {
    create?: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLessonsInput
    connect?: CourseWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutLessonInput = {
    create?: XOR<FileCreateWithoutLessonInput, FileUncheckedCreateWithoutLessonInput> | FileCreateWithoutLessonInput[] | FileUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLessonInput | FileCreateOrConnectWithoutLessonInput[]
    createMany?: FileCreateManyLessonInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type QuizCreateNestedManyWithoutLessonInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutLessonInput = {
    create?: XOR<UserCreateWithoutLessonInput, UserUncheckedCreateWithoutLessonInput> | UserCreateWithoutLessonInput[] | UserUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLessonInput | UserCreateOrConnectWithoutLessonInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutLessonInput = {
    create?: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput> | AttendanceCreateWithoutLessonInput[] | AttendanceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutLessonInput | AttendanceCreateOrConnectWithoutLessonInput[]
    createMany?: AttendanceCreateManyLessonInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<FileCreateWithoutLessonInput, FileUncheckedCreateWithoutLessonInput> | FileCreateWithoutLessonInput[] | FileUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLessonInput | FileCreateOrConnectWithoutLessonInput[]
    createMany?: FileCreateManyLessonInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<UserCreateWithoutLessonInput, UserUncheckedCreateWithoutLessonInput> | UserCreateWithoutLessonInput[] | UserUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLessonInput | UserCreateOrConnectWithoutLessonInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput> | AttendanceCreateWithoutLessonInput[] | AttendanceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutLessonInput | AttendanceCreateOrConnectWithoutLessonInput[]
    createMany?: AttendanceCreateManyLessonInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type EnumLessonStatusFieldUpdateOperationsInput = {
    set?: $Enums.LessonStatus
  }

  export type CourseUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLessonsInput
    upsert?: CourseUpsertWithoutLessonsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLessonsInput, CourseUpdateWithoutLessonsInput>, CourseUncheckedUpdateWithoutLessonsInput>
  }

  export type FileUpdateManyWithoutLessonNestedInput = {
    create?: XOR<FileCreateWithoutLessonInput, FileUncheckedCreateWithoutLessonInput> | FileCreateWithoutLessonInput[] | FileUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLessonInput | FileCreateOrConnectWithoutLessonInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutLessonInput | FileUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: FileCreateManyLessonInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutLessonInput | FileUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: FileUpdateManyWithWhereWithoutLessonInput | FileUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type QuizUpdateManyWithoutLessonNestedInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutLessonInput | QuizUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutLessonInput | QuizUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutLessonInput | QuizUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type UserUpdateManyWithoutLessonNestedInput = {
    create?: XOR<UserCreateWithoutLessonInput, UserUncheckedCreateWithoutLessonInput> | UserCreateWithoutLessonInput[] | UserUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLessonInput | UserCreateOrConnectWithoutLessonInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLessonInput | UserUpsertWithWhereUniqueWithoutLessonInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLessonInput | UserUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLessonInput | UserUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutLessonNestedInput = {
    create?: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput> | AttendanceCreateWithoutLessonInput[] | AttendanceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutLessonInput | AttendanceCreateOrConnectWithoutLessonInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutLessonInput | AttendanceUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: AttendanceCreateManyLessonInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutLessonInput | AttendanceUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutLessonInput | AttendanceUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<FileCreateWithoutLessonInput, FileUncheckedCreateWithoutLessonInput> | FileCreateWithoutLessonInput[] | FileUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLessonInput | FileCreateOrConnectWithoutLessonInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutLessonInput | FileUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: FileCreateManyLessonInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutLessonInput | FileUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: FileUpdateManyWithWhereWithoutLessonInput | FileUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput> | QuizCreateWithoutLessonInput[] | QuizUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutLessonInput | QuizCreateOrConnectWithoutLessonInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutLessonInput | QuizUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: QuizCreateManyLessonInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutLessonInput | QuizUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutLessonInput | QuizUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<UserCreateWithoutLessonInput, UserUncheckedCreateWithoutLessonInput> | UserCreateWithoutLessonInput[] | UserUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLessonInput | UserCreateOrConnectWithoutLessonInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLessonInput | UserUpsertWithWhereUniqueWithoutLessonInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLessonInput | UserUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLessonInput | UserUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput> | AttendanceCreateWithoutLessonInput[] | AttendanceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutLessonInput | AttendanceCreateOrConnectWithoutLessonInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutLessonInput | AttendanceUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: AttendanceCreateManyLessonInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutLessonInput | AttendanceUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutLessonInput | AttendanceUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type LessonCreateNestedOneWithoutFilesInput = {
    create?: XOR<LessonCreateWithoutFilesInput, LessonUncheckedCreateWithoutFilesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutFilesInput
    connect?: LessonWhereUniqueInput
  }

  export type AccountingEntryCreateNestedOneWithoutFilesInput = {
    create?: XOR<AccountingEntryCreateWithoutFilesInput, AccountingEntryUncheckedCreateWithoutFilesInput>
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutFilesInput
    connect?: AccountingEntryWhereUniqueInput
  }

  export type PublicRelationsRecordCreateNestedOneWithoutFilesInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutFilesInput, PublicRelationsRecordUncheckedCreateWithoutFilesInput>
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutFilesInput
    connect?: PublicRelationsRecordWhereUniqueInput
  }

  export type MeetingCreateNestedOneWithoutFilesInput = {
    create?: XOR<MeetingCreateWithoutFilesInput, MeetingUncheckedCreateWithoutFilesInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutFilesInput
    connect?: MeetingWhereUniqueInput
  }

  export type AdminRoleCreateNestedOneWithoutFilesInput = {
    create?: XOR<AdminRoleCreateWithoutFilesInput, AdminRoleUncheckedCreateWithoutFilesInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutFilesInput
    connect?: AdminRoleWhereUniqueInput
  }

  export type LegalCaseCreateNestedOneWithoutFilesInput = {
    create?: XOR<LegalCaseCreateWithoutFilesInput, LegalCaseUncheckedCreateWithoutFilesInput>
    connectOrCreate?: LegalCaseCreateOrConnectWithoutFilesInput
    connect?: LegalCaseWhereUniqueInput
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type LessonUpdateOneWithoutFilesNestedInput = {
    create?: XOR<LessonCreateWithoutFilesInput, LessonUncheckedCreateWithoutFilesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutFilesInput
    upsert?: LessonUpsertWithoutFilesInput
    disconnect?: LessonWhereInput | boolean
    delete?: LessonWhereInput | boolean
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutFilesInput, LessonUpdateWithoutFilesInput>, LessonUncheckedUpdateWithoutFilesInput>
  }

  export type AccountingEntryUpdateOneWithoutFilesNestedInput = {
    create?: XOR<AccountingEntryCreateWithoutFilesInput, AccountingEntryUncheckedCreateWithoutFilesInput>
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutFilesInput
    upsert?: AccountingEntryUpsertWithoutFilesInput
    disconnect?: AccountingEntryWhereInput | boolean
    delete?: AccountingEntryWhereInput | boolean
    connect?: AccountingEntryWhereUniqueInput
    update?: XOR<XOR<AccountingEntryUpdateToOneWithWhereWithoutFilesInput, AccountingEntryUpdateWithoutFilesInput>, AccountingEntryUncheckedUpdateWithoutFilesInput>
  }

  export type PublicRelationsRecordUpdateOneWithoutFilesNestedInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutFilesInput, PublicRelationsRecordUncheckedCreateWithoutFilesInput>
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutFilesInput
    upsert?: PublicRelationsRecordUpsertWithoutFilesInput
    disconnect?: PublicRelationsRecordWhereInput | boolean
    delete?: PublicRelationsRecordWhereInput | boolean
    connect?: PublicRelationsRecordWhereUniqueInput
    update?: XOR<XOR<PublicRelationsRecordUpdateToOneWithWhereWithoutFilesInput, PublicRelationsRecordUpdateWithoutFilesInput>, PublicRelationsRecordUncheckedUpdateWithoutFilesInput>
  }

  export type MeetingUpdateOneWithoutFilesNestedInput = {
    create?: XOR<MeetingCreateWithoutFilesInput, MeetingUncheckedCreateWithoutFilesInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutFilesInput
    upsert?: MeetingUpsertWithoutFilesInput
    disconnect?: MeetingWhereInput | boolean
    delete?: MeetingWhereInput | boolean
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutFilesInput, MeetingUpdateWithoutFilesInput>, MeetingUncheckedUpdateWithoutFilesInput>
  }

  export type AdminRoleUpdateOneWithoutFilesNestedInput = {
    create?: XOR<AdminRoleCreateWithoutFilesInput, AdminRoleUncheckedCreateWithoutFilesInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutFilesInput
    upsert?: AdminRoleUpsertWithoutFilesInput
    disconnect?: AdminRoleWhereInput | boolean
    delete?: AdminRoleWhereInput | boolean
    connect?: AdminRoleWhereUniqueInput
    update?: XOR<XOR<AdminRoleUpdateToOneWithWhereWithoutFilesInput, AdminRoleUpdateWithoutFilesInput>, AdminRoleUncheckedUpdateWithoutFilesInput>
  }

  export type LegalCaseUpdateOneWithoutFilesNestedInput = {
    create?: XOR<LegalCaseCreateWithoutFilesInput, LegalCaseUncheckedCreateWithoutFilesInput>
    connectOrCreate?: LegalCaseCreateOrConnectWithoutFilesInput
    upsert?: LegalCaseUpsertWithoutFilesInput
    disconnect?: LegalCaseWhereInput | boolean
    delete?: LegalCaseWhereInput | boolean
    connect?: LegalCaseWhereUniqueInput
    update?: XOR<XOR<LegalCaseUpdateToOneWithWhereWithoutFilesInput, LegalCaseUpdateWithoutFilesInput>, LegalCaseUncheckedUpdateWithoutFilesInput>
  }

  export type UserCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    upsert?: UserUpsertWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrollmentsInput, UserUpdateWithoutEnrollmentsInput>, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type LessonCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutQuizzesInput
    connect?: LessonWhereUniqueInput
  }

  export type QuestionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput> | QuestionCreateWithoutQuizInput[] | QuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuizInput | QuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuestionCreateManyQuizInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type SubmissionCreateNestedManyWithoutQuizInput = {
    create?: XOR<SubmissionCreateWithoutQuizInput, SubmissionUncheckedCreateWithoutQuizInput> | SubmissionCreateWithoutQuizInput[] | SubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutQuizInput | SubmissionCreateOrConnectWithoutQuizInput[]
    createMany?: SubmissionCreateManyQuizInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<CourseCreateWithoutQuizzesInput, CourseUncheckedCreateWithoutQuizzesInput> | CourseCreateWithoutQuizzesInput[] | CourseUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutQuizzesInput | CourseCreateOrConnectWithoutQuizzesInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput> | QuestionCreateWithoutQuizInput[] | QuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuizInput | QuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuestionCreateManyQuizInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type SubmissionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<SubmissionCreateWithoutQuizInput, SubmissionUncheckedCreateWithoutQuizInput> | SubmissionCreateWithoutQuizInput[] | SubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutQuizInput | SubmissionCreateOrConnectWithoutQuizInput[]
    createMany?: SubmissionCreateManyQuizInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<CourseCreateWithoutQuizzesInput, CourseUncheckedCreateWithoutQuizzesInput> | CourseCreateWithoutQuizzesInput[] | CourseUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutQuizzesInput | CourseCreateOrConnectWithoutQuizzesInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LessonUpdateOneRequiredWithoutQuizzesNestedInput = {
    create?: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutQuizzesInput
    upsert?: LessonUpsertWithoutQuizzesInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutQuizzesInput, LessonUpdateWithoutQuizzesInput>, LessonUncheckedUpdateWithoutQuizzesInput>
  }

  export type QuestionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput> | QuestionCreateWithoutQuizInput[] | QuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuizInput | QuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutQuizInput | QuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuestionCreateManyQuizInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutQuizInput | QuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutQuizInput | QuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type SubmissionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<SubmissionCreateWithoutQuizInput, SubmissionUncheckedCreateWithoutQuizInput> | SubmissionCreateWithoutQuizInput[] | SubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutQuizInput | SubmissionCreateOrConnectWithoutQuizInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutQuizInput | SubmissionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: SubmissionCreateManyQuizInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutQuizInput | SubmissionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutQuizInput | SubmissionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<CourseCreateWithoutQuizzesInput, CourseUncheckedCreateWithoutQuizzesInput> | CourseCreateWithoutQuizzesInput[] | CourseUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutQuizzesInput | CourseCreateOrConnectWithoutQuizzesInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutQuizzesInput | CourseUpsertWithWhereUniqueWithoutQuizzesInput[]
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutQuizzesInput | CourseUpdateWithWhereUniqueWithoutQuizzesInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutQuizzesInput | CourseUpdateManyWithWhereWithoutQuizzesInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput> | QuestionCreateWithoutQuizInput[] | QuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutQuizInput | QuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutQuizInput | QuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuestionCreateManyQuizInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutQuizInput | QuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutQuizInput | QuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type SubmissionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<SubmissionCreateWithoutQuizInput, SubmissionUncheckedCreateWithoutQuizInput> | SubmissionCreateWithoutQuizInput[] | SubmissionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutQuizInput | SubmissionCreateOrConnectWithoutQuizInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutQuizInput | SubmissionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: SubmissionCreateManyQuizInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutQuizInput | SubmissionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutQuizInput | SubmissionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<CourseCreateWithoutQuizzesInput, CourseUncheckedCreateWithoutQuizzesInput> | CourseCreateWithoutQuizzesInput[] | CourseUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutQuizzesInput | CourseCreateOrConnectWithoutQuizzesInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutQuizzesInput | CourseUpsertWithWhereUniqueWithoutQuizzesInput[]
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutQuizzesInput | CourseUpdateWithWhereUniqueWithoutQuizzesInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutQuizzesInput | CourseUpdateManyWithWhereWithoutQuizzesInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type OptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput> | OptionCreateWithoutQuestionInput[] | OptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutQuestionInput | OptionCreateOrConnectWithoutQuestionInput[]
    createMany?: OptionCreateManyQuestionInputEnvelope
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
  }

  export type QuizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
  }

  export type OptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput> | OptionCreateWithoutQuestionInput[] | OptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutQuestionInput | OptionCreateOrConnectWithoutQuestionInput[]
    createMany?: OptionCreateManyQuestionInputEnvelope
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
  }

  export type OptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput> | OptionCreateWithoutQuestionInput[] | OptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutQuestionInput | OptionCreateOrConnectWithoutQuestionInput[]
    upsert?: OptionUpsertWithWhereUniqueWithoutQuestionInput | OptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: OptionCreateManyQuestionInputEnvelope
    set?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    disconnect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    delete?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    update?: OptionUpdateWithWhereUniqueWithoutQuestionInput | OptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: OptionUpdateManyWithWhereWithoutQuestionInput | OptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: OptionScalarWhereInput | OptionScalarWhereInput[]
  }

  export type QuizUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    upsert?: QuizUpsertWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuestionsInput, QuizUpdateWithoutQuestionsInput>, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type OptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput> | OptionCreateWithoutQuestionInput[] | OptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: OptionCreateOrConnectWithoutQuestionInput | OptionCreateOrConnectWithoutQuestionInput[]
    upsert?: OptionUpsertWithWhereUniqueWithoutQuestionInput | OptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: OptionCreateManyQuestionInputEnvelope
    set?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    disconnect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    delete?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    connect?: OptionWhereUniqueInput | OptionWhereUniqueInput[]
    update?: OptionUpdateWithWhereUniqueWithoutQuestionInput | OptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: OptionUpdateManyWithWhereWithoutQuestionInput | OptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: OptionScalarWhereInput | OptionScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutOptionsInput = {
    create?: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutOptionsInput
    connect?: QuestionWhereUniqueInput
  }

  export type QuestionUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutOptionsInput
    upsert?: QuestionUpsertWithoutOptionsInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutOptionsInput, QuestionUpdateWithoutOptionsInput>, QuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type SubmissionCreateanswersInput = {
    set: InputJsonValue[]
  }

  export type UserCreateNestedOneWithoutSubmissionInput = {
    create?: XOR<UserCreateWithoutSubmissionInput, UserUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionInput
    connect?: UserWhereUniqueInput
  }

  export type QuizCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<QuizCreateWithoutSubmissionsInput, QuizUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutSubmissionsInput
    connect?: QuizWhereUniqueInput
  }

  export type SubmissionUpdateanswersInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutSubmissionNestedInput = {
    create?: XOR<UserCreateWithoutSubmissionInput, UserUncheckedCreateWithoutSubmissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionInput
    upsert?: UserUpsertWithoutSubmissionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubmissionInput, UserUpdateWithoutSubmissionInput>, UserUncheckedUpdateWithoutSubmissionInput>
  }

  export type QuizUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<QuizCreateWithoutSubmissionsInput, QuizUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutSubmissionsInput
    upsert?: QuizUpsertWithoutSubmissionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutSubmissionsInput, QuizUpdateWithoutSubmissionsInput>, QuizUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutNotificationSettingsInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationSettingsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationSettingsInput
    upsert?: UserUpsertWithoutNotificationSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationSettingsInput, UserUpdateWithoutNotificationSettingsInput>, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ChannelCreateNestedManyWithoutMessagesInput = {
    create?: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput> | ChannelCreateWithoutMessagesInput[] | ChannelUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMessagesInput | ChannelCreateOrConnectWithoutMessagesInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutMessagesInput = {
    create?: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput> | ChannelCreateWithoutMessagesInput[] | ChannelUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMessagesInput | ChannelCreateOrConnectWithoutMessagesInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type ChannelUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput> | ChannelCreateWithoutMessagesInput[] | ChannelUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMessagesInput | ChannelCreateOrConnectWithoutMessagesInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutMessagesInput | ChannelUpsertWithWhereUniqueWithoutMessagesInput[]
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutMessagesInput | ChannelUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutMessagesInput | ChannelUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput> | ChannelCreateWithoutMessagesInput[] | ChannelUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMessagesInput | ChannelCreateOrConnectWithoutMessagesInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutMessagesInput | ChannelUpsertWithWhereUniqueWithoutMessagesInput[]
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutMessagesInput | ChannelUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutMessagesInput | ChannelUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type GroupCreateNestedManyWithoutPostsInput = {
    create?: XOR<GroupCreateWithoutPostsInput, GroupUncheckedCreateWithoutPostsInput> | GroupCreateWithoutPostsInput[] | GroupUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutPostsInput | GroupCreateOrConnectWithoutPostsInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type CommunityCreateNestedManyWithoutPostsInput = {
    create?: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput> | CommunityCreateWithoutPostsInput[] | CommunityUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutPostsInput | CommunityCreateOrConnectWithoutPostsInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
  }

  export type DiscussionCreateNestedManyWithoutPostInput = {
    create?: XOR<DiscussionCreateWithoutPostInput, DiscussionUncheckedCreateWithoutPostInput> | DiscussionCreateWithoutPostInput[] | DiscussionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: DiscussionCreateOrConnectWithoutPostInput | DiscussionCreateOrConnectWithoutPostInput[]
    createMany?: DiscussionCreateManyPostInputEnvelope
    connect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
  }

  export type PublicRelationsRecordCreateNestedOneWithoutPostsInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutPostsInput, PublicRelationsRecordUncheckedCreateWithoutPostsInput>
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutPostsInput
    connect?: PublicRelationsRecordWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<GroupCreateWithoutPostsInput, GroupUncheckedCreateWithoutPostsInput> | GroupCreateWithoutPostsInput[] | GroupUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutPostsInput | GroupCreateOrConnectWithoutPostsInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type CommunityUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput> | CommunityCreateWithoutPostsInput[] | CommunityUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutPostsInput | CommunityCreateOrConnectWithoutPostsInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
  }

  export type DiscussionUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<DiscussionCreateWithoutPostInput, DiscussionUncheckedCreateWithoutPostInput> | DiscussionCreateWithoutPostInput[] | DiscussionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: DiscussionCreateOrConnectWithoutPostInput | DiscussionCreateOrConnectWithoutPostInput[]
    createMany?: DiscussionCreateManyPostInputEnvelope
    connect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type GroupUpdateManyWithoutPostsNestedInput = {
    create?: XOR<GroupCreateWithoutPostsInput, GroupUncheckedCreateWithoutPostsInput> | GroupCreateWithoutPostsInput[] | GroupUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutPostsInput | GroupCreateOrConnectWithoutPostsInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutPostsInput | GroupUpsertWithWhereUniqueWithoutPostsInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutPostsInput | GroupUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutPostsInput | GroupUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type CommunityUpdateManyWithoutPostsNestedInput = {
    create?: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput> | CommunityCreateWithoutPostsInput[] | CommunityUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutPostsInput | CommunityCreateOrConnectWithoutPostsInput[]
    upsert?: CommunityUpsertWithWhereUniqueWithoutPostsInput | CommunityUpsertWithWhereUniqueWithoutPostsInput[]
    set?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    disconnect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    delete?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    update?: CommunityUpdateWithWhereUniqueWithoutPostsInput | CommunityUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: CommunityUpdateManyWithWhereWithoutPostsInput | CommunityUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
  }

  export type DiscussionUpdateManyWithoutPostNestedInput = {
    create?: XOR<DiscussionCreateWithoutPostInput, DiscussionUncheckedCreateWithoutPostInput> | DiscussionCreateWithoutPostInput[] | DiscussionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: DiscussionCreateOrConnectWithoutPostInput | DiscussionCreateOrConnectWithoutPostInput[]
    upsert?: DiscussionUpsertWithWhereUniqueWithoutPostInput | DiscussionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: DiscussionCreateManyPostInputEnvelope
    set?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    disconnect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    delete?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    connect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    update?: DiscussionUpdateWithWhereUniqueWithoutPostInput | DiscussionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: DiscussionUpdateManyWithWhereWithoutPostInput | DiscussionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: DiscussionScalarWhereInput | DiscussionScalarWhereInput[]
  }

  export type PublicRelationsRecordUpdateOneWithoutPostsNestedInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutPostsInput, PublicRelationsRecordUncheckedCreateWithoutPostsInput>
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutPostsInput
    upsert?: PublicRelationsRecordUpsertWithoutPostsInput
    disconnect?: PublicRelationsRecordWhereInput | boolean
    delete?: PublicRelationsRecordWhereInput | boolean
    connect?: PublicRelationsRecordWhereUniqueInput
    update?: XOR<XOR<PublicRelationsRecordUpdateToOneWithWhereWithoutPostsInput, PublicRelationsRecordUpdateWithoutPostsInput>, PublicRelationsRecordUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<GroupCreateWithoutPostsInput, GroupUncheckedCreateWithoutPostsInput> | GroupCreateWithoutPostsInput[] | GroupUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutPostsInput | GroupCreateOrConnectWithoutPostsInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutPostsInput | GroupUpsertWithWhereUniqueWithoutPostsInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutPostsInput | GroupUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutPostsInput | GroupUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type CommunityUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput> | CommunityCreateWithoutPostsInput[] | CommunityUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutPostsInput | CommunityCreateOrConnectWithoutPostsInput[]
    upsert?: CommunityUpsertWithWhereUniqueWithoutPostsInput | CommunityUpsertWithWhereUniqueWithoutPostsInput[]
    set?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    disconnect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    delete?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    update?: CommunityUpdateWithWhereUniqueWithoutPostsInput | CommunityUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: CommunityUpdateManyWithWhereWithoutPostsInput | CommunityUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
  }

  export type DiscussionUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<DiscussionCreateWithoutPostInput, DiscussionUncheckedCreateWithoutPostInput> | DiscussionCreateWithoutPostInput[] | DiscussionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: DiscussionCreateOrConnectWithoutPostInput | DiscussionCreateOrConnectWithoutPostInput[]
    upsert?: DiscussionUpsertWithWhereUniqueWithoutPostInput | DiscussionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: DiscussionCreateManyPostInputEnvelope
    set?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    disconnect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    delete?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    connect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    update?: DiscussionUpdateWithWhereUniqueWithoutPostInput | DiscussionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: DiscussionUpdateManyWithWhereWithoutPostInput | DiscussionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: DiscussionScalarWhereInput | DiscussionScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutGroupInput = {
    create?: XOR<PostCreateWithoutGroupInput, PostUncheckedCreateWithoutGroupInput> | PostCreateWithoutGroupInput[] | PostUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PostCreateOrConnectWithoutGroupInput | PostCreateOrConnectWithoutGroupInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type AdminCreateNestedOneWithoutGroupInput = {
    create?: XOR<AdminCreateWithoutGroupInput, AdminUncheckedCreateWithoutGroupInput>
    connectOrCreate?: AdminCreateOrConnectWithoutGroupInput
    connect?: AdminWhereUniqueInput
  }

  export type CommunityCreateNestedManyWithoutGroupsInput = {
    create?: XOR<CommunityCreateWithoutGroupsInput, CommunityUncheckedCreateWithoutGroupsInput> | CommunityCreateWithoutGroupsInput[] | CommunityUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutGroupsInput | CommunityCreateOrConnectWithoutGroupsInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<PostCreateWithoutGroupInput, PostUncheckedCreateWithoutGroupInput> | PostCreateWithoutGroupInput[] | PostUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PostCreateOrConnectWithoutGroupInput | PostCreateOrConnectWithoutGroupInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommunityUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<CommunityCreateWithoutGroupsInput, CommunityUncheckedCreateWithoutGroupsInput> | CommunityCreateWithoutGroupsInput[] | CommunityUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutGroupsInput | CommunityCreateOrConnectWithoutGroupsInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutGroupsInput | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutGroupsInput | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutGroupsInput | UserUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PostUpdateManyWithoutGroupNestedInput = {
    create?: XOR<PostCreateWithoutGroupInput, PostUncheckedCreateWithoutGroupInput> | PostCreateWithoutGroupInput[] | PostUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PostCreateOrConnectWithoutGroupInput | PostCreateOrConnectWithoutGroupInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutGroupInput | PostUpsertWithWhereUniqueWithoutGroupInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutGroupInput | PostUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: PostUpdateManyWithWhereWithoutGroupInput | PostUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type AdminUpdateOneRequiredWithoutGroupNestedInput = {
    create?: XOR<AdminCreateWithoutGroupInput, AdminUncheckedCreateWithoutGroupInput>
    connectOrCreate?: AdminCreateOrConnectWithoutGroupInput
    upsert?: AdminUpsertWithoutGroupInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutGroupInput, AdminUpdateWithoutGroupInput>, AdminUncheckedUpdateWithoutGroupInput>
  }

  export type CommunityUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<CommunityCreateWithoutGroupsInput, CommunityUncheckedCreateWithoutGroupsInput> | CommunityCreateWithoutGroupsInput[] | CommunityUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutGroupsInput | CommunityCreateOrConnectWithoutGroupsInput[]
    upsert?: CommunityUpsertWithWhereUniqueWithoutGroupsInput | CommunityUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    disconnect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    delete?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    update?: CommunityUpdateWithWhereUniqueWithoutGroupsInput | CommunityUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: CommunityUpdateManyWithWhereWithoutGroupsInput | CommunityUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput> | UserCreateWithoutGroupsInput[] | UserUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutGroupsInput | UserCreateOrConnectWithoutGroupsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutGroupsInput | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutGroupsInput | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutGroupsInput | UserUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<PostCreateWithoutGroupInput, PostUncheckedCreateWithoutGroupInput> | PostCreateWithoutGroupInput[] | PostUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: PostCreateOrConnectWithoutGroupInput | PostCreateOrConnectWithoutGroupInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutGroupInput | PostUpsertWithWhereUniqueWithoutGroupInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutGroupInput | PostUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: PostUpdateManyWithWhereWithoutGroupInput | PostUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommunityUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<CommunityCreateWithoutGroupsInput, CommunityUncheckedCreateWithoutGroupsInput> | CommunityCreateWithoutGroupsInput[] | CommunityUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: CommunityCreateOrConnectWithoutGroupsInput | CommunityCreateOrConnectWithoutGroupsInput[]
    upsert?: CommunityUpsertWithWhereUniqueWithoutGroupsInput | CommunityUpsertWithWhereUniqueWithoutGroupsInput[]
    set?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    disconnect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    delete?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    connect?: CommunityWhereUniqueInput | CommunityWhereUniqueInput[]
    update?: CommunityUpdateWithWhereUniqueWithoutGroupsInput | CommunityUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: CommunityUpdateManyWithWhereWithoutGroupsInput | CommunityUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type GroupCreateNestedManyWithoutAdminInput = {
    create?: XOR<GroupCreateWithoutAdminInput, GroupUncheckedCreateWithoutAdminInput> | GroupCreateWithoutAdminInput[] | GroupUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutAdminInput | GroupCreateOrConnectWithoutAdminInput[]
    createMany?: GroupCreateManyAdminInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type AccountingEntryCreateNestedManyWithoutCreatedByAdminInput = {
    create?: XOR<AccountingEntryCreateWithoutCreatedByAdminInput, AccountingEntryUncheckedCreateWithoutCreatedByAdminInput> | AccountingEntryCreateWithoutCreatedByAdminInput[] | AccountingEntryUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutCreatedByAdminInput | AccountingEntryCreateOrConnectWithoutCreatedByAdminInput[]
    createMany?: AccountingEntryCreateManyCreatedByAdminInputEnvelope
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
  }

  export type PublicRelationsRecordCreateNestedManyWithoutHandledByAdminInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutHandledByAdminInput, PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput> | PublicRelationsRecordCreateWithoutHandledByAdminInput[] | PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput[]
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutHandledByAdminInput | PublicRelationsRecordCreateOrConnectWithoutHandledByAdminInput[]
    createMany?: PublicRelationsRecordCreateManyHandledByAdminInputEnvelope
    connect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
  }

  export type PRResponseCreateNestedManyWithoutRespondedByAdminInput = {
    create?: XOR<PRResponseCreateWithoutRespondedByAdminInput, PRResponseUncheckedCreateWithoutRespondedByAdminInput> | PRResponseCreateWithoutRespondedByAdminInput[] | PRResponseUncheckedCreateWithoutRespondedByAdminInput[]
    connectOrCreate?: PRResponseCreateOrConnectWithoutRespondedByAdminInput | PRResponseCreateOrConnectWithoutRespondedByAdminInput[]
    createMany?: PRResponseCreateManyRespondedByAdminInputEnvelope
    connect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutCreatedByAdminInput = {
    create?: XOR<MeetingCreateWithoutCreatedByAdminInput, MeetingUncheckedCreateWithoutCreatedByAdminInput> | MeetingCreateWithoutCreatedByAdminInput[] | MeetingUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatedByAdminInput | MeetingCreateOrConnectWithoutCreatedByAdminInput[]
    createMany?: MeetingCreateManyCreatedByAdminInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type AdminAssignmentCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAssignmentCreateWithoutAdminInput, AdminAssignmentUncheckedCreateWithoutAdminInput> | AdminAssignmentCreateWithoutAdminInput[] | AdminAssignmentUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAssignmentCreateOrConnectWithoutAdminInput | AdminAssignmentCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAssignmentCreateManyAdminInputEnvelope
    connect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
  }

  export type LegalCaseCreateNestedManyWithoutAssignedLawyerInput = {
    create?: XOR<LegalCaseCreateWithoutAssignedLawyerInput, LegalCaseUncheckedCreateWithoutAssignedLawyerInput> | LegalCaseCreateWithoutAssignedLawyerInput[] | LegalCaseUncheckedCreateWithoutAssignedLawyerInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutAssignedLawyerInput | LegalCaseCreateOrConnectWithoutAssignedLawyerInput[]
    createMany?: LegalCaseCreateManyAssignedLawyerInputEnvelope
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
  }

  export type AdminRoleCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminRoleCreateWithoutAdminInput, AdminRoleUncheckedCreateWithoutAdminInput> | AdminRoleCreateWithoutAdminInput[] | AdminRoleUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutAdminInput | AdminRoleCreateOrConnectWithoutAdminInput[]
    createMany?: AdminRoleCreateManyAdminInputEnvelope
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<GroupCreateWithoutAdminInput, GroupUncheckedCreateWithoutAdminInput> | GroupCreateWithoutAdminInput[] | GroupUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutAdminInput | GroupCreateOrConnectWithoutAdminInput[]
    createMany?: GroupCreateManyAdminInputEnvelope
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type AccountingEntryUncheckedCreateNestedManyWithoutCreatedByAdminInput = {
    create?: XOR<AccountingEntryCreateWithoutCreatedByAdminInput, AccountingEntryUncheckedCreateWithoutCreatedByAdminInput> | AccountingEntryCreateWithoutCreatedByAdminInput[] | AccountingEntryUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutCreatedByAdminInput | AccountingEntryCreateOrConnectWithoutCreatedByAdminInput[]
    createMany?: AccountingEntryCreateManyCreatedByAdminInputEnvelope
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
  }

  export type PublicRelationsRecordUncheckedCreateNestedManyWithoutHandledByAdminInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutHandledByAdminInput, PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput> | PublicRelationsRecordCreateWithoutHandledByAdminInput[] | PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput[]
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutHandledByAdminInput | PublicRelationsRecordCreateOrConnectWithoutHandledByAdminInput[]
    createMany?: PublicRelationsRecordCreateManyHandledByAdminInputEnvelope
    connect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
  }

  export type PRResponseUncheckedCreateNestedManyWithoutRespondedByAdminInput = {
    create?: XOR<PRResponseCreateWithoutRespondedByAdminInput, PRResponseUncheckedCreateWithoutRespondedByAdminInput> | PRResponseCreateWithoutRespondedByAdminInput[] | PRResponseUncheckedCreateWithoutRespondedByAdminInput[]
    connectOrCreate?: PRResponseCreateOrConnectWithoutRespondedByAdminInput | PRResponseCreateOrConnectWithoutRespondedByAdminInput[]
    createMany?: PRResponseCreateManyRespondedByAdminInputEnvelope
    connect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutCreatedByAdminInput = {
    create?: XOR<MeetingCreateWithoutCreatedByAdminInput, MeetingUncheckedCreateWithoutCreatedByAdminInput> | MeetingCreateWithoutCreatedByAdminInput[] | MeetingUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatedByAdminInput | MeetingCreateOrConnectWithoutCreatedByAdminInput[]
    createMany?: MeetingCreateManyCreatedByAdminInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type AdminAssignmentUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAssignmentCreateWithoutAdminInput, AdminAssignmentUncheckedCreateWithoutAdminInput> | AdminAssignmentCreateWithoutAdminInput[] | AdminAssignmentUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAssignmentCreateOrConnectWithoutAdminInput | AdminAssignmentCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAssignmentCreateManyAdminInputEnvelope
    connect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
  }

  export type LegalCaseUncheckedCreateNestedManyWithoutAssignedLawyerInput = {
    create?: XOR<LegalCaseCreateWithoutAssignedLawyerInput, LegalCaseUncheckedCreateWithoutAssignedLawyerInput> | LegalCaseCreateWithoutAssignedLawyerInput[] | LegalCaseUncheckedCreateWithoutAssignedLawyerInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutAssignedLawyerInput | LegalCaseCreateOrConnectWithoutAssignedLawyerInput[]
    createMany?: LegalCaseCreateManyAssignedLawyerInputEnvelope
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
  }

  export type AdminRoleUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminRoleCreateWithoutAdminInput, AdminRoleUncheckedCreateWithoutAdminInput> | AdminRoleCreateWithoutAdminInput[] | AdminRoleUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutAdminInput | AdminRoleCreateOrConnectWithoutAdminInput[]
    createMany?: AdminRoleCreateManyAdminInputEnvelope
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type GroupUpdateManyWithoutAdminNestedInput = {
    create?: XOR<GroupCreateWithoutAdminInput, GroupUncheckedCreateWithoutAdminInput> | GroupCreateWithoutAdminInput[] | GroupUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutAdminInput | GroupCreateOrConnectWithoutAdminInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutAdminInput | GroupUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: GroupCreateManyAdminInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutAdminInput | GroupUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutAdminInput | GroupUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type AccountingEntryUpdateManyWithoutCreatedByAdminNestedInput = {
    create?: XOR<AccountingEntryCreateWithoutCreatedByAdminInput, AccountingEntryUncheckedCreateWithoutCreatedByAdminInput> | AccountingEntryCreateWithoutCreatedByAdminInput[] | AccountingEntryUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutCreatedByAdminInput | AccountingEntryCreateOrConnectWithoutCreatedByAdminInput[]
    upsert?: AccountingEntryUpsertWithWhereUniqueWithoutCreatedByAdminInput | AccountingEntryUpsertWithWhereUniqueWithoutCreatedByAdminInput[]
    createMany?: AccountingEntryCreateManyCreatedByAdminInputEnvelope
    set?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    disconnect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    delete?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    update?: AccountingEntryUpdateWithWhereUniqueWithoutCreatedByAdminInput | AccountingEntryUpdateWithWhereUniqueWithoutCreatedByAdminInput[]
    updateMany?: AccountingEntryUpdateManyWithWhereWithoutCreatedByAdminInput | AccountingEntryUpdateManyWithWhereWithoutCreatedByAdminInput[]
    deleteMany?: AccountingEntryScalarWhereInput | AccountingEntryScalarWhereInput[]
  }

  export type PublicRelationsRecordUpdateManyWithoutHandledByAdminNestedInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutHandledByAdminInput, PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput> | PublicRelationsRecordCreateWithoutHandledByAdminInput[] | PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput[]
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutHandledByAdminInput | PublicRelationsRecordCreateOrConnectWithoutHandledByAdminInput[]
    upsert?: PublicRelationsRecordUpsertWithWhereUniqueWithoutHandledByAdminInput | PublicRelationsRecordUpsertWithWhereUniqueWithoutHandledByAdminInput[]
    createMany?: PublicRelationsRecordCreateManyHandledByAdminInputEnvelope
    set?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    disconnect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    delete?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    connect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    update?: PublicRelationsRecordUpdateWithWhereUniqueWithoutHandledByAdminInput | PublicRelationsRecordUpdateWithWhereUniqueWithoutHandledByAdminInput[]
    updateMany?: PublicRelationsRecordUpdateManyWithWhereWithoutHandledByAdminInput | PublicRelationsRecordUpdateManyWithWhereWithoutHandledByAdminInput[]
    deleteMany?: PublicRelationsRecordScalarWhereInput | PublicRelationsRecordScalarWhereInput[]
  }

  export type PRResponseUpdateManyWithoutRespondedByAdminNestedInput = {
    create?: XOR<PRResponseCreateWithoutRespondedByAdminInput, PRResponseUncheckedCreateWithoutRespondedByAdminInput> | PRResponseCreateWithoutRespondedByAdminInput[] | PRResponseUncheckedCreateWithoutRespondedByAdminInput[]
    connectOrCreate?: PRResponseCreateOrConnectWithoutRespondedByAdminInput | PRResponseCreateOrConnectWithoutRespondedByAdminInput[]
    upsert?: PRResponseUpsertWithWhereUniqueWithoutRespondedByAdminInput | PRResponseUpsertWithWhereUniqueWithoutRespondedByAdminInput[]
    createMany?: PRResponseCreateManyRespondedByAdminInputEnvelope
    set?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    disconnect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    delete?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    connect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    update?: PRResponseUpdateWithWhereUniqueWithoutRespondedByAdminInput | PRResponseUpdateWithWhereUniqueWithoutRespondedByAdminInput[]
    updateMany?: PRResponseUpdateManyWithWhereWithoutRespondedByAdminInput | PRResponseUpdateManyWithWhereWithoutRespondedByAdminInput[]
    deleteMany?: PRResponseScalarWhereInput | PRResponseScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutCreatedByAdminNestedInput = {
    create?: XOR<MeetingCreateWithoutCreatedByAdminInput, MeetingUncheckedCreateWithoutCreatedByAdminInput> | MeetingCreateWithoutCreatedByAdminInput[] | MeetingUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatedByAdminInput | MeetingCreateOrConnectWithoutCreatedByAdminInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutCreatedByAdminInput | MeetingUpsertWithWhereUniqueWithoutCreatedByAdminInput[]
    createMany?: MeetingCreateManyCreatedByAdminInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutCreatedByAdminInput | MeetingUpdateWithWhereUniqueWithoutCreatedByAdminInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutCreatedByAdminInput | MeetingUpdateManyWithWhereWithoutCreatedByAdminInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type AdminAssignmentUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAssignmentCreateWithoutAdminInput, AdminAssignmentUncheckedCreateWithoutAdminInput> | AdminAssignmentCreateWithoutAdminInput[] | AdminAssignmentUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAssignmentCreateOrConnectWithoutAdminInput | AdminAssignmentCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAssignmentUpsertWithWhereUniqueWithoutAdminInput | AdminAssignmentUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAssignmentCreateManyAdminInputEnvelope
    set?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    disconnect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    delete?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    connect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    update?: AdminAssignmentUpdateWithWhereUniqueWithoutAdminInput | AdminAssignmentUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAssignmentUpdateManyWithWhereWithoutAdminInput | AdminAssignmentUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAssignmentScalarWhereInput | AdminAssignmentScalarWhereInput[]
  }

  export type LegalCaseUpdateManyWithoutAssignedLawyerNestedInput = {
    create?: XOR<LegalCaseCreateWithoutAssignedLawyerInput, LegalCaseUncheckedCreateWithoutAssignedLawyerInput> | LegalCaseCreateWithoutAssignedLawyerInput[] | LegalCaseUncheckedCreateWithoutAssignedLawyerInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutAssignedLawyerInput | LegalCaseCreateOrConnectWithoutAssignedLawyerInput[]
    upsert?: LegalCaseUpsertWithWhereUniqueWithoutAssignedLawyerInput | LegalCaseUpsertWithWhereUniqueWithoutAssignedLawyerInput[]
    createMany?: LegalCaseCreateManyAssignedLawyerInputEnvelope
    set?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    disconnect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    delete?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    update?: LegalCaseUpdateWithWhereUniqueWithoutAssignedLawyerInput | LegalCaseUpdateWithWhereUniqueWithoutAssignedLawyerInput[]
    updateMany?: LegalCaseUpdateManyWithWhereWithoutAssignedLawyerInput | LegalCaseUpdateManyWithWhereWithoutAssignedLawyerInput[]
    deleteMany?: LegalCaseScalarWhereInput | LegalCaseScalarWhereInput[]
  }

  export type AdminRoleUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminRoleCreateWithoutAdminInput, AdminRoleUncheckedCreateWithoutAdminInput> | AdminRoleCreateWithoutAdminInput[] | AdminRoleUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutAdminInput | AdminRoleCreateOrConnectWithoutAdminInput[]
    upsert?: AdminRoleUpsertWithWhereUniqueWithoutAdminInput | AdminRoleUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminRoleCreateManyAdminInputEnvelope
    set?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    disconnect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    delete?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    update?: AdminRoleUpdateWithWhereUniqueWithoutAdminInput | AdminRoleUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminRoleUpdateManyWithWhereWithoutAdminInput | AdminRoleUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminRoleScalarWhereInput | AdminRoleScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<GroupCreateWithoutAdminInput, GroupUncheckedCreateWithoutAdminInput> | GroupCreateWithoutAdminInput[] | GroupUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutAdminInput | GroupCreateOrConnectWithoutAdminInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutAdminInput | GroupUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: GroupCreateManyAdminInputEnvelope
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutAdminInput | GroupUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutAdminInput | GroupUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminNestedInput = {
    create?: XOR<AccountingEntryCreateWithoutCreatedByAdminInput, AccountingEntryUncheckedCreateWithoutCreatedByAdminInput> | AccountingEntryCreateWithoutCreatedByAdminInput[] | AccountingEntryUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutCreatedByAdminInput | AccountingEntryCreateOrConnectWithoutCreatedByAdminInput[]
    upsert?: AccountingEntryUpsertWithWhereUniqueWithoutCreatedByAdminInput | AccountingEntryUpsertWithWhereUniqueWithoutCreatedByAdminInput[]
    createMany?: AccountingEntryCreateManyCreatedByAdminInputEnvelope
    set?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    disconnect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    delete?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    connect?: AccountingEntryWhereUniqueInput | AccountingEntryWhereUniqueInput[]
    update?: AccountingEntryUpdateWithWhereUniqueWithoutCreatedByAdminInput | AccountingEntryUpdateWithWhereUniqueWithoutCreatedByAdminInput[]
    updateMany?: AccountingEntryUpdateManyWithWhereWithoutCreatedByAdminInput | AccountingEntryUpdateManyWithWhereWithoutCreatedByAdminInput[]
    deleteMany?: AccountingEntryScalarWhereInput | AccountingEntryScalarWhereInput[]
  }

  export type PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminNestedInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutHandledByAdminInput, PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput> | PublicRelationsRecordCreateWithoutHandledByAdminInput[] | PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput[]
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutHandledByAdminInput | PublicRelationsRecordCreateOrConnectWithoutHandledByAdminInput[]
    upsert?: PublicRelationsRecordUpsertWithWhereUniqueWithoutHandledByAdminInput | PublicRelationsRecordUpsertWithWhereUniqueWithoutHandledByAdminInput[]
    createMany?: PublicRelationsRecordCreateManyHandledByAdminInputEnvelope
    set?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    disconnect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    delete?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    connect?: PublicRelationsRecordWhereUniqueInput | PublicRelationsRecordWhereUniqueInput[]
    update?: PublicRelationsRecordUpdateWithWhereUniqueWithoutHandledByAdminInput | PublicRelationsRecordUpdateWithWhereUniqueWithoutHandledByAdminInput[]
    updateMany?: PublicRelationsRecordUpdateManyWithWhereWithoutHandledByAdminInput | PublicRelationsRecordUpdateManyWithWhereWithoutHandledByAdminInput[]
    deleteMany?: PublicRelationsRecordScalarWhereInput | PublicRelationsRecordScalarWhereInput[]
  }

  export type PRResponseUncheckedUpdateManyWithoutRespondedByAdminNestedInput = {
    create?: XOR<PRResponseCreateWithoutRespondedByAdminInput, PRResponseUncheckedCreateWithoutRespondedByAdminInput> | PRResponseCreateWithoutRespondedByAdminInput[] | PRResponseUncheckedCreateWithoutRespondedByAdminInput[]
    connectOrCreate?: PRResponseCreateOrConnectWithoutRespondedByAdminInput | PRResponseCreateOrConnectWithoutRespondedByAdminInput[]
    upsert?: PRResponseUpsertWithWhereUniqueWithoutRespondedByAdminInput | PRResponseUpsertWithWhereUniqueWithoutRespondedByAdminInput[]
    createMany?: PRResponseCreateManyRespondedByAdminInputEnvelope
    set?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    disconnect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    delete?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    connect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    update?: PRResponseUpdateWithWhereUniqueWithoutRespondedByAdminInput | PRResponseUpdateWithWhereUniqueWithoutRespondedByAdminInput[]
    updateMany?: PRResponseUpdateManyWithWhereWithoutRespondedByAdminInput | PRResponseUpdateManyWithWhereWithoutRespondedByAdminInput[]
    deleteMany?: PRResponseScalarWhereInput | PRResponseScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutCreatedByAdminNestedInput = {
    create?: XOR<MeetingCreateWithoutCreatedByAdminInput, MeetingUncheckedCreateWithoutCreatedByAdminInput> | MeetingCreateWithoutCreatedByAdminInput[] | MeetingUncheckedCreateWithoutCreatedByAdminInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatedByAdminInput | MeetingCreateOrConnectWithoutCreatedByAdminInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutCreatedByAdminInput | MeetingUpsertWithWhereUniqueWithoutCreatedByAdminInput[]
    createMany?: MeetingCreateManyCreatedByAdminInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutCreatedByAdminInput | MeetingUpdateWithWhereUniqueWithoutCreatedByAdminInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutCreatedByAdminInput | MeetingUpdateManyWithWhereWithoutCreatedByAdminInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type AdminAssignmentUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAssignmentCreateWithoutAdminInput, AdminAssignmentUncheckedCreateWithoutAdminInput> | AdminAssignmentCreateWithoutAdminInput[] | AdminAssignmentUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAssignmentCreateOrConnectWithoutAdminInput | AdminAssignmentCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAssignmentUpsertWithWhereUniqueWithoutAdminInput | AdminAssignmentUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAssignmentCreateManyAdminInputEnvelope
    set?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    disconnect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    delete?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    connect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    update?: AdminAssignmentUpdateWithWhereUniqueWithoutAdminInput | AdminAssignmentUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAssignmentUpdateManyWithWhereWithoutAdminInput | AdminAssignmentUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAssignmentScalarWhereInput | AdminAssignmentScalarWhereInput[]
  }

  export type LegalCaseUncheckedUpdateManyWithoutAssignedLawyerNestedInput = {
    create?: XOR<LegalCaseCreateWithoutAssignedLawyerInput, LegalCaseUncheckedCreateWithoutAssignedLawyerInput> | LegalCaseCreateWithoutAssignedLawyerInput[] | LegalCaseUncheckedCreateWithoutAssignedLawyerInput[]
    connectOrCreate?: LegalCaseCreateOrConnectWithoutAssignedLawyerInput | LegalCaseCreateOrConnectWithoutAssignedLawyerInput[]
    upsert?: LegalCaseUpsertWithWhereUniqueWithoutAssignedLawyerInput | LegalCaseUpsertWithWhereUniqueWithoutAssignedLawyerInput[]
    createMany?: LegalCaseCreateManyAssignedLawyerInputEnvelope
    set?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    disconnect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    delete?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    connect?: LegalCaseWhereUniqueInput | LegalCaseWhereUniqueInput[]
    update?: LegalCaseUpdateWithWhereUniqueWithoutAssignedLawyerInput | LegalCaseUpdateWithWhereUniqueWithoutAssignedLawyerInput[]
    updateMany?: LegalCaseUpdateManyWithWhereWithoutAssignedLawyerInput | LegalCaseUpdateManyWithWhereWithoutAssignedLawyerInput[]
    deleteMany?: LegalCaseScalarWhereInput | LegalCaseScalarWhereInput[]
  }

  export type AdminRoleUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminRoleCreateWithoutAdminInput, AdminRoleUncheckedCreateWithoutAdminInput> | AdminRoleCreateWithoutAdminInput[] | AdminRoleUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutAdminInput | AdminRoleCreateOrConnectWithoutAdminInput[]
    upsert?: AdminRoleUpsertWithWhereUniqueWithoutAdminInput | AdminRoleUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminRoleCreateManyAdminInputEnvelope
    set?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    disconnect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    delete?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    update?: AdminRoleUpdateWithWhereUniqueWithoutAdminInput | AdminRoleUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminRoleUpdateManyWithWhereWithoutAdminInput | AdminRoleUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminRoleScalarWhereInput | AdminRoleScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutChannelsInput = {
    create?: XOR<UserCreateWithoutChannelsInput, UserUncheckedCreateWithoutChannelsInput> | UserCreateWithoutChannelsInput[] | UserUncheckedCreateWithoutChannelsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutChannelsInput | UserCreateOrConnectWithoutChannelsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type OwnerCreateNestedOneWithoutChannelInput = {
    create?: XOR<OwnerCreateWithoutChannelInput, OwnerUncheckedCreateWithoutChannelInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutChannelInput
    connect?: OwnerWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutChannelInput = {
    create?: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput> | MessageCreateWithoutChannelInput[] | MessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChannelInput | MessageCreateOrConnectWithoutChannelInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type PublicRelationsRecordCreateNestedOneWithoutChannelsInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutChannelsInput, PublicRelationsRecordUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutChannelsInput
    connect?: PublicRelationsRecordWhereUniqueInput
  }

  export type MeetingCreateNestedOneWithoutChannelsInput = {
    create?: XOR<MeetingCreateWithoutChannelsInput, MeetingUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutChannelsInput
    connect?: MeetingWhereUniqueInput
  }

  export type AdminRoleCreateNestedOneWithoutChannelsInput = {
    create?: XOR<AdminRoleCreateWithoutChannelsInput, AdminRoleUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutChannelsInput
    connect?: AdminRoleWhereUniqueInput
  }

  export type LegalCaseCreateNestedOneWithoutChannelsInput = {
    create?: XOR<LegalCaseCreateWithoutChannelsInput, LegalCaseUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: LegalCaseCreateOrConnectWithoutChannelsInput
    connect?: LegalCaseWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutChannelsInput = {
    create?: XOR<UserCreateWithoutChannelsInput, UserUncheckedCreateWithoutChannelsInput> | UserCreateWithoutChannelsInput[] | UserUncheckedCreateWithoutChannelsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutChannelsInput | UserCreateOrConnectWithoutChannelsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput> | MessageCreateWithoutChannelInput[] | MessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChannelInput | MessageCreateOrConnectWithoutChannelInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutChannelsNestedInput = {
    create?: XOR<UserCreateWithoutChannelsInput, UserUncheckedCreateWithoutChannelsInput> | UserCreateWithoutChannelsInput[] | UserUncheckedCreateWithoutChannelsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutChannelsInput | UserCreateOrConnectWithoutChannelsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutChannelsInput | UserUpsertWithWhereUniqueWithoutChannelsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutChannelsInput | UserUpdateWithWhereUniqueWithoutChannelsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutChannelsInput | UserUpdateManyWithWhereWithoutChannelsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type OwnerUpdateOneRequiredWithoutChannelNestedInput = {
    create?: XOR<OwnerCreateWithoutChannelInput, OwnerUncheckedCreateWithoutChannelInput>
    connectOrCreate?: OwnerCreateOrConnectWithoutChannelInput
    upsert?: OwnerUpsertWithoutChannelInput
    connect?: OwnerWhereUniqueInput
    update?: XOR<XOR<OwnerUpdateToOneWithWhereWithoutChannelInput, OwnerUpdateWithoutChannelInput>, OwnerUncheckedUpdateWithoutChannelInput>
  }

  export type MessageUpdateManyWithoutChannelNestedInput = {
    create?: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput> | MessageCreateWithoutChannelInput[] | MessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChannelInput | MessageCreateOrConnectWithoutChannelInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChannelInput | MessageUpsertWithWhereUniqueWithoutChannelInput[]
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChannelInput | MessageUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChannelInput | MessageUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type PublicRelationsRecordUpdateOneWithoutChannelsNestedInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutChannelsInput, PublicRelationsRecordUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutChannelsInput
    upsert?: PublicRelationsRecordUpsertWithoutChannelsInput
    disconnect?: PublicRelationsRecordWhereInput | boolean
    delete?: PublicRelationsRecordWhereInput | boolean
    connect?: PublicRelationsRecordWhereUniqueInput
    update?: XOR<XOR<PublicRelationsRecordUpdateToOneWithWhereWithoutChannelsInput, PublicRelationsRecordUpdateWithoutChannelsInput>, PublicRelationsRecordUncheckedUpdateWithoutChannelsInput>
  }

  export type MeetingUpdateOneWithoutChannelsNestedInput = {
    create?: XOR<MeetingCreateWithoutChannelsInput, MeetingUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutChannelsInput
    upsert?: MeetingUpsertWithoutChannelsInput
    disconnect?: MeetingWhereInput | boolean
    delete?: MeetingWhereInput | boolean
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutChannelsInput, MeetingUpdateWithoutChannelsInput>, MeetingUncheckedUpdateWithoutChannelsInput>
  }

  export type AdminRoleUpdateOneWithoutChannelsNestedInput = {
    create?: XOR<AdminRoleCreateWithoutChannelsInput, AdminRoleUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutChannelsInput
    upsert?: AdminRoleUpsertWithoutChannelsInput
    disconnect?: AdminRoleWhereInput | boolean
    delete?: AdminRoleWhereInput | boolean
    connect?: AdminRoleWhereUniqueInput
    update?: XOR<XOR<AdminRoleUpdateToOneWithWhereWithoutChannelsInput, AdminRoleUpdateWithoutChannelsInput>, AdminRoleUncheckedUpdateWithoutChannelsInput>
  }

  export type LegalCaseUpdateOneWithoutChannelsNestedInput = {
    create?: XOR<LegalCaseCreateWithoutChannelsInput, LegalCaseUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: LegalCaseCreateOrConnectWithoutChannelsInput
    upsert?: LegalCaseUpsertWithoutChannelsInput
    disconnect?: LegalCaseWhereInput | boolean
    delete?: LegalCaseWhereInput | boolean
    connect?: LegalCaseWhereUniqueInput
    update?: XOR<XOR<LegalCaseUpdateToOneWithWhereWithoutChannelsInput, LegalCaseUpdateWithoutChannelsInput>, LegalCaseUncheckedUpdateWithoutChannelsInput>
  }

  export type UserUncheckedUpdateManyWithoutChannelsNestedInput = {
    create?: XOR<UserCreateWithoutChannelsInput, UserUncheckedCreateWithoutChannelsInput> | UserCreateWithoutChannelsInput[] | UserUncheckedCreateWithoutChannelsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutChannelsInput | UserCreateOrConnectWithoutChannelsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutChannelsInput | UserUpsertWithWhereUniqueWithoutChannelsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutChannelsInput | UserUpdateWithWhereUniqueWithoutChannelsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutChannelsInput | UserUpdateManyWithWhereWithoutChannelsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput> | MessageCreateWithoutChannelInput[] | MessageUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutChannelInput | MessageCreateOrConnectWithoutChannelInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutChannelInput | MessageUpsertWithWhereUniqueWithoutChannelInput[]
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutChannelInput | MessageUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutChannelInput | MessageUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutOwnerInput = {
    create?: XOR<UserCreateWithoutOwnerInput, UserUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnerInput
    connect?: UserWhereUniqueInput
  }

  export type ChannelCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput> | ChannelCreateWithoutOwnerInput[] | ChannelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOwnerInput | ChannelCreateOrConnectWithoutOwnerInput[]
    createMany?: ChannelCreateManyOwnerInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput> | ChannelCreateWithoutOwnerInput[] | ChannelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOwnerInput | ChannelCreateOrConnectWithoutOwnerInput[]
    createMany?: ChannelCreateManyOwnerInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutOwnerNestedInput = {
    create?: XOR<UserCreateWithoutOwnerInput, UserUncheckedCreateWithoutOwnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnerInput
    upsert?: UserUpsertWithoutOwnerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnerInput, UserUpdateWithoutOwnerInput>, UserUncheckedUpdateWithoutOwnerInput>
  }

  export type ChannelUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput> | ChannelCreateWithoutOwnerInput[] | ChannelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOwnerInput | ChannelCreateOrConnectWithoutOwnerInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutOwnerInput | ChannelUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ChannelCreateManyOwnerInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutOwnerInput | ChannelUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutOwnerInput | ChannelUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput> | ChannelCreateWithoutOwnerInput[] | ChannelUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutOwnerInput | ChannelCreateOrConnectWithoutOwnerInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutOwnerInput | ChannelUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ChannelCreateManyOwnerInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutOwnerInput | ChannelUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutOwnerInput | ChannelUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookmarksInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookmarksInput
    upsert?: UserUpsertWithoutBookmarksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookmarksInput, UserUpdateWithoutBookmarksInput>, UserUncheckedUpdateWithoutBookmarksInput>
  }

  export type AcademyCreateNestedOneWithoutEventsInput = {
    create?: XOR<AcademyCreateWithoutEventsInput, AcademyUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutEventsInput
    connect?: AcademyWhereUniqueInput
  }

  export type PublicRelationsRecordCreateNestedOneWithoutEventsInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutEventsInput, PublicRelationsRecordUncheckedCreateWithoutEventsInput>
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutEventsInput
    connect?: PublicRelationsRecordWhereUniqueInput
  }

  export type AdminRoleCreateNestedOneWithoutEventsInput = {
    create?: XOR<AdminRoleCreateWithoutEventsInput, AdminRoleUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutEventsInput
    connect?: AdminRoleWhereUniqueInput
  }

  export type LegalCaseCreateNestedOneWithoutEventsInput = {
    create?: XOR<LegalCaseCreateWithoutEventsInput, LegalCaseUncheckedCreateWithoutEventsInput>
    connectOrCreate?: LegalCaseCreateOrConnectWithoutEventsInput
    connect?: LegalCaseWhereUniqueInput
  }

  export type AcademyUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<AcademyCreateWithoutEventsInput, AcademyUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutEventsInput
    upsert?: AcademyUpsertWithoutEventsInput
    connect?: AcademyWhereUniqueInput
    update?: XOR<XOR<AcademyUpdateToOneWithWhereWithoutEventsInput, AcademyUpdateWithoutEventsInput>, AcademyUncheckedUpdateWithoutEventsInput>
  }

  export type PublicRelationsRecordUpdateOneWithoutEventsNestedInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutEventsInput, PublicRelationsRecordUncheckedCreateWithoutEventsInput>
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutEventsInput
    upsert?: PublicRelationsRecordUpsertWithoutEventsInput
    disconnect?: PublicRelationsRecordWhereInput | boolean
    delete?: PublicRelationsRecordWhereInput | boolean
    connect?: PublicRelationsRecordWhereUniqueInput
    update?: XOR<XOR<PublicRelationsRecordUpdateToOneWithWhereWithoutEventsInput, PublicRelationsRecordUpdateWithoutEventsInput>, PublicRelationsRecordUncheckedUpdateWithoutEventsInput>
  }

  export type AdminRoleUpdateOneWithoutEventsNestedInput = {
    create?: XOR<AdminRoleCreateWithoutEventsInput, AdminRoleUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutEventsInput
    upsert?: AdminRoleUpsertWithoutEventsInput
    disconnect?: AdminRoleWhereInput | boolean
    delete?: AdminRoleWhereInput | boolean
    connect?: AdminRoleWhereUniqueInput
    update?: XOR<XOR<AdminRoleUpdateToOneWithWhereWithoutEventsInput, AdminRoleUpdateWithoutEventsInput>, AdminRoleUncheckedUpdateWithoutEventsInput>
  }

  export type LegalCaseUpdateOneWithoutEventsNestedInput = {
    create?: XOR<LegalCaseCreateWithoutEventsInput, LegalCaseUncheckedCreateWithoutEventsInput>
    connectOrCreate?: LegalCaseCreateOrConnectWithoutEventsInput
    upsert?: LegalCaseUpsertWithoutEventsInput
    disconnect?: LegalCaseWhereInput | boolean
    delete?: LegalCaseWhereInput | boolean
    connect?: LegalCaseWhereUniqueInput
    update?: XOR<XOR<LegalCaseUpdateToOneWithWhereWithoutEventsInput, LegalCaseUpdateWithoutEventsInput>, LegalCaseUncheckedUpdateWithoutEventsInput>
  }

  export type UserCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<LessonCreateWithoutAttendanceInput, LessonUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: LessonCreateOrConnectWithoutAttendanceInput
    connect?: LessonWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendanceInput
    upsert?: UserUpsertWithoutAttendanceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendanceInput, UserUpdateWithoutAttendanceInput>, UserUncheckedUpdateWithoutAttendanceInput>
  }

  export type LessonUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<LessonCreateWithoutAttendanceInput, LessonUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: LessonCreateOrConnectWithoutAttendanceInput
    upsert?: LessonUpsertWithoutAttendanceInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutAttendanceInput, LessonUpdateWithoutAttendanceInput>, LessonUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserCreateNestedOneWithoutPaymentInput = {
    create?: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentInput
    connect?: UserWhereUniqueInput
  }

  export type LegalCaseCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<LegalCaseCreateWithoutPaymentsInput, LegalCaseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: LegalCaseCreateOrConnectWithoutPaymentsInput
    connect?: LegalCaseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentInput
    upsert?: UserUpsertWithoutPaymentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentInput, UserUpdateWithoutPaymentInput>, UserUncheckedUpdateWithoutPaymentInput>
  }

  export type LegalCaseUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<LegalCaseCreateWithoutPaymentsInput, LegalCaseUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: LegalCaseCreateOrConnectWithoutPaymentsInput
    upsert?: LegalCaseUpsertWithoutPaymentsInput
    disconnect?: LegalCaseWhereInput | boolean
    delete?: LegalCaseWhereInput | boolean
    connect?: LegalCaseWhereUniqueInput
    update?: XOR<XOR<LegalCaseUpdateToOneWithWhereWithoutPaymentsInput, LegalCaseUpdateWithoutPaymentsInput>, LegalCaseUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutReportInput = {
    create?: XOR<UserCreateWithoutReportInput, UserUncheckedCreateWithoutReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportInput
    connect?: UserWhereUniqueInput
  }

  export type AccountingEntryCreateNestedOneWithoutReportsInput = {
    create?: XOR<AccountingEntryCreateWithoutReportsInput, AccountingEntryUncheckedCreateWithoutReportsInput>
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutReportsInput
    connect?: AccountingEntryWhereUniqueInput
  }

  export type MeetingCreateNestedOneWithoutReportsInput = {
    create?: XOR<MeetingCreateWithoutReportsInput, MeetingUncheckedCreateWithoutReportsInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutReportsInput
    connect?: MeetingWhereUniqueInput
  }

  export type AdminRoleCreateNestedOneWithoutReportsInput = {
    create?: XOR<AdminRoleCreateWithoutReportsInput, AdminRoleUncheckedCreateWithoutReportsInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutReportsInput
    connect?: AdminRoleWhereUniqueInput
  }

  export type LegalCaseCreateNestedOneWithoutReportsInput = {
    create?: XOR<LegalCaseCreateWithoutReportsInput, LegalCaseUncheckedCreateWithoutReportsInput>
    connectOrCreate?: LegalCaseCreateOrConnectWithoutReportsInput
    connect?: LegalCaseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReportNestedInput = {
    create?: XOR<UserCreateWithoutReportInput, UserUncheckedCreateWithoutReportInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportInput
    upsert?: UserUpsertWithoutReportInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportInput, UserUpdateWithoutReportInput>, UserUncheckedUpdateWithoutReportInput>
  }

  export type AccountingEntryUpdateOneWithoutReportsNestedInput = {
    create?: XOR<AccountingEntryCreateWithoutReportsInput, AccountingEntryUncheckedCreateWithoutReportsInput>
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutReportsInput
    upsert?: AccountingEntryUpsertWithoutReportsInput
    disconnect?: AccountingEntryWhereInput | boolean
    delete?: AccountingEntryWhereInput | boolean
    connect?: AccountingEntryWhereUniqueInput
    update?: XOR<XOR<AccountingEntryUpdateToOneWithWhereWithoutReportsInput, AccountingEntryUpdateWithoutReportsInput>, AccountingEntryUncheckedUpdateWithoutReportsInput>
  }

  export type MeetingUpdateOneWithoutReportsNestedInput = {
    create?: XOR<MeetingCreateWithoutReportsInput, MeetingUncheckedCreateWithoutReportsInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutReportsInput
    upsert?: MeetingUpsertWithoutReportsInput
    disconnect?: MeetingWhereInput | boolean
    delete?: MeetingWhereInput | boolean
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutReportsInput, MeetingUpdateWithoutReportsInput>, MeetingUncheckedUpdateWithoutReportsInput>
  }

  export type AdminRoleUpdateOneWithoutReportsNestedInput = {
    create?: XOR<AdminRoleCreateWithoutReportsInput, AdminRoleUncheckedCreateWithoutReportsInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutReportsInput
    upsert?: AdminRoleUpsertWithoutReportsInput
    disconnect?: AdminRoleWhereInput | boolean
    delete?: AdminRoleWhereInput | boolean
    connect?: AdminRoleWhereUniqueInput
    update?: XOR<XOR<AdminRoleUpdateToOneWithWhereWithoutReportsInput, AdminRoleUpdateWithoutReportsInput>, AdminRoleUncheckedUpdateWithoutReportsInput>
  }

  export type LegalCaseUpdateOneWithoutReportsNestedInput = {
    create?: XOR<LegalCaseCreateWithoutReportsInput, LegalCaseUncheckedCreateWithoutReportsInput>
    connectOrCreate?: LegalCaseCreateOrConnectWithoutReportsInput
    upsert?: LegalCaseUpsertWithoutReportsInput
    disconnect?: LegalCaseWhereInput | boolean
    delete?: LegalCaseWhereInput | boolean
    connect?: LegalCaseWhereUniqueInput
    update?: XOR<XOR<LegalCaseUpdateToOneWithWhereWithoutReportsInput, LegalCaseUpdateWithoutReportsInput>, LegalCaseUncheckedUpdateWithoutReportsInput>
  }

  export type UserCreateNestedOneWithoutBadgeInput = {
    create?: XOR<UserCreateWithoutBadgeInput, UserUncheckedCreateWithoutBadgeInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgeInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBadgeNestedInput = {
    create?: XOR<UserCreateWithoutBadgeInput, UserUncheckedCreateWithoutBadgeInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgeInput
    upsert?: UserUpsertWithoutBadgeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBadgeInput, UserUpdateWithoutBadgeInput>, UserUncheckedUpdateWithoutBadgeInput>
  }

  export type UserCreateNestedOneWithoutCertificateInput = {
    create?: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificateInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCertificateNestedInput = {
    create?: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificateInput
    upsert?: UserUpsertWithoutCertificateInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificateInput, UserUpdateWithoutCertificateInput>, UserUncheckedUpdateWithoutCertificateInput>
  }

  export type GroupCreateNestedManyWithoutCommunityInput = {
    create?: XOR<GroupCreateWithoutCommunityInput, GroupUncheckedCreateWithoutCommunityInput> | GroupCreateWithoutCommunityInput[] | GroupUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCommunityInput | GroupCreateOrConnectWithoutCommunityInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type LiveRoomCreateNestedManyWithoutCommunityInput = {
    create?: XOR<LiveRoomCreateWithoutCommunityInput, LiveRoomUncheckedCreateWithoutCommunityInput> | LiveRoomCreateWithoutCommunityInput[] | LiveRoomUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutCommunityInput | LiveRoomCreateOrConnectWithoutCommunityInput[]
    createMany?: LiveRoomCreateManyCommunityInputEnvelope
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCommunityInput = {
    create?: XOR<UserCreateWithoutCommunityInput, UserUncheckedCreateWithoutCommunityInput> | UserCreateWithoutCommunityInput[] | UserUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCommunityInput | UserCreateOrConnectWithoutCommunityInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type DiscussionCreateNestedManyWithoutCommunityInput = {
    create?: XOR<DiscussionCreateWithoutCommunityInput, DiscussionUncheckedCreateWithoutCommunityInput> | DiscussionCreateWithoutCommunityInput[] | DiscussionUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiscussionCreateOrConnectWithoutCommunityInput | DiscussionCreateOrConnectWithoutCommunityInput[]
    createMany?: DiscussionCreateManyCommunityInputEnvelope
    connect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
  }

  export type GroupUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<GroupCreateWithoutCommunityInput, GroupUncheckedCreateWithoutCommunityInput> | GroupCreateWithoutCommunityInput[] | GroupUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCommunityInput | GroupCreateOrConnectWithoutCommunityInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
  }

  export type LiveRoomUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<LiveRoomCreateWithoutCommunityInput, LiveRoomUncheckedCreateWithoutCommunityInput> | LiveRoomCreateWithoutCommunityInput[] | LiveRoomUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutCommunityInput | LiveRoomCreateOrConnectWithoutCommunityInput[]
    createMany?: LiveRoomCreateManyCommunityInputEnvelope
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<UserCreateWithoutCommunityInput, UserUncheckedCreateWithoutCommunityInput> | UserCreateWithoutCommunityInput[] | UserUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCommunityInput | UserCreateOrConnectWithoutCommunityInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type DiscussionUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<DiscussionCreateWithoutCommunityInput, DiscussionUncheckedCreateWithoutCommunityInput> | DiscussionCreateWithoutCommunityInput[] | DiscussionUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiscussionCreateOrConnectWithoutCommunityInput | DiscussionCreateOrConnectWithoutCommunityInput[]
    createMany?: DiscussionCreateManyCommunityInputEnvelope
    connect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
  }

  export type GroupUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<GroupCreateWithoutCommunityInput, GroupUncheckedCreateWithoutCommunityInput> | GroupCreateWithoutCommunityInput[] | GroupUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCommunityInput | GroupCreateOrConnectWithoutCommunityInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutCommunityInput | GroupUpsertWithWhereUniqueWithoutCommunityInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutCommunityInput | GroupUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutCommunityInput | GroupUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type LiveRoomUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<LiveRoomCreateWithoutCommunityInput, LiveRoomUncheckedCreateWithoutCommunityInput> | LiveRoomCreateWithoutCommunityInput[] | LiveRoomUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutCommunityInput | LiveRoomCreateOrConnectWithoutCommunityInput[]
    upsert?: LiveRoomUpsertWithWhereUniqueWithoutCommunityInput | LiveRoomUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: LiveRoomCreateManyCommunityInputEnvelope
    set?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    disconnect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    delete?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    update?: LiveRoomUpdateWithWhereUniqueWithoutCommunityInput | LiveRoomUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: LiveRoomUpdateManyWithWhereWithoutCommunityInput | LiveRoomUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: LiveRoomScalarWhereInput | LiveRoomScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<UserCreateWithoutCommunityInput, UserUncheckedCreateWithoutCommunityInput> | UserCreateWithoutCommunityInput[] | UserUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCommunityInput | UserCreateOrConnectWithoutCommunityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCommunityInput | UserUpsertWithWhereUniqueWithoutCommunityInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCommunityInput | UserUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCommunityInput | UserUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PostUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCommunityInput | PostUpsertWithWhereUniqueWithoutCommunityInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCommunityInput | PostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCommunityInput | PostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type DiscussionUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<DiscussionCreateWithoutCommunityInput, DiscussionUncheckedCreateWithoutCommunityInput> | DiscussionCreateWithoutCommunityInput[] | DiscussionUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiscussionCreateOrConnectWithoutCommunityInput | DiscussionCreateOrConnectWithoutCommunityInput[]
    upsert?: DiscussionUpsertWithWhereUniqueWithoutCommunityInput | DiscussionUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: DiscussionCreateManyCommunityInputEnvelope
    set?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    disconnect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    delete?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    connect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    update?: DiscussionUpdateWithWhereUniqueWithoutCommunityInput | DiscussionUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: DiscussionUpdateManyWithWhereWithoutCommunityInput | DiscussionUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: DiscussionScalarWhereInput | DiscussionScalarWhereInput[]
  }

  export type GroupUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<GroupCreateWithoutCommunityInput, GroupUncheckedCreateWithoutCommunityInput> | GroupCreateWithoutCommunityInput[] | GroupUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: GroupCreateOrConnectWithoutCommunityInput | GroupCreateOrConnectWithoutCommunityInput[]
    upsert?: GroupUpsertWithWhereUniqueWithoutCommunityInput | GroupUpsertWithWhereUniqueWithoutCommunityInput[]
    set?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    disconnect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    delete?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    connect?: GroupWhereUniqueInput | GroupWhereUniqueInput[]
    update?: GroupUpdateWithWhereUniqueWithoutCommunityInput | GroupUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: GroupUpdateManyWithWhereWithoutCommunityInput | GroupUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: GroupScalarWhereInput | GroupScalarWhereInput[]
  }

  export type LiveRoomUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<LiveRoomCreateWithoutCommunityInput, LiveRoomUncheckedCreateWithoutCommunityInput> | LiveRoomCreateWithoutCommunityInput[] | LiveRoomUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: LiveRoomCreateOrConnectWithoutCommunityInput | LiveRoomCreateOrConnectWithoutCommunityInput[]
    upsert?: LiveRoomUpsertWithWhereUniqueWithoutCommunityInput | LiveRoomUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: LiveRoomCreateManyCommunityInputEnvelope
    set?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    disconnect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    delete?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    connect?: LiveRoomWhereUniqueInput | LiveRoomWhereUniqueInput[]
    update?: LiveRoomUpdateWithWhereUniqueWithoutCommunityInput | LiveRoomUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: LiveRoomUpdateManyWithWhereWithoutCommunityInput | LiveRoomUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: LiveRoomScalarWhereInput | LiveRoomScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<UserCreateWithoutCommunityInput, UserUncheckedCreateWithoutCommunityInput> | UserCreateWithoutCommunityInput[] | UserUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCommunityInput | UserCreateOrConnectWithoutCommunityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCommunityInput | UserUpsertWithWhereUniqueWithoutCommunityInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCommunityInput | UserUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCommunityInput | UserUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput> | PostCreateWithoutCommunityInput[] | PostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCommunityInput | PostCreateOrConnectWithoutCommunityInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCommunityInput | PostUpsertWithWhereUniqueWithoutCommunityInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCommunityInput | PostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCommunityInput | PostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type DiscussionUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<DiscussionCreateWithoutCommunityInput, DiscussionUncheckedCreateWithoutCommunityInput> | DiscussionCreateWithoutCommunityInput[] | DiscussionUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: DiscussionCreateOrConnectWithoutCommunityInput | DiscussionCreateOrConnectWithoutCommunityInput[]
    upsert?: DiscussionUpsertWithWhereUniqueWithoutCommunityInput | DiscussionUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: DiscussionCreateManyCommunityInputEnvelope
    set?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    disconnect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    delete?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    connect?: DiscussionWhereUniqueInput | DiscussionWhereUniqueInput[]
    update?: DiscussionUpdateWithWhereUniqueWithoutCommunityInput | DiscussionUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: DiscussionUpdateManyWithWhereWithoutCommunityInput | DiscussionUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: DiscussionScalarWhereInput | DiscussionScalarWhereInput[]
  }

  export type CommunityCreateNestedOneWithoutDiscussionsInput = {
    create?: XOR<CommunityCreateWithoutDiscussionsInput, CommunityUncheckedCreateWithoutDiscussionsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutDiscussionsInput
    connect?: CommunityWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutDiscussionInput = {
    create?: XOR<PostCreateWithoutDiscussionInput, PostUncheckedCreateWithoutDiscussionInput>
    connectOrCreate?: PostCreateOrConnectWithoutDiscussionInput
    connect?: PostWhereUniqueInput
  }

  export type CommunityUpdateOneRequiredWithoutDiscussionsNestedInput = {
    create?: XOR<CommunityCreateWithoutDiscussionsInput, CommunityUncheckedCreateWithoutDiscussionsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutDiscussionsInput
    upsert?: CommunityUpsertWithoutDiscussionsInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutDiscussionsInput, CommunityUpdateWithoutDiscussionsInput>, CommunityUncheckedUpdateWithoutDiscussionsInput>
  }

  export type PostUpdateOneWithoutDiscussionNestedInput = {
    create?: XOR<PostCreateWithoutDiscussionInput, PostUncheckedCreateWithoutDiscussionInput>
    connectOrCreate?: PostCreateOrConnectWithoutDiscussionInput
    upsert?: PostUpsertWithoutDiscussionInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutDiscussionInput, PostUpdateWithoutDiscussionInput>, PostUncheckedUpdateWithoutDiscussionInput>
  }

  export type CommunityCreateNestedOneWithoutLiveRoomInput = {
    create?: XOR<CommunityCreateWithoutLiveRoomInput, CommunityUncheckedCreateWithoutLiveRoomInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutLiveRoomInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutLiveRoomInput = {
    create?: XOR<UserCreateWithoutLiveRoomInput, UserUncheckedCreateWithoutLiveRoomInput> | UserCreateWithoutLiveRoomInput[] | UserUncheckedCreateWithoutLiveRoomInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLiveRoomInput | UserCreateOrConnectWithoutLiveRoomInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CourseCreateNestedOneWithoutLiveRoomInput = {
    create?: XOR<CourseCreateWithoutLiveRoomInput, CourseUncheckedCreateWithoutLiveRoomInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLiveRoomInput
    connect?: CourseWhereUniqueInput
  }

  export type UserUncheckedCreateNestedManyWithoutLiveRoomInput = {
    create?: XOR<UserCreateWithoutLiveRoomInput, UserUncheckedCreateWithoutLiveRoomInput> | UserCreateWithoutLiveRoomInput[] | UserUncheckedCreateWithoutLiveRoomInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLiveRoomInput | UserCreateOrConnectWithoutLiveRoomInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CommunityUpdateOneRequiredWithoutLiveRoomNestedInput = {
    create?: XOR<CommunityCreateWithoutLiveRoomInput, CommunityUncheckedCreateWithoutLiveRoomInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutLiveRoomInput
    upsert?: CommunityUpsertWithoutLiveRoomInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutLiveRoomInput, CommunityUpdateWithoutLiveRoomInput>, CommunityUncheckedUpdateWithoutLiveRoomInput>
  }

  export type UserUpdateManyWithoutLiveRoomNestedInput = {
    create?: XOR<UserCreateWithoutLiveRoomInput, UserUncheckedCreateWithoutLiveRoomInput> | UserCreateWithoutLiveRoomInput[] | UserUncheckedCreateWithoutLiveRoomInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLiveRoomInput | UserCreateOrConnectWithoutLiveRoomInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLiveRoomInput | UserUpsertWithWhereUniqueWithoutLiveRoomInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLiveRoomInput | UserUpdateWithWhereUniqueWithoutLiveRoomInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLiveRoomInput | UserUpdateManyWithWhereWithoutLiveRoomInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CourseUpdateOneWithoutLiveRoomNestedInput = {
    create?: XOR<CourseCreateWithoutLiveRoomInput, CourseUncheckedCreateWithoutLiveRoomInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLiveRoomInput
    upsert?: CourseUpsertWithoutLiveRoomInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLiveRoomInput, CourseUpdateWithoutLiveRoomInput>, CourseUncheckedUpdateWithoutLiveRoomInput>
  }

  export type UserUncheckedUpdateManyWithoutLiveRoomNestedInput = {
    create?: XOR<UserCreateWithoutLiveRoomInput, UserUncheckedCreateWithoutLiveRoomInput> | UserCreateWithoutLiveRoomInput[] | UserUncheckedCreateWithoutLiveRoomInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLiveRoomInput | UserCreateOrConnectWithoutLiveRoomInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLiveRoomInput | UserUpsertWithWhereUniqueWithoutLiveRoomInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLiveRoomInput | UserUpdateWithWhereUniqueWithoutLiveRoomInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLiveRoomInput | UserUpdateManyWithWhereWithoutLiveRoomInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutAccountingEntriesInput = {
    create?: XOR<AdminCreateWithoutAccountingEntriesInput, AdminUncheckedCreateWithoutAccountingEntriesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAccountingEntriesInput
    connect?: AdminWhereUniqueInput
  }

  export type AcademyCreateNestedOneWithoutAccountingEntryInput = {
    create?: XOR<AcademyCreateWithoutAccountingEntryInput, AcademyUncheckedCreateWithoutAccountingEntryInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutAccountingEntryInput
    connect?: AcademyWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutAccountingEntryInput = {
    create?: XOR<InvoiceCreateWithoutAccountingEntryInput, InvoiceUncheckedCreateWithoutAccountingEntryInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutAccountingEntryInput
    connect?: InvoiceWhereUniqueInput
  }

  export type SalaryPaymentCreateNestedOneWithoutAccountingEntryInput = {
    create?: XOR<SalaryPaymentCreateWithoutAccountingEntryInput, SalaryPaymentUncheckedCreateWithoutAccountingEntryInput>
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutAccountingEntryInput
    connect?: SalaryPaymentWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutAccountingEntryInput = {
    create?: XOR<FileCreateWithoutAccountingEntryInput, FileUncheckedCreateWithoutAccountingEntryInput> | FileCreateWithoutAccountingEntryInput[] | FileUncheckedCreateWithoutAccountingEntryInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAccountingEntryInput | FileCreateOrConnectWithoutAccountingEntryInput[]
    createMany?: FileCreateManyAccountingEntryInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutAccountingEntryInput = {
    create?: XOR<ReportCreateWithoutAccountingEntryInput, ReportUncheckedCreateWithoutAccountingEntryInput> | ReportCreateWithoutAccountingEntryInput[] | ReportUncheckedCreateWithoutAccountingEntryInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAccountingEntryInput | ReportCreateOrConnectWithoutAccountingEntryInput[]
    createMany?: ReportCreateManyAccountingEntryInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutAccountingEntryInput = {
    create?: XOR<InvoiceCreateWithoutAccountingEntryInput, InvoiceUncheckedCreateWithoutAccountingEntryInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutAccountingEntryInput
    connect?: InvoiceWhereUniqueInput
  }

  export type SalaryPaymentUncheckedCreateNestedOneWithoutAccountingEntryInput = {
    create?: XOR<SalaryPaymentCreateWithoutAccountingEntryInput, SalaryPaymentUncheckedCreateWithoutAccountingEntryInput>
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutAccountingEntryInput
    connect?: SalaryPaymentWhereUniqueInput
  }

  export type FileUncheckedCreateNestedManyWithoutAccountingEntryInput = {
    create?: XOR<FileCreateWithoutAccountingEntryInput, FileUncheckedCreateWithoutAccountingEntryInput> | FileCreateWithoutAccountingEntryInput[] | FileUncheckedCreateWithoutAccountingEntryInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAccountingEntryInput | FileCreateOrConnectWithoutAccountingEntryInput[]
    createMany?: FileCreateManyAccountingEntryInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutAccountingEntryInput = {
    create?: XOR<ReportCreateWithoutAccountingEntryInput, ReportUncheckedCreateWithoutAccountingEntryInput> | ReportCreateWithoutAccountingEntryInput[] | ReportUncheckedCreateWithoutAccountingEntryInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAccountingEntryInput | ReportCreateOrConnectWithoutAccountingEntryInput[]
    createMany?: ReportCreateManyAccountingEntryInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EnumAccountingTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountingType
  }

  export type AdminUpdateOneRequiredWithoutAccountingEntriesNestedInput = {
    create?: XOR<AdminCreateWithoutAccountingEntriesInput, AdminUncheckedCreateWithoutAccountingEntriesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAccountingEntriesInput
    upsert?: AdminUpsertWithoutAccountingEntriesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAccountingEntriesInput, AdminUpdateWithoutAccountingEntriesInput>, AdminUncheckedUpdateWithoutAccountingEntriesInput>
  }

  export type AcademyUpdateOneRequiredWithoutAccountingEntryNestedInput = {
    create?: XOR<AcademyCreateWithoutAccountingEntryInput, AcademyUncheckedCreateWithoutAccountingEntryInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutAccountingEntryInput
    upsert?: AcademyUpsertWithoutAccountingEntryInput
    connect?: AcademyWhereUniqueInput
    update?: XOR<XOR<AcademyUpdateToOneWithWhereWithoutAccountingEntryInput, AcademyUpdateWithoutAccountingEntryInput>, AcademyUncheckedUpdateWithoutAccountingEntryInput>
  }

  export type InvoiceUpdateOneWithoutAccountingEntryNestedInput = {
    create?: XOR<InvoiceCreateWithoutAccountingEntryInput, InvoiceUncheckedCreateWithoutAccountingEntryInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutAccountingEntryInput
    upsert?: InvoiceUpsertWithoutAccountingEntryInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutAccountingEntryInput, InvoiceUpdateWithoutAccountingEntryInput>, InvoiceUncheckedUpdateWithoutAccountingEntryInput>
  }

  export type SalaryPaymentUpdateOneWithoutAccountingEntryNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutAccountingEntryInput, SalaryPaymentUncheckedCreateWithoutAccountingEntryInput>
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutAccountingEntryInput
    upsert?: SalaryPaymentUpsertWithoutAccountingEntryInput
    disconnect?: SalaryPaymentWhereInput | boolean
    delete?: SalaryPaymentWhereInput | boolean
    connect?: SalaryPaymentWhereUniqueInput
    update?: XOR<XOR<SalaryPaymentUpdateToOneWithWhereWithoutAccountingEntryInput, SalaryPaymentUpdateWithoutAccountingEntryInput>, SalaryPaymentUncheckedUpdateWithoutAccountingEntryInput>
  }

  export type FileUpdateManyWithoutAccountingEntryNestedInput = {
    create?: XOR<FileCreateWithoutAccountingEntryInput, FileUncheckedCreateWithoutAccountingEntryInput> | FileCreateWithoutAccountingEntryInput[] | FileUncheckedCreateWithoutAccountingEntryInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAccountingEntryInput | FileCreateOrConnectWithoutAccountingEntryInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutAccountingEntryInput | FileUpsertWithWhereUniqueWithoutAccountingEntryInput[]
    createMany?: FileCreateManyAccountingEntryInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutAccountingEntryInput | FileUpdateWithWhereUniqueWithoutAccountingEntryInput[]
    updateMany?: FileUpdateManyWithWhereWithoutAccountingEntryInput | FileUpdateManyWithWhereWithoutAccountingEntryInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutAccountingEntryNestedInput = {
    create?: XOR<ReportCreateWithoutAccountingEntryInput, ReportUncheckedCreateWithoutAccountingEntryInput> | ReportCreateWithoutAccountingEntryInput[] | ReportUncheckedCreateWithoutAccountingEntryInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAccountingEntryInput | ReportCreateOrConnectWithoutAccountingEntryInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAccountingEntryInput | ReportUpsertWithWhereUniqueWithoutAccountingEntryInput[]
    createMany?: ReportCreateManyAccountingEntryInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAccountingEntryInput | ReportUpdateWithWhereUniqueWithoutAccountingEntryInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAccountingEntryInput | ReportUpdateManyWithWhereWithoutAccountingEntryInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutAccountingEntryNestedInput = {
    create?: XOR<InvoiceCreateWithoutAccountingEntryInput, InvoiceUncheckedCreateWithoutAccountingEntryInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutAccountingEntryInput
    upsert?: InvoiceUpsertWithoutAccountingEntryInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutAccountingEntryInput, InvoiceUpdateWithoutAccountingEntryInput>, InvoiceUncheckedUpdateWithoutAccountingEntryInput>
  }

  export type SalaryPaymentUncheckedUpdateOneWithoutAccountingEntryNestedInput = {
    create?: XOR<SalaryPaymentCreateWithoutAccountingEntryInput, SalaryPaymentUncheckedCreateWithoutAccountingEntryInput>
    connectOrCreate?: SalaryPaymentCreateOrConnectWithoutAccountingEntryInput
    upsert?: SalaryPaymentUpsertWithoutAccountingEntryInput
    disconnect?: SalaryPaymentWhereInput | boolean
    delete?: SalaryPaymentWhereInput | boolean
    connect?: SalaryPaymentWhereUniqueInput
    update?: XOR<XOR<SalaryPaymentUpdateToOneWithWhereWithoutAccountingEntryInput, SalaryPaymentUpdateWithoutAccountingEntryInput>, SalaryPaymentUncheckedUpdateWithoutAccountingEntryInput>
  }

  export type FileUncheckedUpdateManyWithoutAccountingEntryNestedInput = {
    create?: XOR<FileCreateWithoutAccountingEntryInput, FileUncheckedCreateWithoutAccountingEntryInput> | FileCreateWithoutAccountingEntryInput[] | FileUncheckedCreateWithoutAccountingEntryInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAccountingEntryInput | FileCreateOrConnectWithoutAccountingEntryInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutAccountingEntryInput | FileUpsertWithWhereUniqueWithoutAccountingEntryInput[]
    createMany?: FileCreateManyAccountingEntryInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutAccountingEntryInput | FileUpdateWithWhereUniqueWithoutAccountingEntryInput[]
    updateMany?: FileUpdateManyWithWhereWithoutAccountingEntryInput | FileUpdateManyWithWhereWithoutAccountingEntryInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutAccountingEntryNestedInput = {
    create?: XOR<ReportCreateWithoutAccountingEntryInput, ReportUncheckedCreateWithoutAccountingEntryInput> | ReportCreateWithoutAccountingEntryInput[] | ReportUncheckedCreateWithoutAccountingEntryInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAccountingEntryInput | ReportCreateOrConnectWithoutAccountingEntryInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAccountingEntryInput | ReportUpsertWithWhereUniqueWithoutAccountingEntryInput[]
    createMany?: ReportCreateManyAccountingEntryInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAccountingEntryInput | ReportUpdateWithWhereUniqueWithoutAccountingEntryInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAccountingEntryInput | ReportUpdateManyWithWhereWithoutAccountingEntryInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type AccountingEntryCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<AccountingEntryCreateWithoutInvoiceInput, AccountingEntryUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutInvoiceInput
    connect?: AccountingEntryWhereUniqueInput
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type AccountingEntryUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<AccountingEntryCreateWithoutInvoiceInput, AccountingEntryUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutInvoiceInput
    upsert?: AccountingEntryUpsertWithoutInvoiceInput
    connect?: AccountingEntryWhereUniqueInput
    update?: XOR<XOR<AccountingEntryUpdateToOneWithWhereWithoutInvoiceInput, AccountingEntryUpdateWithoutInvoiceInput>, AccountingEntryUncheckedUpdateWithoutInvoiceInput>
  }

  export type UserCreateNestedOneWithoutSalaryPaymentInput = {
    create?: XOR<UserCreateWithoutSalaryPaymentInput, UserUncheckedCreateWithoutSalaryPaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryPaymentInput
    connect?: UserWhereUniqueInput
  }

  export type AccountingEntryCreateNestedOneWithoutSalaryPaymentInput = {
    create?: XOR<AccountingEntryCreateWithoutSalaryPaymentInput, AccountingEntryUncheckedCreateWithoutSalaryPaymentInput>
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutSalaryPaymentInput
    connect?: AccountingEntryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSalaryPaymentNestedInput = {
    create?: XOR<UserCreateWithoutSalaryPaymentInput, UserUncheckedCreateWithoutSalaryPaymentInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryPaymentInput
    upsert?: UserUpsertWithoutSalaryPaymentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalaryPaymentInput, UserUpdateWithoutSalaryPaymentInput>, UserUncheckedUpdateWithoutSalaryPaymentInput>
  }

  export type AccountingEntryUpdateOneRequiredWithoutSalaryPaymentNestedInput = {
    create?: XOR<AccountingEntryCreateWithoutSalaryPaymentInput, AccountingEntryUncheckedCreateWithoutSalaryPaymentInput>
    connectOrCreate?: AccountingEntryCreateOrConnectWithoutSalaryPaymentInput
    upsert?: AccountingEntryUpsertWithoutSalaryPaymentInput
    connect?: AccountingEntryWhereUniqueInput
    update?: XOR<XOR<AccountingEntryUpdateToOneWithWhereWithoutSalaryPaymentInput, AccountingEntryUpdateWithoutSalaryPaymentInput>, AccountingEntryUncheckedUpdateWithoutSalaryPaymentInput>
  }

  export type AdminCreateNestedOneWithoutPrRecordsInput = {
    create?: XOR<AdminCreateWithoutPrRecordsInput, AdminUncheckedCreateWithoutPrRecordsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPrRecordsInput
    connect?: AdminWhereUniqueInput
  }

  export type AcademyCreateNestedOneWithoutPublicRelationsRecordInput = {
    create?: XOR<AcademyCreateWithoutPublicRelationsRecordInput, AcademyUncheckedCreateWithoutPublicRelationsRecordInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutPublicRelationsRecordInput
    connect?: AcademyWhereUniqueInput
  }

  export type PRResponseCreateNestedManyWithoutPrRecordInput = {
    create?: XOR<PRResponseCreateWithoutPrRecordInput, PRResponseUncheckedCreateWithoutPrRecordInput> | PRResponseCreateWithoutPrRecordInput[] | PRResponseUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: PRResponseCreateOrConnectWithoutPrRecordInput | PRResponseCreateOrConnectWithoutPrRecordInput[]
    createMany?: PRResponseCreateManyPrRecordInputEnvelope
    connect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutPrRecordInput = {
    create?: XOR<EventCreateWithoutPrRecordInput, EventUncheckedCreateWithoutPrRecordInput> | EventCreateWithoutPrRecordInput[] | EventUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: EventCreateOrConnectWithoutPrRecordInput | EventCreateOrConnectWithoutPrRecordInput[]
    createMany?: EventCreateManyPrRecordInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutPublicRelationsRecordInput = {
    create?: XOR<PostCreateWithoutPublicRelationsRecordInput, PostUncheckedCreateWithoutPublicRelationsRecordInput> | PostCreateWithoutPublicRelationsRecordInput[] | PostUncheckedCreateWithoutPublicRelationsRecordInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPublicRelationsRecordInput | PostCreateOrConnectWithoutPublicRelationsRecordInput[]
    createMany?: PostCreateManyPublicRelationsRecordInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutPrRecordInput = {
    create?: XOR<FileCreateWithoutPrRecordInput, FileUncheckedCreateWithoutPrRecordInput> | FileCreateWithoutPrRecordInput[] | FileUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPrRecordInput | FileCreateOrConnectWithoutPrRecordInput[]
    createMany?: FileCreateManyPrRecordInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ChannelCreateNestedManyWithoutPrRecordInput = {
    create?: XOR<ChannelCreateWithoutPrRecordInput, ChannelUncheckedCreateWithoutPrRecordInput> | ChannelCreateWithoutPrRecordInput[] | ChannelUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutPrRecordInput | ChannelCreateOrConnectWithoutPrRecordInput[]
    createMany?: ChannelCreateManyPrRecordInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type PRResponseUncheckedCreateNestedManyWithoutPrRecordInput = {
    create?: XOR<PRResponseCreateWithoutPrRecordInput, PRResponseUncheckedCreateWithoutPrRecordInput> | PRResponseCreateWithoutPrRecordInput[] | PRResponseUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: PRResponseCreateOrConnectWithoutPrRecordInput | PRResponseCreateOrConnectWithoutPrRecordInput[]
    createMany?: PRResponseCreateManyPrRecordInputEnvelope
    connect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutPrRecordInput = {
    create?: XOR<EventCreateWithoutPrRecordInput, EventUncheckedCreateWithoutPrRecordInput> | EventCreateWithoutPrRecordInput[] | EventUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: EventCreateOrConnectWithoutPrRecordInput | EventCreateOrConnectWithoutPrRecordInput[]
    createMany?: EventCreateManyPrRecordInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutPublicRelationsRecordInput = {
    create?: XOR<PostCreateWithoutPublicRelationsRecordInput, PostUncheckedCreateWithoutPublicRelationsRecordInput> | PostCreateWithoutPublicRelationsRecordInput[] | PostUncheckedCreateWithoutPublicRelationsRecordInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPublicRelationsRecordInput | PostCreateOrConnectWithoutPublicRelationsRecordInput[]
    createMany?: PostCreateManyPublicRelationsRecordInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutPrRecordInput = {
    create?: XOR<FileCreateWithoutPrRecordInput, FileUncheckedCreateWithoutPrRecordInput> | FileCreateWithoutPrRecordInput[] | FileUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPrRecordInput | FileCreateOrConnectWithoutPrRecordInput[]
    createMany?: FileCreateManyPrRecordInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutPrRecordInput = {
    create?: XOR<ChannelCreateWithoutPrRecordInput, ChannelUncheckedCreateWithoutPrRecordInput> | ChannelCreateWithoutPrRecordInput[] | ChannelUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutPrRecordInput | ChannelCreateOrConnectWithoutPrRecordInput[]
    createMany?: ChannelCreateManyPrRecordInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type EnumPRRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.PRRequestStatus
  }

  export type AdminUpdateOneRequiredWithoutPrRecordsNestedInput = {
    create?: XOR<AdminCreateWithoutPrRecordsInput, AdminUncheckedCreateWithoutPrRecordsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPrRecordsInput
    upsert?: AdminUpsertWithoutPrRecordsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutPrRecordsInput, AdminUpdateWithoutPrRecordsInput>, AdminUncheckedUpdateWithoutPrRecordsInput>
  }

  export type AcademyUpdateOneRequiredWithoutPublicRelationsRecordNestedInput = {
    create?: XOR<AcademyCreateWithoutPublicRelationsRecordInput, AcademyUncheckedCreateWithoutPublicRelationsRecordInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutPublicRelationsRecordInput
    upsert?: AcademyUpsertWithoutPublicRelationsRecordInput
    connect?: AcademyWhereUniqueInput
    update?: XOR<XOR<AcademyUpdateToOneWithWhereWithoutPublicRelationsRecordInput, AcademyUpdateWithoutPublicRelationsRecordInput>, AcademyUncheckedUpdateWithoutPublicRelationsRecordInput>
  }

  export type PRResponseUpdateManyWithoutPrRecordNestedInput = {
    create?: XOR<PRResponseCreateWithoutPrRecordInput, PRResponseUncheckedCreateWithoutPrRecordInput> | PRResponseCreateWithoutPrRecordInput[] | PRResponseUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: PRResponseCreateOrConnectWithoutPrRecordInput | PRResponseCreateOrConnectWithoutPrRecordInput[]
    upsert?: PRResponseUpsertWithWhereUniqueWithoutPrRecordInput | PRResponseUpsertWithWhereUniqueWithoutPrRecordInput[]
    createMany?: PRResponseCreateManyPrRecordInputEnvelope
    set?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    disconnect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    delete?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    connect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    update?: PRResponseUpdateWithWhereUniqueWithoutPrRecordInput | PRResponseUpdateWithWhereUniqueWithoutPrRecordInput[]
    updateMany?: PRResponseUpdateManyWithWhereWithoutPrRecordInput | PRResponseUpdateManyWithWhereWithoutPrRecordInput[]
    deleteMany?: PRResponseScalarWhereInput | PRResponseScalarWhereInput[]
  }

  export type EventUpdateManyWithoutPrRecordNestedInput = {
    create?: XOR<EventCreateWithoutPrRecordInput, EventUncheckedCreateWithoutPrRecordInput> | EventCreateWithoutPrRecordInput[] | EventUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: EventCreateOrConnectWithoutPrRecordInput | EventCreateOrConnectWithoutPrRecordInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutPrRecordInput | EventUpsertWithWhereUniqueWithoutPrRecordInput[]
    createMany?: EventCreateManyPrRecordInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutPrRecordInput | EventUpdateWithWhereUniqueWithoutPrRecordInput[]
    updateMany?: EventUpdateManyWithWhereWithoutPrRecordInput | EventUpdateManyWithWhereWithoutPrRecordInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type PostUpdateManyWithoutPublicRelationsRecordNestedInput = {
    create?: XOR<PostCreateWithoutPublicRelationsRecordInput, PostUncheckedCreateWithoutPublicRelationsRecordInput> | PostCreateWithoutPublicRelationsRecordInput[] | PostUncheckedCreateWithoutPublicRelationsRecordInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPublicRelationsRecordInput | PostCreateOrConnectWithoutPublicRelationsRecordInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutPublicRelationsRecordInput | PostUpsertWithWhereUniqueWithoutPublicRelationsRecordInput[]
    createMany?: PostCreateManyPublicRelationsRecordInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutPublicRelationsRecordInput | PostUpdateWithWhereUniqueWithoutPublicRelationsRecordInput[]
    updateMany?: PostUpdateManyWithWhereWithoutPublicRelationsRecordInput | PostUpdateManyWithWhereWithoutPublicRelationsRecordInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileUpdateManyWithoutPrRecordNestedInput = {
    create?: XOR<FileCreateWithoutPrRecordInput, FileUncheckedCreateWithoutPrRecordInput> | FileCreateWithoutPrRecordInput[] | FileUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPrRecordInput | FileCreateOrConnectWithoutPrRecordInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutPrRecordInput | FileUpsertWithWhereUniqueWithoutPrRecordInput[]
    createMany?: FileCreateManyPrRecordInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutPrRecordInput | FileUpdateWithWhereUniqueWithoutPrRecordInput[]
    updateMany?: FileUpdateManyWithWhereWithoutPrRecordInput | FileUpdateManyWithWhereWithoutPrRecordInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ChannelUpdateManyWithoutPrRecordNestedInput = {
    create?: XOR<ChannelCreateWithoutPrRecordInput, ChannelUncheckedCreateWithoutPrRecordInput> | ChannelCreateWithoutPrRecordInput[] | ChannelUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutPrRecordInput | ChannelCreateOrConnectWithoutPrRecordInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutPrRecordInput | ChannelUpsertWithWhereUniqueWithoutPrRecordInput[]
    createMany?: ChannelCreateManyPrRecordInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutPrRecordInput | ChannelUpdateWithWhereUniqueWithoutPrRecordInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutPrRecordInput | ChannelUpdateManyWithWhereWithoutPrRecordInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type PRResponseUncheckedUpdateManyWithoutPrRecordNestedInput = {
    create?: XOR<PRResponseCreateWithoutPrRecordInput, PRResponseUncheckedCreateWithoutPrRecordInput> | PRResponseCreateWithoutPrRecordInput[] | PRResponseUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: PRResponseCreateOrConnectWithoutPrRecordInput | PRResponseCreateOrConnectWithoutPrRecordInput[]
    upsert?: PRResponseUpsertWithWhereUniqueWithoutPrRecordInput | PRResponseUpsertWithWhereUniqueWithoutPrRecordInput[]
    createMany?: PRResponseCreateManyPrRecordInputEnvelope
    set?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    disconnect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    delete?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    connect?: PRResponseWhereUniqueInput | PRResponseWhereUniqueInput[]
    update?: PRResponseUpdateWithWhereUniqueWithoutPrRecordInput | PRResponseUpdateWithWhereUniqueWithoutPrRecordInput[]
    updateMany?: PRResponseUpdateManyWithWhereWithoutPrRecordInput | PRResponseUpdateManyWithWhereWithoutPrRecordInput[]
    deleteMany?: PRResponseScalarWhereInput | PRResponseScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutPrRecordNestedInput = {
    create?: XOR<EventCreateWithoutPrRecordInput, EventUncheckedCreateWithoutPrRecordInput> | EventCreateWithoutPrRecordInput[] | EventUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: EventCreateOrConnectWithoutPrRecordInput | EventCreateOrConnectWithoutPrRecordInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutPrRecordInput | EventUpsertWithWhereUniqueWithoutPrRecordInput[]
    createMany?: EventCreateManyPrRecordInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutPrRecordInput | EventUpdateWithWhereUniqueWithoutPrRecordInput[]
    updateMany?: EventUpdateManyWithWhereWithoutPrRecordInput | EventUpdateManyWithWhereWithoutPrRecordInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutPublicRelationsRecordNestedInput = {
    create?: XOR<PostCreateWithoutPublicRelationsRecordInput, PostUncheckedCreateWithoutPublicRelationsRecordInput> | PostCreateWithoutPublicRelationsRecordInput[] | PostUncheckedCreateWithoutPublicRelationsRecordInput[]
    connectOrCreate?: PostCreateOrConnectWithoutPublicRelationsRecordInput | PostCreateOrConnectWithoutPublicRelationsRecordInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutPublicRelationsRecordInput | PostUpsertWithWhereUniqueWithoutPublicRelationsRecordInput[]
    createMany?: PostCreateManyPublicRelationsRecordInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutPublicRelationsRecordInput | PostUpdateWithWhereUniqueWithoutPublicRelationsRecordInput[]
    updateMany?: PostUpdateManyWithWhereWithoutPublicRelationsRecordInput | PostUpdateManyWithWhereWithoutPublicRelationsRecordInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutPrRecordNestedInput = {
    create?: XOR<FileCreateWithoutPrRecordInput, FileUncheckedCreateWithoutPrRecordInput> | FileCreateWithoutPrRecordInput[] | FileUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: FileCreateOrConnectWithoutPrRecordInput | FileCreateOrConnectWithoutPrRecordInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutPrRecordInput | FileUpsertWithWhereUniqueWithoutPrRecordInput[]
    createMany?: FileCreateManyPrRecordInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutPrRecordInput | FileUpdateWithWhereUniqueWithoutPrRecordInput[]
    updateMany?: FileUpdateManyWithWhereWithoutPrRecordInput | FileUpdateManyWithWhereWithoutPrRecordInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutPrRecordNestedInput = {
    create?: XOR<ChannelCreateWithoutPrRecordInput, ChannelUncheckedCreateWithoutPrRecordInput> | ChannelCreateWithoutPrRecordInput[] | ChannelUncheckedCreateWithoutPrRecordInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutPrRecordInput | ChannelCreateOrConnectWithoutPrRecordInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutPrRecordInput | ChannelUpsertWithWhereUniqueWithoutPrRecordInput[]
    createMany?: ChannelCreateManyPrRecordInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutPrRecordInput | ChannelUpdateWithWhereUniqueWithoutPrRecordInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutPrRecordInput | ChannelUpdateManyWithWhereWithoutPrRecordInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type PublicRelationsRecordCreateNestedOneWithoutResponsesInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutResponsesInput, PublicRelationsRecordUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutResponsesInput
    connect?: PublicRelationsRecordWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutPrResponsesInput = {
    create?: XOR<AdminCreateWithoutPrResponsesInput, AdminUncheckedCreateWithoutPrResponsesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPrResponsesInput
    connect?: AdminWhereUniqueInput
  }

  export type PublicRelationsRecordUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<PublicRelationsRecordCreateWithoutResponsesInput, PublicRelationsRecordUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: PublicRelationsRecordCreateOrConnectWithoutResponsesInput
    upsert?: PublicRelationsRecordUpsertWithoutResponsesInput
    connect?: PublicRelationsRecordWhereUniqueInput
    update?: XOR<XOR<PublicRelationsRecordUpdateToOneWithWhereWithoutResponsesInput, PublicRelationsRecordUpdateWithoutResponsesInput>, PublicRelationsRecordUncheckedUpdateWithoutResponsesInput>
  }

  export type AdminUpdateOneRequiredWithoutPrResponsesNestedInput = {
    create?: XOR<AdminCreateWithoutPrResponsesInput, AdminUncheckedCreateWithoutPrResponsesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPrResponsesInput
    upsert?: AdminUpsertWithoutPrResponsesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutPrResponsesInput, AdminUpdateWithoutPrResponsesInput>, AdminUncheckedUpdateWithoutPrResponsesInput>
  }

  export type AdminCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<AdminCreateWithoutMeetingsInput, AdminUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutMeetingsInput
    connect?: AdminWhereUniqueInput
  }

  export type AcademyCreateNestedOneWithoutMeetingInput = {
    create?: XOR<AcademyCreateWithoutMeetingInput, AcademyUncheckedCreateWithoutMeetingInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutMeetingInput
    connect?: AcademyWhereUniqueInput
  }

  export type MeetingParticipantCreateNestedManyWithoutMeetingInput = {
    create?: XOR<MeetingParticipantCreateWithoutMeetingInput, MeetingParticipantUncheckedCreateWithoutMeetingInput> | MeetingParticipantCreateWithoutMeetingInput[] | MeetingParticipantUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingParticipantCreateOrConnectWithoutMeetingInput | MeetingParticipantCreateOrConnectWithoutMeetingInput[]
    createMany?: MeetingParticipantCreateManyMeetingInputEnvelope
    connect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutMeetingInput = {
    create?: XOR<FileCreateWithoutMeetingInput, FileUncheckedCreateWithoutMeetingInput> | FileCreateWithoutMeetingInput[] | FileUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMeetingInput | FileCreateOrConnectWithoutMeetingInput[]
    createMany?: FileCreateManyMeetingInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutMeetingInput = {
    create?: XOR<ReportCreateWithoutMeetingInput, ReportUncheckedCreateWithoutMeetingInput> | ReportCreateWithoutMeetingInput[] | ReportUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMeetingInput | ReportCreateOrConnectWithoutMeetingInput[]
    createMany?: ReportCreateManyMeetingInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ChannelCreateNestedManyWithoutMeetingInput = {
    create?: XOR<ChannelCreateWithoutMeetingInput, ChannelUncheckedCreateWithoutMeetingInput> | ChannelCreateWithoutMeetingInput[] | ChannelUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMeetingInput | ChannelCreateOrConnectWithoutMeetingInput[]
    createMany?: ChannelCreateManyMeetingInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type MeetingParticipantUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<MeetingParticipantCreateWithoutMeetingInput, MeetingParticipantUncheckedCreateWithoutMeetingInput> | MeetingParticipantCreateWithoutMeetingInput[] | MeetingParticipantUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingParticipantCreateOrConnectWithoutMeetingInput | MeetingParticipantCreateOrConnectWithoutMeetingInput[]
    createMany?: MeetingParticipantCreateManyMeetingInputEnvelope
    connect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<FileCreateWithoutMeetingInput, FileUncheckedCreateWithoutMeetingInput> | FileCreateWithoutMeetingInput[] | FileUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMeetingInput | FileCreateOrConnectWithoutMeetingInput[]
    createMany?: FileCreateManyMeetingInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<ReportCreateWithoutMeetingInput, ReportUncheckedCreateWithoutMeetingInput> | ReportCreateWithoutMeetingInput[] | ReportUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMeetingInput | ReportCreateOrConnectWithoutMeetingInput[]
    createMany?: ReportCreateManyMeetingInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<ChannelCreateWithoutMeetingInput, ChannelUncheckedCreateWithoutMeetingInput> | ChannelCreateWithoutMeetingInput[] | ChannelUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMeetingInput | ChannelCreateOrConnectWithoutMeetingInput[]
    createMany?: ChannelCreateManyMeetingInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type AdminUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<AdminCreateWithoutMeetingsInput, AdminUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutMeetingsInput
    upsert?: AdminUpsertWithoutMeetingsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutMeetingsInput, AdminUpdateWithoutMeetingsInput>, AdminUncheckedUpdateWithoutMeetingsInput>
  }

  export type AcademyUpdateOneRequiredWithoutMeetingNestedInput = {
    create?: XOR<AcademyCreateWithoutMeetingInput, AcademyUncheckedCreateWithoutMeetingInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutMeetingInput
    upsert?: AcademyUpsertWithoutMeetingInput
    connect?: AcademyWhereUniqueInput
    update?: XOR<XOR<AcademyUpdateToOneWithWhereWithoutMeetingInput, AcademyUpdateWithoutMeetingInput>, AcademyUncheckedUpdateWithoutMeetingInput>
  }

  export type MeetingParticipantUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<MeetingParticipantCreateWithoutMeetingInput, MeetingParticipantUncheckedCreateWithoutMeetingInput> | MeetingParticipantCreateWithoutMeetingInput[] | MeetingParticipantUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingParticipantCreateOrConnectWithoutMeetingInput | MeetingParticipantCreateOrConnectWithoutMeetingInput[]
    upsert?: MeetingParticipantUpsertWithWhereUniqueWithoutMeetingInput | MeetingParticipantUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: MeetingParticipantCreateManyMeetingInputEnvelope
    set?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    disconnect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    delete?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    connect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    update?: MeetingParticipantUpdateWithWhereUniqueWithoutMeetingInput | MeetingParticipantUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: MeetingParticipantUpdateManyWithWhereWithoutMeetingInput | MeetingParticipantUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: MeetingParticipantScalarWhereInput | MeetingParticipantScalarWhereInput[]
  }

  export type FileUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<FileCreateWithoutMeetingInput, FileUncheckedCreateWithoutMeetingInput> | FileCreateWithoutMeetingInput[] | FileUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMeetingInput | FileCreateOrConnectWithoutMeetingInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutMeetingInput | FileUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: FileCreateManyMeetingInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutMeetingInput | FileUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: FileUpdateManyWithWhereWithoutMeetingInput | FileUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<ReportCreateWithoutMeetingInput, ReportUncheckedCreateWithoutMeetingInput> | ReportCreateWithoutMeetingInput[] | ReportUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMeetingInput | ReportCreateOrConnectWithoutMeetingInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutMeetingInput | ReportUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: ReportCreateManyMeetingInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutMeetingInput | ReportUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutMeetingInput | ReportUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ChannelUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<ChannelCreateWithoutMeetingInput, ChannelUncheckedCreateWithoutMeetingInput> | ChannelCreateWithoutMeetingInput[] | ChannelUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMeetingInput | ChannelCreateOrConnectWithoutMeetingInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutMeetingInput | ChannelUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: ChannelCreateManyMeetingInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutMeetingInput | ChannelUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutMeetingInput | ChannelUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type MeetingParticipantUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<MeetingParticipantCreateWithoutMeetingInput, MeetingParticipantUncheckedCreateWithoutMeetingInput> | MeetingParticipantCreateWithoutMeetingInput[] | MeetingParticipantUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingParticipantCreateOrConnectWithoutMeetingInput | MeetingParticipantCreateOrConnectWithoutMeetingInput[]
    upsert?: MeetingParticipantUpsertWithWhereUniqueWithoutMeetingInput | MeetingParticipantUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: MeetingParticipantCreateManyMeetingInputEnvelope
    set?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    disconnect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    delete?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    connect?: MeetingParticipantWhereUniqueInput | MeetingParticipantWhereUniqueInput[]
    update?: MeetingParticipantUpdateWithWhereUniqueWithoutMeetingInput | MeetingParticipantUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: MeetingParticipantUpdateManyWithWhereWithoutMeetingInput | MeetingParticipantUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: MeetingParticipantScalarWhereInput | MeetingParticipantScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<FileCreateWithoutMeetingInput, FileUncheckedCreateWithoutMeetingInput> | FileCreateWithoutMeetingInput[] | FileUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: FileCreateOrConnectWithoutMeetingInput | FileCreateOrConnectWithoutMeetingInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutMeetingInput | FileUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: FileCreateManyMeetingInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutMeetingInput | FileUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: FileUpdateManyWithWhereWithoutMeetingInput | FileUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<ReportCreateWithoutMeetingInput, ReportUncheckedCreateWithoutMeetingInput> | ReportCreateWithoutMeetingInput[] | ReportUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMeetingInput | ReportCreateOrConnectWithoutMeetingInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutMeetingInput | ReportUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: ReportCreateManyMeetingInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutMeetingInput | ReportUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutMeetingInput | ReportUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<ChannelCreateWithoutMeetingInput, ChannelUncheckedCreateWithoutMeetingInput> | ChannelCreateWithoutMeetingInput[] | ChannelUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutMeetingInput | ChannelCreateOrConnectWithoutMeetingInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutMeetingInput | ChannelUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: ChannelCreateManyMeetingInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutMeetingInput | ChannelUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutMeetingInput | ChannelUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type MeetingCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<MeetingCreateWithoutParticipantsInput, MeetingUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutParticipantsInput
    connect?: MeetingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMeetingParticipantInput = {
    create?: XOR<UserCreateWithoutMeetingParticipantInput, UserUncheckedCreateWithoutMeetingParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingParticipantInput
    connect?: UserWhereUniqueInput
  }

  export type MeetingUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<MeetingCreateWithoutParticipantsInput, MeetingUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutParticipantsInput
    upsert?: MeetingUpsertWithoutParticipantsInput
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutParticipantsInput, MeetingUpdateWithoutParticipantsInput>, MeetingUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutMeetingParticipantNestedInput = {
    create?: XOR<UserCreateWithoutMeetingParticipantInput, UserUncheckedCreateWithoutMeetingParticipantInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingParticipantInput
    upsert?: UserUpsertWithoutMeetingParticipantInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMeetingParticipantInput, UserUpdateWithoutMeetingParticipantInput>, UserUncheckedUpdateWithoutMeetingParticipantInput>
  }

  export type AdminRoleCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput> | AdminRoleCreateWithoutPermissionsInput[] | AdminRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutPermissionsInput | AdminRoleCreateOrConnectWithoutPermissionsInput[]
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
  }

  export type AdminRoleUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput> | AdminRoleCreateWithoutPermissionsInput[] | AdminRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutPermissionsInput | AdminRoleCreateOrConnectWithoutPermissionsInput[]
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
  }

  export type AdminRoleUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput> | AdminRoleCreateWithoutPermissionsInput[] | AdminRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutPermissionsInput | AdminRoleCreateOrConnectWithoutPermissionsInput[]
    upsert?: AdminRoleUpsertWithWhereUniqueWithoutPermissionsInput | AdminRoleUpsertWithWhereUniqueWithoutPermissionsInput[]
    set?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    disconnect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    delete?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    update?: AdminRoleUpdateWithWhereUniqueWithoutPermissionsInput | AdminRoleUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: AdminRoleUpdateManyWithWhereWithoutPermissionsInput | AdminRoleUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: AdminRoleScalarWhereInput | AdminRoleScalarWhereInput[]
  }

  export type AdminRoleUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput> | AdminRoleCreateWithoutPermissionsInput[] | AdminRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: AdminRoleCreateOrConnectWithoutPermissionsInput | AdminRoleCreateOrConnectWithoutPermissionsInput[]
    upsert?: AdminRoleUpsertWithWhereUniqueWithoutPermissionsInput | AdminRoleUpsertWithWhereUniqueWithoutPermissionsInput[]
    set?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    disconnect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    delete?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    connect?: AdminRoleWhereUniqueInput | AdminRoleWhereUniqueInput[]
    update?: AdminRoleUpdateWithWhereUniqueWithoutPermissionsInput | AdminRoleUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: AdminRoleUpdateManyWithWhereWithoutPermissionsInput | AdminRoleUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: AdminRoleScalarWhereInput | AdminRoleScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutAdminRoleInput = {
    create?: XOR<AdminCreateWithoutAdminRoleInput, AdminUncheckedCreateWithoutAdminRoleInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAdminRoleInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminAssignmentCreateNestedManyWithoutRoleInput = {
    create?: XOR<AdminAssignmentCreateWithoutRoleInput, AdminAssignmentUncheckedCreateWithoutRoleInput> | AdminAssignmentCreateWithoutRoleInput[] | AdminAssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminAssignmentCreateOrConnectWithoutRoleInput | AdminAssignmentCreateOrConnectWithoutRoleInput[]
    createMany?: AdminAssignmentCreateManyRoleInputEnvelope
    connect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
  }

  export type PermissionCreateNestedManyWithoutAdminRoleInput = {
    create?: XOR<PermissionCreateWithoutAdminRoleInput, PermissionUncheckedCreateWithoutAdminRoleInput> | PermissionCreateWithoutAdminRoleInput[] | PermissionUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutAdminRoleInput | PermissionCreateOrConnectWithoutAdminRoleInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutAdminRoleInput = {
    create?: XOR<ReportCreateWithoutAdminRoleInput, ReportUncheckedCreateWithoutAdminRoleInput> | ReportCreateWithoutAdminRoleInput[] | ReportUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAdminRoleInput | ReportCreateOrConnectWithoutAdminRoleInput[]
    createMany?: ReportCreateManyAdminRoleInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutAdminRoleInput = {
    create?: XOR<FileCreateWithoutAdminRoleInput, FileUncheckedCreateWithoutAdminRoleInput> | FileCreateWithoutAdminRoleInput[] | FileUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAdminRoleInput | FileCreateOrConnectWithoutAdminRoleInput[]
    createMany?: FileCreateManyAdminRoleInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutAdminRoleInput = {
    create?: XOR<EventCreateWithoutAdminRoleInput, EventUncheckedCreateWithoutAdminRoleInput> | EventCreateWithoutAdminRoleInput[] | EventUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAdminRoleInput | EventCreateOrConnectWithoutAdminRoleInput[]
    createMany?: EventCreateManyAdminRoleInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChannelCreateNestedManyWithoutAdminRoleInput = {
    create?: XOR<ChannelCreateWithoutAdminRoleInput, ChannelUncheckedCreateWithoutAdminRoleInput> | ChannelCreateWithoutAdminRoleInput[] | ChannelUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutAdminRoleInput | ChannelCreateOrConnectWithoutAdminRoleInput[]
    createMany?: ChannelCreateManyAdminRoleInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type AdminAssignmentUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<AdminAssignmentCreateWithoutRoleInput, AdminAssignmentUncheckedCreateWithoutRoleInput> | AdminAssignmentCreateWithoutRoleInput[] | AdminAssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminAssignmentCreateOrConnectWithoutRoleInput | AdminAssignmentCreateOrConnectWithoutRoleInput[]
    createMany?: AdminAssignmentCreateManyRoleInputEnvelope
    connect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutAdminRoleInput = {
    create?: XOR<PermissionCreateWithoutAdminRoleInput, PermissionUncheckedCreateWithoutAdminRoleInput> | PermissionCreateWithoutAdminRoleInput[] | PermissionUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutAdminRoleInput | PermissionCreateOrConnectWithoutAdminRoleInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutAdminRoleInput = {
    create?: XOR<ReportCreateWithoutAdminRoleInput, ReportUncheckedCreateWithoutAdminRoleInput> | ReportCreateWithoutAdminRoleInput[] | ReportUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAdminRoleInput | ReportCreateOrConnectWithoutAdminRoleInput[]
    createMany?: ReportCreateManyAdminRoleInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutAdminRoleInput = {
    create?: XOR<FileCreateWithoutAdminRoleInput, FileUncheckedCreateWithoutAdminRoleInput> | FileCreateWithoutAdminRoleInput[] | FileUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAdminRoleInput | FileCreateOrConnectWithoutAdminRoleInput[]
    createMany?: FileCreateManyAdminRoleInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutAdminRoleInput = {
    create?: XOR<EventCreateWithoutAdminRoleInput, EventUncheckedCreateWithoutAdminRoleInput> | EventCreateWithoutAdminRoleInput[] | EventUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAdminRoleInput | EventCreateOrConnectWithoutAdminRoleInput[]
    createMany?: EventCreateManyAdminRoleInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutAdminRoleInput = {
    create?: XOR<ChannelCreateWithoutAdminRoleInput, ChannelUncheckedCreateWithoutAdminRoleInput> | ChannelCreateWithoutAdminRoleInput[] | ChannelUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutAdminRoleInput | ChannelCreateOrConnectWithoutAdminRoleInput[]
    createMany?: ChannelCreateManyAdminRoleInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type EnumAdminRoleTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdminRoleType
  }

  export type AdminUpdateOneRequiredWithoutAdminRoleNestedInput = {
    create?: XOR<AdminCreateWithoutAdminRoleInput, AdminUncheckedCreateWithoutAdminRoleInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAdminRoleInput
    upsert?: AdminUpsertWithoutAdminRoleInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAdminRoleInput, AdminUpdateWithoutAdminRoleInput>, AdminUncheckedUpdateWithoutAdminRoleInput>
  }

  export type AdminAssignmentUpdateManyWithoutRoleNestedInput = {
    create?: XOR<AdminAssignmentCreateWithoutRoleInput, AdminAssignmentUncheckedCreateWithoutRoleInput> | AdminAssignmentCreateWithoutRoleInput[] | AdminAssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminAssignmentCreateOrConnectWithoutRoleInput | AdminAssignmentCreateOrConnectWithoutRoleInput[]
    upsert?: AdminAssignmentUpsertWithWhereUniqueWithoutRoleInput | AdminAssignmentUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: AdminAssignmentCreateManyRoleInputEnvelope
    set?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    disconnect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    delete?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    connect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    update?: AdminAssignmentUpdateWithWhereUniqueWithoutRoleInput | AdminAssignmentUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: AdminAssignmentUpdateManyWithWhereWithoutRoleInput | AdminAssignmentUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: AdminAssignmentScalarWhereInput | AdminAssignmentScalarWhereInput[]
  }

  export type PermissionUpdateManyWithoutAdminRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutAdminRoleInput, PermissionUncheckedCreateWithoutAdminRoleInput> | PermissionCreateWithoutAdminRoleInput[] | PermissionUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutAdminRoleInput | PermissionCreateOrConnectWithoutAdminRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutAdminRoleInput | PermissionUpsertWithWhereUniqueWithoutAdminRoleInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutAdminRoleInput | PermissionUpdateWithWhereUniqueWithoutAdminRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutAdminRoleInput | PermissionUpdateManyWithWhereWithoutAdminRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutAdminRoleNestedInput = {
    create?: XOR<ReportCreateWithoutAdminRoleInput, ReportUncheckedCreateWithoutAdminRoleInput> | ReportCreateWithoutAdminRoleInput[] | ReportUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAdminRoleInput | ReportCreateOrConnectWithoutAdminRoleInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAdminRoleInput | ReportUpsertWithWhereUniqueWithoutAdminRoleInput[]
    createMany?: ReportCreateManyAdminRoleInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAdminRoleInput | ReportUpdateWithWhereUniqueWithoutAdminRoleInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAdminRoleInput | ReportUpdateManyWithWhereWithoutAdminRoleInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type FileUpdateManyWithoutAdminRoleNestedInput = {
    create?: XOR<FileCreateWithoutAdminRoleInput, FileUncheckedCreateWithoutAdminRoleInput> | FileCreateWithoutAdminRoleInput[] | FileUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAdminRoleInput | FileCreateOrConnectWithoutAdminRoleInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutAdminRoleInput | FileUpsertWithWhereUniqueWithoutAdminRoleInput[]
    createMany?: FileCreateManyAdminRoleInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutAdminRoleInput | FileUpdateWithWhereUniqueWithoutAdminRoleInput[]
    updateMany?: FileUpdateManyWithWhereWithoutAdminRoleInput | FileUpdateManyWithWhereWithoutAdminRoleInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type EventUpdateManyWithoutAdminRoleNestedInput = {
    create?: XOR<EventCreateWithoutAdminRoleInput, EventUncheckedCreateWithoutAdminRoleInput> | EventCreateWithoutAdminRoleInput[] | EventUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAdminRoleInput | EventCreateOrConnectWithoutAdminRoleInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutAdminRoleInput | EventUpsertWithWhereUniqueWithoutAdminRoleInput[]
    createMany?: EventCreateManyAdminRoleInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutAdminRoleInput | EventUpdateWithWhereUniqueWithoutAdminRoleInput[]
    updateMany?: EventUpdateManyWithWhereWithoutAdminRoleInput | EventUpdateManyWithWhereWithoutAdminRoleInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChannelUpdateManyWithoutAdminRoleNestedInput = {
    create?: XOR<ChannelCreateWithoutAdminRoleInput, ChannelUncheckedCreateWithoutAdminRoleInput> | ChannelCreateWithoutAdminRoleInput[] | ChannelUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutAdminRoleInput | ChannelCreateOrConnectWithoutAdminRoleInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutAdminRoleInput | ChannelUpsertWithWhereUniqueWithoutAdminRoleInput[]
    createMany?: ChannelCreateManyAdminRoleInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutAdminRoleInput | ChannelUpdateWithWhereUniqueWithoutAdminRoleInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutAdminRoleInput | ChannelUpdateManyWithWhereWithoutAdminRoleInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type AdminAssignmentUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<AdminAssignmentCreateWithoutRoleInput, AdminAssignmentUncheckedCreateWithoutRoleInput> | AdminAssignmentCreateWithoutRoleInput[] | AdminAssignmentUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: AdminAssignmentCreateOrConnectWithoutRoleInput | AdminAssignmentCreateOrConnectWithoutRoleInput[]
    upsert?: AdminAssignmentUpsertWithWhereUniqueWithoutRoleInput | AdminAssignmentUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: AdminAssignmentCreateManyRoleInputEnvelope
    set?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    disconnect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    delete?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    connect?: AdminAssignmentWhereUniqueInput | AdminAssignmentWhereUniqueInput[]
    update?: AdminAssignmentUpdateWithWhereUniqueWithoutRoleInput | AdminAssignmentUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: AdminAssignmentUpdateManyWithWhereWithoutRoleInput | AdminAssignmentUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: AdminAssignmentScalarWhereInput | AdminAssignmentScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutAdminRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutAdminRoleInput, PermissionUncheckedCreateWithoutAdminRoleInput> | PermissionCreateWithoutAdminRoleInput[] | PermissionUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutAdminRoleInput | PermissionCreateOrConnectWithoutAdminRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutAdminRoleInput | PermissionUpsertWithWhereUniqueWithoutAdminRoleInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutAdminRoleInput | PermissionUpdateWithWhereUniqueWithoutAdminRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutAdminRoleInput | PermissionUpdateManyWithWhereWithoutAdminRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutAdminRoleNestedInput = {
    create?: XOR<ReportCreateWithoutAdminRoleInput, ReportUncheckedCreateWithoutAdminRoleInput> | ReportCreateWithoutAdminRoleInput[] | ReportUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAdminRoleInput | ReportCreateOrConnectWithoutAdminRoleInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAdminRoleInput | ReportUpsertWithWhereUniqueWithoutAdminRoleInput[]
    createMany?: ReportCreateManyAdminRoleInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAdminRoleInput | ReportUpdateWithWhereUniqueWithoutAdminRoleInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAdminRoleInput | ReportUpdateManyWithWhereWithoutAdminRoleInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutAdminRoleNestedInput = {
    create?: XOR<FileCreateWithoutAdminRoleInput, FileUncheckedCreateWithoutAdminRoleInput> | FileCreateWithoutAdminRoleInput[] | FileUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: FileCreateOrConnectWithoutAdminRoleInput | FileCreateOrConnectWithoutAdminRoleInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutAdminRoleInput | FileUpsertWithWhereUniqueWithoutAdminRoleInput[]
    createMany?: FileCreateManyAdminRoleInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutAdminRoleInput | FileUpdateWithWhereUniqueWithoutAdminRoleInput[]
    updateMany?: FileUpdateManyWithWhereWithoutAdminRoleInput | FileUpdateManyWithWhereWithoutAdminRoleInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutAdminRoleNestedInput = {
    create?: XOR<EventCreateWithoutAdminRoleInput, EventUncheckedCreateWithoutAdminRoleInput> | EventCreateWithoutAdminRoleInput[] | EventUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: EventCreateOrConnectWithoutAdminRoleInput | EventCreateOrConnectWithoutAdminRoleInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutAdminRoleInput | EventUpsertWithWhereUniqueWithoutAdminRoleInput[]
    createMany?: EventCreateManyAdminRoleInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutAdminRoleInput | EventUpdateWithWhereUniqueWithoutAdminRoleInput[]
    updateMany?: EventUpdateManyWithWhereWithoutAdminRoleInput | EventUpdateManyWithWhereWithoutAdminRoleInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutAdminRoleNestedInput = {
    create?: XOR<ChannelCreateWithoutAdminRoleInput, ChannelUncheckedCreateWithoutAdminRoleInput> | ChannelCreateWithoutAdminRoleInput[] | ChannelUncheckedCreateWithoutAdminRoleInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutAdminRoleInput | ChannelCreateOrConnectWithoutAdminRoleInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutAdminRoleInput | ChannelUpsertWithWhereUniqueWithoutAdminRoleInput[]
    createMany?: ChannelCreateManyAdminRoleInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutAdminRoleInput | ChannelUpdateWithWhereUniqueWithoutAdminRoleInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutAdminRoleInput | ChannelUpdateManyWithWhereWithoutAdminRoleInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<AdminCreateWithoutAssignmentsInput, AdminUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAssignmentsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminRoleCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<AdminRoleCreateWithoutAssignmentsInput, AdminRoleUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutAssignmentsInput
    connect?: AdminRoleWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AdminUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<AdminCreateWithoutAssignmentsInput, AdminUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutAssignmentsInput
    upsert?: AdminUpsertWithoutAssignmentsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutAssignmentsInput, AdminUpdateWithoutAssignmentsInput>, AdminUncheckedUpdateWithoutAssignmentsInput>
  }

  export type AdminRoleUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<AdminRoleCreateWithoutAssignmentsInput, AdminRoleUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: AdminRoleCreateOrConnectWithoutAssignmentsInput
    upsert?: AdminRoleUpsertWithoutAssignmentsInput
    connect?: AdminRoleWhereUniqueInput
    update?: XOR<XOR<AdminRoleUpdateToOneWithWhereWithoutAssignmentsInput, AdminRoleUpdateWithoutAssignmentsInput>, AdminRoleUncheckedUpdateWithoutAssignmentsInput>
  }

  export type AdminCreateNestedOneWithoutLegalCasesInput = {
    create?: XOR<AdminCreateWithoutLegalCasesInput, AdminUncheckedCreateWithoutLegalCasesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutLegalCasesInput
    connect?: AdminWhereUniqueInput
  }

  export type AcademyCreateNestedOneWithoutLegalCaseInput = {
    create?: XOR<AcademyCreateWithoutLegalCaseInput, AcademyUncheckedCreateWithoutLegalCaseInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutLegalCaseInput
    connect?: AcademyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLegalCaseInput = {
    create?: XOR<UserCreateWithoutLegalCaseInput, UserUncheckedCreateWithoutLegalCaseInput>
    connectOrCreate?: UserCreateOrConnectWithoutLegalCaseInput
    connect?: UserWhereUniqueInput
  }

  export type FileCreateNestedManyWithoutLegalCaseInput = {
    create?: XOR<FileCreateWithoutLegalCaseInput, FileUncheckedCreateWithoutLegalCaseInput> | FileCreateWithoutLegalCaseInput[] | FileUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLegalCaseInput | FileCreateOrConnectWithoutLegalCaseInput[]
    createMany?: FileCreateManyLegalCaseInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutLegalCaseInput = {
    create?: XOR<ReportCreateWithoutLegalCaseInput, ReportUncheckedCreateWithoutLegalCaseInput> | ReportCreateWithoutLegalCaseInput[] | ReportUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutLegalCaseInput | ReportCreateOrConnectWithoutLegalCaseInput[]
    createMany?: ReportCreateManyLegalCaseInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutLegalCaseInput = {
    create?: XOR<EventCreateWithoutLegalCaseInput, EventUncheckedCreateWithoutLegalCaseInput> | EventCreateWithoutLegalCaseInput[] | EventUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLegalCaseInput | EventCreateOrConnectWithoutLegalCaseInput[]
    createMany?: EventCreateManyLegalCaseInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChannelCreateNestedManyWithoutLegalCaseInput = {
    create?: XOR<ChannelCreateWithoutLegalCaseInput, ChannelUncheckedCreateWithoutLegalCaseInput> | ChannelCreateWithoutLegalCaseInput[] | ChannelUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutLegalCaseInput | ChannelCreateOrConnectWithoutLegalCaseInput[]
    createMany?: ChannelCreateManyLegalCaseInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutLegalCaseInput = {
    create?: XOR<PaymentCreateWithoutLegalCaseInput, PaymentUncheckedCreateWithoutLegalCaseInput> | PaymentCreateWithoutLegalCaseInput[] | PaymentUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLegalCaseInput | PaymentCreateOrConnectWithoutLegalCaseInput[]
    createMany?: PaymentCreateManyLegalCaseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutLegalCaseInput = {
    create?: XOR<FileCreateWithoutLegalCaseInput, FileUncheckedCreateWithoutLegalCaseInput> | FileCreateWithoutLegalCaseInput[] | FileUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLegalCaseInput | FileCreateOrConnectWithoutLegalCaseInput[]
    createMany?: FileCreateManyLegalCaseInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutLegalCaseInput = {
    create?: XOR<ReportCreateWithoutLegalCaseInput, ReportUncheckedCreateWithoutLegalCaseInput> | ReportCreateWithoutLegalCaseInput[] | ReportUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutLegalCaseInput | ReportCreateOrConnectWithoutLegalCaseInput[]
    createMany?: ReportCreateManyLegalCaseInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutLegalCaseInput = {
    create?: XOR<EventCreateWithoutLegalCaseInput, EventUncheckedCreateWithoutLegalCaseInput> | EventCreateWithoutLegalCaseInput[] | EventUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLegalCaseInput | EventCreateOrConnectWithoutLegalCaseInput[]
    createMany?: EventCreateManyLegalCaseInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChannelUncheckedCreateNestedManyWithoutLegalCaseInput = {
    create?: XOR<ChannelCreateWithoutLegalCaseInput, ChannelUncheckedCreateWithoutLegalCaseInput> | ChannelCreateWithoutLegalCaseInput[] | ChannelUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutLegalCaseInput | ChannelCreateOrConnectWithoutLegalCaseInput[]
    createMany?: ChannelCreateManyLegalCaseInputEnvelope
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutLegalCaseInput = {
    create?: XOR<PaymentCreateWithoutLegalCaseInput, PaymentUncheckedCreateWithoutLegalCaseInput> | PaymentCreateWithoutLegalCaseInput[] | PaymentUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLegalCaseInput | PaymentCreateOrConnectWithoutLegalCaseInput[]
    createMany?: PaymentCreateManyLegalCaseInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumLegalCaseTypeFieldUpdateOperationsInput = {
    set?: $Enums.LegalCaseType
  }

  export type EnumLegalCaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.LegalCaseStatus
  }

  export type AdminUpdateOneRequiredWithoutLegalCasesNestedInput = {
    create?: XOR<AdminCreateWithoutLegalCasesInput, AdminUncheckedCreateWithoutLegalCasesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutLegalCasesInput
    upsert?: AdminUpsertWithoutLegalCasesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutLegalCasesInput, AdminUpdateWithoutLegalCasesInput>, AdminUncheckedUpdateWithoutLegalCasesInput>
  }

  export type AcademyUpdateOneRequiredWithoutLegalCaseNestedInput = {
    create?: XOR<AcademyCreateWithoutLegalCaseInput, AcademyUncheckedCreateWithoutLegalCaseInput>
    connectOrCreate?: AcademyCreateOrConnectWithoutLegalCaseInput
    upsert?: AcademyUpsertWithoutLegalCaseInput
    connect?: AcademyWhereUniqueInput
    update?: XOR<XOR<AcademyUpdateToOneWithWhereWithoutLegalCaseInput, AcademyUpdateWithoutLegalCaseInput>, AcademyUncheckedUpdateWithoutLegalCaseInput>
  }

  export type UserUpdateOneWithoutLegalCaseNestedInput = {
    create?: XOR<UserCreateWithoutLegalCaseInput, UserUncheckedCreateWithoutLegalCaseInput>
    connectOrCreate?: UserCreateOrConnectWithoutLegalCaseInput
    upsert?: UserUpsertWithoutLegalCaseInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLegalCaseInput, UserUpdateWithoutLegalCaseInput>, UserUncheckedUpdateWithoutLegalCaseInput>
  }

  export type FileUpdateManyWithoutLegalCaseNestedInput = {
    create?: XOR<FileCreateWithoutLegalCaseInput, FileUncheckedCreateWithoutLegalCaseInput> | FileCreateWithoutLegalCaseInput[] | FileUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLegalCaseInput | FileCreateOrConnectWithoutLegalCaseInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutLegalCaseInput | FileUpsertWithWhereUniqueWithoutLegalCaseInput[]
    createMany?: FileCreateManyLegalCaseInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutLegalCaseInput | FileUpdateWithWhereUniqueWithoutLegalCaseInput[]
    updateMany?: FileUpdateManyWithWhereWithoutLegalCaseInput | FileUpdateManyWithWhereWithoutLegalCaseInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutLegalCaseNestedInput = {
    create?: XOR<ReportCreateWithoutLegalCaseInput, ReportUncheckedCreateWithoutLegalCaseInput> | ReportCreateWithoutLegalCaseInput[] | ReportUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutLegalCaseInput | ReportCreateOrConnectWithoutLegalCaseInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutLegalCaseInput | ReportUpsertWithWhereUniqueWithoutLegalCaseInput[]
    createMany?: ReportCreateManyLegalCaseInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutLegalCaseInput | ReportUpdateWithWhereUniqueWithoutLegalCaseInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutLegalCaseInput | ReportUpdateManyWithWhereWithoutLegalCaseInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type EventUpdateManyWithoutLegalCaseNestedInput = {
    create?: XOR<EventCreateWithoutLegalCaseInput, EventUncheckedCreateWithoutLegalCaseInput> | EventCreateWithoutLegalCaseInput[] | EventUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLegalCaseInput | EventCreateOrConnectWithoutLegalCaseInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutLegalCaseInput | EventUpsertWithWhereUniqueWithoutLegalCaseInput[]
    createMany?: EventCreateManyLegalCaseInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutLegalCaseInput | EventUpdateWithWhereUniqueWithoutLegalCaseInput[]
    updateMany?: EventUpdateManyWithWhereWithoutLegalCaseInput | EventUpdateManyWithWhereWithoutLegalCaseInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChannelUpdateManyWithoutLegalCaseNestedInput = {
    create?: XOR<ChannelCreateWithoutLegalCaseInput, ChannelUncheckedCreateWithoutLegalCaseInput> | ChannelCreateWithoutLegalCaseInput[] | ChannelUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutLegalCaseInput | ChannelCreateOrConnectWithoutLegalCaseInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutLegalCaseInput | ChannelUpsertWithWhereUniqueWithoutLegalCaseInput[]
    createMany?: ChannelCreateManyLegalCaseInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutLegalCaseInput | ChannelUpdateWithWhereUniqueWithoutLegalCaseInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutLegalCaseInput | ChannelUpdateManyWithWhereWithoutLegalCaseInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutLegalCaseNestedInput = {
    create?: XOR<PaymentCreateWithoutLegalCaseInput, PaymentUncheckedCreateWithoutLegalCaseInput> | PaymentCreateWithoutLegalCaseInput[] | PaymentUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLegalCaseInput | PaymentCreateOrConnectWithoutLegalCaseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutLegalCaseInput | PaymentUpsertWithWhereUniqueWithoutLegalCaseInput[]
    createMany?: PaymentCreateManyLegalCaseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutLegalCaseInput | PaymentUpdateWithWhereUniqueWithoutLegalCaseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutLegalCaseInput | PaymentUpdateManyWithWhereWithoutLegalCaseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutLegalCaseNestedInput = {
    create?: XOR<FileCreateWithoutLegalCaseInput, FileUncheckedCreateWithoutLegalCaseInput> | FileCreateWithoutLegalCaseInput[] | FileUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: FileCreateOrConnectWithoutLegalCaseInput | FileCreateOrConnectWithoutLegalCaseInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutLegalCaseInput | FileUpsertWithWhereUniqueWithoutLegalCaseInput[]
    createMany?: FileCreateManyLegalCaseInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutLegalCaseInput | FileUpdateWithWhereUniqueWithoutLegalCaseInput[]
    updateMany?: FileUpdateManyWithWhereWithoutLegalCaseInput | FileUpdateManyWithWhereWithoutLegalCaseInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutLegalCaseNestedInput = {
    create?: XOR<ReportCreateWithoutLegalCaseInput, ReportUncheckedCreateWithoutLegalCaseInput> | ReportCreateWithoutLegalCaseInput[] | ReportUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutLegalCaseInput | ReportCreateOrConnectWithoutLegalCaseInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutLegalCaseInput | ReportUpsertWithWhereUniqueWithoutLegalCaseInput[]
    createMany?: ReportCreateManyLegalCaseInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutLegalCaseInput | ReportUpdateWithWhereUniqueWithoutLegalCaseInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutLegalCaseInput | ReportUpdateManyWithWhereWithoutLegalCaseInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutLegalCaseNestedInput = {
    create?: XOR<EventCreateWithoutLegalCaseInput, EventUncheckedCreateWithoutLegalCaseInput> | EventCreateWithoutLegalCaseInput[] | EventUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLegalCaseInput | EventCreateOrConnectWithoutLegalCaseInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutLegalCaseInput | EventUpsertWithWhereUniqueWithoutLegalCaseInput[]
    createMany?: EventCreateManyLegalCaseInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutLegalCaseInput | EventUpdateWithWhereUniqueWithoutLegalCaseInput[]
    updateMany?: EventUpdateManyWithWhereWithoutLegalCaseInput | EventUpdateManyWithWhereWithoutLegalCaseInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChannelUncheckedUpdateManyWithoutLegalCaseNestedInput = {
    create?: XOR<ChannelCreateWithoutLegalCaseInput, ChannelUncheckedCreateWithoutLegalCaseInput> | ChannelCreateWithoutLegalCaseInput[] | ChannelUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: ChannelCreateOrConnectWithoutLegalCaseInput | ChannelCreateOrConnectWithoutLegalCaseInput[]
    upsert?: ChannelUpsertWithWhereUniqueWithoutLegalCaseInput | ChannelUpsertWithWhereUniqueWithoutLegalCaseInput[]
    createMany?: ChannelCreateManyLegalCaseInputEnvelope
    set?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    disconnect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    delete?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    connect?: ChannelWhereUniqueInput | ChannelWhereUniqueInput[]
    update?: ChannelUpdateWithWhereUniqueWithoutLegalCaseInput | ChannelUpdateWithWhereUniqueWithoutLegalCaseInput[]
    updateMany?: ChannelUpdateManyWithWhereWithoutLegalCaseInput | ChannelUpdateManyWithWhereWithoutLegalCaseInput[]
    deleteMany?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutLegalCaseNestedInput = {
    create?: XOR<PaymentCreateWithoutLegalCaseInput, PaymentUncheckedCreateWithoutLegalCaseInput> | PaymentCreateWithoutLegalCaseInput[] | PaymentUncheckedCreateWithoutLegalCaseInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLegalCaseInput | PaymentCreateOrConnectWithoutLegalCaseInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutLegalCaseInput | PaymentUpsertWithWhereUniqueWithoutLegalCaseInput[]
    createMany?: PaymentCreateManyLegalCaseInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutLegalCaseInput | PaymentUpdateWithWhereUniqueWithoutLegalCaseInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutLegalCaseInput | PaymentUpdateManyWithWhereWithoutLegalCaseInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLoginDeviceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginDevice | EnumLoginDeviceFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoginDevice[] | ListEnumLoginDeviceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoginDevice[] | ListEnumLoginDeviceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoginDeviceNullableFilter<$PrismaModel> | $Enums.LoginDevice | null
  }

  export type NestedEnumLoginDeviceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoginDevice | EnumLoginDeviceFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoginDevice[] | ListEnumLoginDeviceFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoginDevice[] | ListEnumLoginDeviceFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoginDeviceNullableWithAggregatesFilter<$PrismaModel> | $Enums.LoginDevice | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLoginDeviceNullableFilter<$PrismaModel>
    _max?: NestedEnumLoginDeviceNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCourseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusFilter<$PrismaModel> | $Enums.CourseStatus
  }

  export type NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseStatus | EnumCourseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseStatus[] | ListEnumCourseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseStatusFilter<$PrismaModel>
    _max?: NestedEnumCourseStatusFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumMilestoneStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusFilter<$PrismaModel> | $Enums.MilestoneStatus
  }

  export type NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MilestoneStatus | EnumMilestoneStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MilestoneStatus[] | ListEnumMilestoneStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMilestoneStatusWithAggregatesFilter<$PrismaModel> | $Enums.MilestoneStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMilestoneStatusFilter<$PrismaModel>
    _max?: NestedEnumMilestoneStatusFilter<$PrismaModel>
  }

  export type NestedEnumLessonStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusFilter<$PrismaModel> | $Enums.LessonStatus
  }

  export type NestedEnumLessonStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusWithAggregatesFilter<$PrismaModel> | $Enums.LessonStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonStatusFilter<$PrismaModel>
    _max?: NestedEnumLessonStatusFilter<$PrismaModel>
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumAccountingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingType | EnumAccountingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingType[] | ListEnumAccountingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingType[] | ListEnumAccountingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingTypeFilter<$PrismaModel> | $Enums.AccountingType
  }

  export type NestedEnumAccountingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountingType | EnumAccountingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountingType[] | ListEnumAccountingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountingType[] | ListEnumAccountingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountingTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountingTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountingTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPRRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PRRequestStatus | EnumPRRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PRRequestStatus[] | ListEnumPRRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PRRequestStatus[] | ListEnumPRRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPRRequestStatusFilter<$PrismaModel> | $Enums.PRRequestStatus
  }

  export type NestedEnumPRRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PRRequestStatus | EnumPRRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PRRequestStatus[] | ListEnumPRRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PRRequestStatus[] | ListEnumPRRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPRRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.PRRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPRRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumPRRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdminRoleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRoleType | EnumAdminRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRoleType[] | ListEnumAdminRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRoleType[] | ListEnumAdminRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleTypeFilter<$PrismaModel> | $Enums.AdminRoleType
  }

  export type NestedEnumAdminRoleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRoleType | EnumAdminRoleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRoleType[] | ListEnumAdminRoleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRoleType[] | ListEnumAdminRoleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdminRoleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleTypeFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLegalCaseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalCaseType | EnumLegalCaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalCaseType[] | ListEnumLegalCaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalCaseType[] | ListEnumLegalCaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalCaseTypeFilter<$PrismaModel> | $Enums.LegalCaseType
  }

  export type NestedEnumLegalCaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalCaseStatus | EnumLegalCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LegalCaseStatus[] | ListEnumLegalCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalCaseStatus[] | ListEnumLegalCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalCaseStatusFilter<$PrismaModel> | $Enums.LegalCaseStatus
  }

  export type NestedEnumLegalCaseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalCaseType | EnumLegalCaseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LegalCaseType[] | ListEnumLegalCaseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalCaseType[] | ListEnumLegalCaseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalCaseTypeWithAggregatesFilter<$PrismaModel> | $Enums.LegalCaseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLegalCaseTypeFilter<$PrismaModel>
    _max?: NestedEnumLegalCaseTypeFilter<$PrismaModel>
  }

  export type NestedEnumLegalCaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LegalCaseStatus | EnumLegalCaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LegalCaseStatus[] | ListEnumLegalCaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LegalCaseStatus[] | ListEnumLegalCaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLegalCaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.LegalCaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLegalCaseStatusFilter<$PrismaModel>
    _max?: NestedEnumLegalCaseStatusFilter<$PrismaModel>
  }

  export type AcademyCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ceos?: UserAcademyCEOCreateNestedManyWithoutAcademyInput
    courses?: CourseCreateNestedManyWithoutAcademyInput
    instructors?: InstructorCreateNestedManyWithoutAcademyInput
    events?: EventCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ceos?: UserAcademyCEOUncheckedCreateNestedManyWithoutAcademyInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademyInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutAcademyInput
    events?: EventUncheckedCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryUncheckedCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutAcademyInput
  }

  export type AcademyCreateOrConnectWithoutUsersInput = {
    where: AcademyWhereUniqueInput
    create: XOR<AcademyCreateWithoutUsersInput, AcademyUncheckedCreateWithoutUsersInput>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    phone?: string | null
    address?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    phone?: string | null
    address?: string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentCreateWithoutUserInput = {
    id?: string
    progress?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    progress?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentCreateManyUserInputEnvelope = {
    data: EnrollmentCreateManyUserInput | EnrollmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AchievementCreateWithoutUserInput = {
    id?: string
    type: string
    value: JsonNullValueInput | InputJsonValue
    isNew?: boolean
    createdAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    value: JsonNullValueInput | InputJsonValue
    isNew?: boolean
    createdAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUserInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementCreateManyUserInputEnvelope = {
    data: AchievementCreateManyUserInput | AchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type?: $Enums.NotificationType
    message: string
    isImportant?: boolean
    urgent?: boolean
    title: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type?: $Enums.NotificationType
    message: string
    isImportant?: boolean
    urgent?: boolean
    title: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    Channel?: ChannelCreateNestedManyWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    Channel?: ChannelUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    comments?: CommentCreateNestedManyWithoutPostInput
    Group?: GroupCreateNestedManyWithoutPostsInput
    Community?: CommunityCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionCreateNestedManyWithoutPostInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    publicRelationsRecordId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    Group?: GroupUncheckedCreateNestedManyWithoutPostsInput
    Community?: CommunityUncheckedCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutMembersInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    createdAt?: Date | string
    posts?: PostCreateNestedManyWithoutGroupInput
    admin: AdminCreateNestedOneWithoutGroupInput
    Community?: CommunityCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    adminId: string
    createdAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutGroupInput
    Community?: CommunityUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupCreateOrConnectWithoutMembersInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type ChannelCreateWithoutMembersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    owner: OwnerCreateNestedOneWithoutChannelInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutChannelsInput
    meeting?: MeetingCreateNestedOneWithoutChannelsInput
    adminRole?: AdminRoleCreateNestedOneWithoutChannelsInput
    legalCase?: LegalCaseCreateNestedOneWithoutChannelsInput
  }

  export type ChannelUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    ownerId: string
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutMembersInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput>
  }

  export type BookmarkCreateWithoutUserInput = {
    id?: string
    type: string
    itemId: string
    createdAt?: Date | string
  }

  export type BookmarkUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    itemId: string
    createdAt?: Date | string
  }

  export type BookmarkCreateOrConnectWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    create: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput>
  }

  export type BookmarkCreateManyUserInputEnvelope = {
    data: BookmarkCreateManyUserInput | BookmarkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionCreateWithoutUserInput = {
    id?: string
    answers?: SubmissionCreateanswersInput | InputJsonValue[]
    score?: number | null
    feedback?: string | null
    passed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz: QuizCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateWithoutUserInput = {
    id?: string
    quizId: string
    answers?: SubmissionCreateanswersInput | InputJsonValue[]
    score?: number | null
    feedback?: string | null
    passed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubmissionCreateOrConnectWithoutUserInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput>
  }

  export type SubmissionCreateManyUserInputEnvelope = {
    data: SubmissionCreateManyUserInput | SubmissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutStudentInput = {
    id?: string
    status: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutStudentInput = {
    id?: string
    lessonId: string
    status: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceCreateManyStudentInputEnvelope = {
    data: AttendanceCreateManyStudentInput | AttendanceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type InstructorCreateWithoutUserInput = {
    id?: string
    academy: AcademyCreateNestedOneWithoutInstructorsInput
    courses?: CourseCreateNestedManyWithoutInstructorsInput
  }

  export type InstructorUncheckedCreateWithoutUserInput = {
    id?: string
    academyId: string
    courses?: CourseUncheckedCreateNestedManyWithoutInstructorsInput
  }

  export type InstructorCreateOrConnectWithoutUserInput = {
    where: InstructorWhereUniqueInput
    create: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput>
  }

  export type InstructorCreateManyUserInputEnvelope = {
    data: InstructorCreateManyUserInput | InstructorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OwnerCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    Channel?: ChannelCreateNestedManyWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    Channel?: ChannelUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type OwnerCreateOrConnectWithoutUserInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutUserInput, OwnerUncheckedCreateWithoutUserInput>
  }

  export type OwnerCreateManyUserInputEnvelope = {
    data: OwnerCreateManyUserInput | OwnerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    Group?: GroupCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    Group?: GroupUncheckedCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordUncheckedCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseUncheckedCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseUncheckedCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateManyUserInputEnvelope = {
    data: AdminCreateManyUserInput | AdminCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutCompletedByInput = {
    id?: string
    title: string
    content: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutLessonsInput
    files?: FileCreateNestedManyWithoutLessonInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    Attendance?: AttendanceCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutCompletedByInput = {
    id?: string
    title: string
    content: string
    courseId: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLessonInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCompletedByInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCompletedByInput, LessonUncheckedCreateWithoutCompletedByInput>
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    legalCase?: LegalCaseCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    accountingEntry?: AccountingEntryCreateNestedOneWithoutReportsInput
    meeting?: MeetingCreateNestedOneWithoutReportsInput
    adminRole?: AdminRoleCreateNestedOneWithoutReportsInput
    legalCase?: LegalCaseCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutUserInput = {
    id?: string
    accountingEntryId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutUserInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
  }

  export type ReportCreateManyUserInputEnvelope = {
    data: ReportCreateManyUserInput | ReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BadgeCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
  }

  export type BadgeUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutUserInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput>
  }

  export type BadgeCreateManyUserInputEnvelope = {
    data: BadgeCreateManyUserInput | BadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutUserInput = {
    id?: string
    name: string
    address: string
    phone: string
    notes: string
    title: string
    description?: string | null
    url?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
  }

  export type CertificateUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    address: string
    phone: string
    notes: string
    title: string
    description?: string | null
    url?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutUserInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateCreateManyUserInputEnvelope = {
    data: CertificateCreateManyUserInput | CertificateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommunityCreateWithoutParticipantsInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupCreateNestedManyWithoutCommunityInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCommunityInput
    posts?: PostCreateNestedManyWithoutCommunityInput
    discussions?: DiscussionCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutParticipantsInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupUncheckedCreateNestedManyWithoutCommunityInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCommunityInput
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
    discussions?: DiscussionUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutParticipantsInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutParticipantsInput, CommunityUncheckedCreateWithoutParticipantsInput>
  }

  export type LiveRoomCreateWithoutUserInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutLiveRoomInput
    course?: CourseCreateNestedOneWithoutLiveRoomInput
  }

  export type LiveRoomUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    communityId: string
    courseId?: string | null
  }

  export type LiveRoomCreateOrConnectWithoutUserInput = {
    where: LiveRoomWhereUniqueInput
    create: XOR<LiveRoomCreateWithoutUserInput, LiveRoomUncheckedCreateWithoutUserInput>
  }

  export type NotificationSettingsCreateWithoutUserInput = {
    id?: string
    assignments?: boolean
    grades?: boolean
    messages?: boolean
    achievements?: boolean
    urgent?: boolean
    email?: boolean
    push?: boolean
    createdAt?: Date | string
  }

  export type NotificationSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    assignments?: boolean
    grades?: boolean
    messages?: boolean
    achievements?: boolean
    urgent?: boolean
    email?: boolean
    push?: boolean
    createdAt?: Date | string
  }

  export type NotificationSettingsCreateOrConnectWithoutUserInput = {
    where: NotificationSettingsWhereUniqueInput
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
  }

  export type NotificationSettingsCreateManyUserInputEnvelope = {
    data: NotificationSettingsCreateManyUserInput | NotificationSettingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PathCreateWithoutPeersInput = {
    id?: string
    title: string
    description?: string | null
    level: string
    completedTasks?: number
    remainingTime?: number
    studyTime?: number
    totalTasks?: number
    progress?: number
    engagement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: MilestoneCreateNestedManyWithoutPathInput
    courses?: CourseCreateNestedManyWithoutPathInput
  }

  export type PathUncheckedCreateWithoutPeersInput = {
    id?: string
    title: string
    description?: string | null
    level: string
    completedTasks?: number
    remainingTime?: number
    studyTime?: number
    totalTasks?: number
    progress?: number
    engagement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: MilestoneUncheckedCreateNestedManyWithoutPathInput
    courses?: CourseUncheckedCreateNestedManyWithoutPathInput
  }

  export type PathCreateOrConnectWithoutPeersInput = {
    where: PathWhereUniqueInput
    create: XOR<PathCreateWithoutPeersInput, PathUncheckedCreateWithoutPeersInput>
  }

  export type LoginHistoryCreateWithoutUserInput = {
    id?: string
    success?: boolean
    ip?: string | null
    device?: $Enums.LoginDevice | null
    location?: string | null
    browser?: string | null
    os?: string | null
    createdAt?: Date | string
  }

  export type LoginHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    success?: boolean
    ip?: string | null
    device?: $Enums.LoginDevice | null
    location?: string | null
    browser?: string | null
    os?: string | null
    createdAt?: Date | string
  }

  export type LoginHistoryCreateOrConnectWithoutUserInput = {
    where: LoginHistoryWhereUniqueInput
    create: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput>
  }

  export type LoginHistoryCreateManyUserInputEnvelope = {
    data: LoginHistoryCreateManyUserInput | LoginHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TwoFactorCreateWithoutUserInput = {
    id?: string
    email?: boolean
    sms?: boolean
    authenticator?: boolean
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorUncheckedCreateWithoutUserInput = {
    id?: string
    email?: boolean
    sms?: boolean
    authenticator?: boolean
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwoFactorCreateOrConnectWithoutUserInput = {
    where: TwoFactorWhereUniqueInput
    create: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorCreateManyUserInputEnvelope = {
    data: TwoFactorCreateManyUserInput | TwoFactorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAcademyCEOCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    academy: AcademyCreateNestedOneWithoutCeosInput
  }

  export type UserAcademyCEOUncheckedCreateWithoutUserInput = {
    id?: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAcademyCEOCreateOrConnectWithoutUserInput = {
    where: UserAcademyCEOWhereUniqueInput
    create: XOR<UserAcademyCEOCreateWithoutUserInput, UserAcademyCEOUncheckedCreateWithoutUserInput>
  }

  export type UserAcademyCEOCreateManyUserInputEnvelope = {
    data: UserAcademyCEOCreateManyUserInput | UserAcademyCEOCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SalaryPaymentCreateWithoutEmployeeInput = {
    id?: string
    amount: number
    month: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    accountingEntry: AccountingEntryCreateNestedOneWithoutSalaryPaymentInput
  }

  export type SalaryPaymentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    amount: number
    month: number
    year: number
    accountingEntryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryPaymentCreateOrConnectWithoutEmployeeInput = {
    where: SalaryPaymentWhereUniqueInput
    create: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryPaymentCreateManyEmployeeInputEnvelope = {
    data: SalaryPaymentCreateManyEmployeeInput | SalaryPaymentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type MeetingParticipantCreateWithoutUserInput = {
    id?: string
    isAttended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutParticipantsInput
  }

  export type MeetingParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    meetingId: string
    isAttended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingParticipantCreateOrConnectWithoutUserInput = {
    where: MeetingParticipantWhereUniqueInput
    create: XOR<MeetingParticipantCreateWithoutUserInput, MeetingParticipantUncheckedCreateWithoutUserInput>
  }

  export type MeetingParticipantCreateManyUserInputEnvelope = {
    data: MeetingParticipantCreateManyUserInput | MeetingParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LegalCaseCreateWithoutRelatedUserInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedLawyer: AdminCreateNestedOneWithoutLegalCasesInput
    academy: AcademyCreateNestedOneWithoutLegalCaseInput
    files?: FileCreateNestedManyWithoutLegalCaseInput
    reports?: ReportCreateNestedManyWithoutLegalCaseInput
    events?: EventCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseUncheckedCreateWithoutRelatedUserInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLegalCaseInput
    reports?: ReportUncheckedCreateNestedManyWithoutLegalCaseInput
    events?: EventUncheckedCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelUncheckedCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseCreateOrConnectWithoutRelatedUserInput = {
    where: LegalCaseWhereUniqueInput
    create: XOR<LegalCaseCreateWithoutRelatedUserInput, LegalCaseUncheckedCreateWithoutRelatedUserInput>
  }

  export type LegalCaseCreateManyRelatedUserInputEnvelope = {
    data: LegalCaseCreateManyRelatedUserInput | LegalCaseCreateManyRelatedUserInput[]
    skipDuplicates?: boolean
  }

  export type AcademyUpsertWithoutUsersInput = {
    update: XOR<AcademyUpdateWithoutUsersInput, AcademyUncheckedUpdateWithoutUsersInput>
    create: XOR<AcademyCreateWithoutUsersInput, AcademyUncheckedCreateWithoutUsersInput>
    where?: AcademyWhereInput
  }

  export type AcademyUpdateToOneWithWhereWithoutUsersInput = {
    where?: AcademyWhereInput
    data: XOR<AcademyUpdateWithoutUsersInput, AcademyUncheckedUpdateWithoutUsersInput>
  }

  export type AcademyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ceos?: UserAcademyCEOUpdateManyWithoutAcademyNestedInput
    courses?: CourseUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUpdateManyWithoutAcademyNestedInput
    events?: EventUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ceos?: UserAcademyCEOUncheckedUpdateManyWithoutAcademyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutAcademyNestedInput
    events?: EventUncheckedUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUncheckedUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutAcademyNestedInput
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    preferences?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<EnrollmentCreateWithoutUserInput, EnrollmentUncheckedCreateWithoutUserInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutUserInput, EnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: StringFilter<"Enrollment"> | string
    userId?: StringFilter<"Enrollment"> | string
    courseId?: StringFilter<"Enrollment"> | string
    progress?: FloatFilter<"Enrollment"> | number
    status?: StringFilter<"Enrollment"> | string
    createdAt?: DateTimeFilter<"Enrollment"> | Date | string
    updatedAt?: DateTimeFilter<"Enrollment"> | Date | string
  }

  export type AchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUpdateManyWithWhereWithoutUserInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    OR?: AchievementScalarWhereInput[]
    NOT?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    id?: StringFilter<"Achievement"> | string
    userId?: StringFilter<"Achievement"> | string
    type?: StringFilter<"Achievement"> | string
    value?: JsonFilter<"Achievement">
    isNew?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    message?: StringFilter<"Notification"> | string
    isImportant?: BoolFilter<"Notification"> | boolean
    urgent?: BoolFilter<"Notification"> | boolean
    title?: StringFilter<"Notification"> | string
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    isRead?: BoolFilter<"Message"> | boolean
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    createdAt?: DateTimeFilter<"Post"> | Date | string
    likesCount?: IntFilter<"Post"> | number
    publicRelationsRecordId?: StringNullableFilter<"Post"> | string | null
  }

  export type GroupUpsertWithWhereUniqueWithoutMembersInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
    create: XOR<GroupCreateWithoutMembersInput, GroupUncheckedCreateWithoutMembersInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutMembersInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutMembersInput, GroupUncheckedUpdateWithoutMembersInput>
  }

  export type GroupUpdateManyWithWhereWithoutMembersInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutMembersInput>
  }

  export type GroupScalarWhereInput = {
    AND?: GroupScalarWhereInput | GroupScalarWhereInput[]
    OR?: GroupScalarWhereInput[]
    NOT?: GroupScalarWhereInput | GroupScalarWhereInput[]
    id?: StringFilter<"Group"> | string
    name?: StringFilter<"Group"> | string
    subject?: StringFilter<"Group"> | string
    image?: StringNullableFilter<"Group"> | string | null
    adminId?: StringFilter<"Group"> | string
    createdAt?: DateTimeFilter<"Group"> | Date | string
  }

  export type ChannelUpsertWithWhereUniqueWithoutMembersInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutMembersInput, ChannelUncheckedUpdateWithoutMembersInput>
    create: XOR<ChannelCreateWithoutMembersInput, ChannelUncheckedCreateWithoutMembersInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutMembersInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutMembersInput, ChannelUncheckedUpdateWithoutMembersInput>
  }

  export type ChannelUpdateManyWithWhereWithoutMembersInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutMembersInput>
  }

  export type ChannelScalarWhereInput = {
    AND?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    OR?: ChannelScalarWhereInput[]
    NOT?: ChannelScalarWhereInput | ChannelScalarWhereInput[]
    id?: StringFilter<"Channel"> | string
    name?: StringFilter<"Channel"> | string
    ownerId?: StringFilter<"Channel"> | string
    prRecordId?: StringNullableFilter<"Channel"> | string | null
    meetingId?: StringNullableFilter<"Channel"> | string | null
    adminRoleId?: StringNullableFilter<"Channel"> | string | null
    legalCaseId?: StringNullableFilter<"Channel"> | string | null
    createdAt?: DateTimeFilter<"Channel"> | Date | string
  }

  export type BookmarkUpsertWithWhereUniqueWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    update: XOR<BookmarkUpdateWithoutUserInput, BookmarkUncheckedUpdateWithoutUserInput>
    create: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput>
  }

  export type BookmarkUpdateWithWhereUniqueWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    data: XOR<BookmarkUpdateWithoutUserInput, BookmarkUncheckedUpdateWithoutUserInput>
  }

  export type BookmarkUpdateManyWithWhereWithoutUserInput = {
    where: BookmarkScalarWhereInput
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyWithoutUserInput>
  }

  export type BookmarkScalarWhereInput = {
    AND?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
    OR?: BookmarkScalarWhereInput[]
    NOT?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
    id?: StringFilter<"Bookmark"> | string
    userId?: StringFilter<"Bookmark"> | string
    type?: StringFilter<"Bookmark"> | string
    itemId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
  }

  export type SubmissionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubmissionWhereUniqueInput
    update: XOR<SubmissionUpdateWithoutUserInput, SubmissionUncheckedUpdateWithoutUserInput>
    create: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput>
  }

  export type SubmissionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubmissionWhereUniqueInput
    data: XOR<SubmissionUpdateWithoutUserInput, SubmissionUncheckedUpdateWithoutUserInput>
  }

  export type SubmissionUpdateManyWithWhereWithoutUserInput = {
    where: SubmissionScalarWhereInput
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubmissionScalarWhereInput = {
    AND?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
    OR?: SubmissionScalarWhereInput[]
    NOT?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
    id?: StringFilter<"Submission"> | string
    userId?: StringFilter<"Submission"> | string
    quizId?: StringFilter<"Submission"> | string
    answers?: JsonNullableListFilter<"Submission">
    score?: FloatNullableFilter<"Submission"> | number | null
    feedback?: StringNullableFilter<"Submission"> | string | null
    passed?: BoolNullableFilter<"Submission"> | boolean | null
    createdAt?: DateTimeFilter<"Submission"> | Date | string
    updatedAt?: DateTimeFilter<"Submission"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    studentId?: StringFilter<"Attendance"> | string
    lessonId?: StringFilter<"Attendance"> | string
    status?: StringFilter<"Attendance"> | string
    method?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type InstructorUpsertWithWhereUniqueWithoutUserInput = {
    where: InstructorWhereUniqueInput
    update: XOR<InstructorUpdateWithoutUserInput, InstructorUncheckedUpdateWithoutUserInput>
    create: XOR<InstructorCreateWithoutUserInput, InstructorUncheckedCreateWithoutUserInput>
  }

  export type InstructorUpdateWithWhereUniqueWithoutUserInput = {
    where: InstructorWhereUniqueInput
    data: XOR<InstructorUpdateWithoutUserInput, InstructorUncheckedUpdateWithoutUserInput>
  }

  export type InstructorUpdateManyWithWhereWithoutUserInput = {
    where: InstructorScalarWhereInput
    data: XOR<InstructorUpdateManyMutationInput, InstructorUncheckedUpdateManyWithoutUserInput>
  }

  export type InstructorScalarWhereInput = {
    AND?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
    OR?: InstructorScalarWhereInput[]
    NOT?: InstructorScalarWhereInput | InstructorScalarWhereInput[]
    id?: StringFilter<"Instructor"> | string
    userId?: StringFilter<"Instructor"> | string
    academyId?: StringFilter<"Instructor"> | string
  }

  export type OwnerUpsertWithWhereUniqueWithoutUserInput = {
    where: OwnerWhereUniqueInput
    update: XOR<OwnerUpdateWithoutUserInput, OwnerUncheckedUpdateWithoutUserInput>
    create: XOR<OwnerCreateWithoutUserInput, OwnerUncheckedCreateWithoutUserInput>
  }

  export type OwnerUpdateWithWhereUniqueWithoutUserInput = {
    where: OwnerWhereUniqueInput
    data: XOR<OwnerUpdateWithoutUserInput, OwnerUncheckedUpdateWithoutUserInput>
  }

  export type OwnerUpdateManyWithWhereWithoutUserInput = {
    where: OwnerScalarWhereInput
    data: XOR<OwnerUpdateManyMutationInput, OwnerUncheckedUpdateManyWithoutUserInput>
  }

  export type OwnerScalarWhereInput = {
    AND?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
    OR?: OwnerScalarWhereInput[]
    NOT?: OwnerScalarWhereInput | OwnerScalarWhereInput[]
    id?: StringFilter<"Owner"> | string
    userId?: StringFilter<"Owner"> | string
    createdAt?: DateTimeFilter<"Owner"> | Date | string
  }

  export type AdminUpsertWithWhereUniqueWithoutUserInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutUserInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateManyWithWhereWithoutUserInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutUserInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
  }

  export type LessonUpsertWithWhereUniqueWithoutCompletedByInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutCompletedByInput, LessonUncheckedUpdateWithoutCompletedByInput>
    create: XOR<LessonCreateWithoutCompletedByInput, LessonUncheckedCreateWithoutCompletedByInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutCompletedByInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutCompletedByInput, LessonUncheckedUpdateWithoutCompletedByInput>
  }

  export type LessonUpdateManyWithWhereWithoutCompletedByInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutCompletedByInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    content?: StringFilter<"Lesson"> | string
    courseId?: StringFilter<"Lesson"> | string
    status?: EnumLessonStatusFilter<"Lesson"> | $Enums.LessonStatus
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    legalCaseId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutUserInput, ReportUncheckedUpdateWithoutUserInput>
    create: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutUserInput, ReportUncheckedUpdateWithoutUserInput>
  }

  export type ReportUpdateManyWithWhereWithoutUserInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    userId?: StringFilter<"Report"> | string
    accountingEntryId?: StringNullableFilter<"Report"> | string | null
    meetingId?: StringNullableFilter<"Report"> | string | null
    adminRoleId?: StringNullableFilter<"Report"> | string | null
    legalCaseId?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type BadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutUserInput, BadgeUncheckedUpdateWithoutUserInput>
    create: XOR<BadgeCreateWithoutUserInput, BadgeUncheckedCreateWithoutUserInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutUserInput, BadgeUncheckedUpdateWithoutUserInput>
  }

  export type BadgeUpdateManyWithWhereWithoutUserInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type BadgeScalarWhereInput = {
    AND?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    OR?: BadgeScalarWhereInput[]
    NOT?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    id?: StringFilter<"Badge"> | string
    userId?: StringFilter<"Badge"> | string
    title?: StringFilter<"Badge"> | string
    description?: StringNullableFilter<"Badge"> | string | null
    image?: StringNullableFilter<"Badge"> | string | null
    points?: IntFilter<"Badge"> | number
    type?: StringFilter<"Badge"> | string
    earnedAt?: DateTimeFilter<"Badge"> | Date | string
    createdAt?: DateTimeFilter<"Badge"> | Date | string
  }

  export type CertificateUpsertWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
  }

  export type CertificateUpdateManyWithWhereWithoutUserInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutUserInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: StringFilter<"Certificate"> | string
    name?: StringFilter<"Certificate"> | string
    address?: StringFilter<"Certificate"> | string
    phone?: StringFilter<"Certificate"> | string
    notes?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    title?: StringFilter<"Certificate"> | string
    description?: StringNullableFilter<"Certificate"> | string | null
    url?: StringNullableFilter<"Certificate"> | string | null
    image?: StringNullableFilter<"Certificate"> | string | null
    points?: IntFilter<"Certificate"> | number
    type?: StringFilter<"Certificate"> | string
    earnedAt?: DateTimeFilter<"Certificate"> | Date | string
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
  }

  export type CommunityUpsertWithWhereUniqueWithoutParticipantsInput = {
    where: CommunityWhereUniqueInput
    update: XOR<CommunityUpdateWithoutParticipantsInput, CommunityUncheckedUpdateWithoutParticipantsInput>
    create: XOR<CommunityCreateWithoutParticipantsInput, CommunityUncheckedCreateWithoutParticipantsInput>
  }

  export type CommunityUpdateWithWhereUniqueWithoutParticipantsInput = {
    where: CommunityWhereUniqueInput
    data: XOR<CommunityUpdateWithoutParticipantsInput, CommunityUncheckedUpdateWithoutParticipantsInput>
  }

  export type CommunityUpdateManyWithWhereWithoutParticipantsInput = {
    where: CommunityScalarWhereInput
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyWithoutParticipantsInput>
  }

  export type CommunityScalarWhereInput = {
    AND?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
    OR?: CommunityScalarWhereInput[]
    NOT?: CommunityScalarWhereInput | CommunityScalarWhereInput[]
    id?: StringFilter<"Community"> | string
    name?: StringFilter<"Community"> | string
    image?: StringNullableFilter<"Community"> | string | null
    description?: StringNullableFilter<"Community"> | string | null
    type?: StringFilter<"Community"> | string
    likes?: IntFilter<"Community"> | number
    dislikes?: IntFilter<"Community"> | number
    views?: IntFilter<"Community"> | number
    createdAt?: DateTimeFilter<"Community"> | Date | string
    updatedAt?: DateTimeFilter<"Community"> | Date | string
  }

  export type LiveRoomUpsertWithWhereUniqueWithoutUserInput = {
    where: LiveRoomWhereUniqueInput
    update: XOR<LiveRoomUpdateWithoutUserInput, LiveRoomUncheckedUpdateWithoutUserInput>
    create: XOR<LiveRoomCreateWithoutUserInput, LiveRoomUncheckedCreateWithoutUserInput>
  }

  export type LiveRoomUpdateWithWhereUniqueWithoutUserInput = {
    where: LiveRoomWhereUniqueInput
    data: XOR<LiveRoomUpdateWithoutUserInput, LiveRoomUncheckedUpdateWithoutUserInput>
  }

  export type LiveRoomUpdateManyWithWhereWithoutUserInput = {
    where: LiveRoomScalarWhereInput
    data: XOR<LiveRoomUpdateManyMutationInput, LiveRoomUncheckedUpdateManyWithoutUserInput>
  }

  export type LiveRoomScalarWhereInput = {
    AND?: LiveRoomScalarWhereInput | LiveRoomScalarWhereInput[]
    OR?: LiveRoomScalarWhereInput[]
    NOT?: LiveRoomScalarWhereInput | LiveRoomScalarWhereInput[]
    id?: StringFilter<"LiveRoom"> | string
    title?: StringFilter<"LiveRoom"> | string
    topic?: StringNullableFilter<"LiveRoom"> | string | null
    participants?: IntFilter<"LiveRoom"> | number
    isLive?: BoolFilter<"LiveRoom"> | boolean
    isActive?: BoolFilter<"LiveRoom"> | boolean
    isPublic?: BoolFilter<"LiveRoom"> | boolean
    isPrivate?: BoolFilter<"LiveRoom"> | boolean
    isPasswordProtected?: BoolFilter<"LiveRoom"> | boolean
    createdAt?: DateTimeFilter<"LiveRoom"> | Date | string
    updatedAt?: DateTimeFilter<"LiveRoom"> | Date | string
    communityId?: StringFilter<"LiveRoom"> | string
    courseId?: StringNullableFilter<"LiveRoom"> | string | null
  }

  export type NotificationSettingsUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationSettingsWhereUniqueInput
    update: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
  }

  export type NotificationSettingsUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationSettingsWhereUniqueInput
    data: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationSettingsUpdateManyWithWhereWithoutUserInput = {
    where: NotificationSettingsScalarWhereInput
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationSettingsScalarWhereInput = {
    AND?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
    OR?: NotificationSettingsScalarWhereInput[]
    NOT?: NotificationSettingsScalarWhereInput | NotificationSettingsScalarWhereInput[]
    id?: StringFilter<"NotificationSettings"> | string
    userId?: StringFilter<"NotificationSettings"> | string
    assignments?: BoolFilter<"NotificationSettings"> | boolean
    grades?: BoolFilter<"NotificationSettings"> | boolean
    messages?: BoolFilter<"NotificationSettings"> | boolean
    achievements?: BoolFilter<"NotificationSettings"> | boolean
    urgent?: BoolFilter<"NotificationSettings"> | boolean
    email?: BoolFilter<"NotificationSettings"> | boolean
    push?: BoolFilter<"NotificationSettings"> | boolean
    createdAt?: DateTimeFilter<"NotificationSettings"> | Date | string
  }

  export type PathUpsertWithWhereUniqueWithoutPeersInput = {
    where: PathWhereUniqueInput
    update: XOR<PathUpdateWithoutPeersInput, PathUncheckedUpdateWithoutPeersInput>
    create: XOR<PathCreateWithoutPeersInput, PathUncheckedCreateWithoutPeersInput>
  }

  export type PathUpdateWithWhereUniqueWithoutPeersInput = {
    where: PathWhereUniqueInput
    data: XOR<PathUpdateWithoutPeersInput, PathUncheckedUpdateWithoutPeersInput>
  }

  export type PathUpdateManyWithWhereWithoutPeersInput = {
    where: PathScalarWhereInput
    data: XOR<PathUpdateManyMutationInput, PathUncheckedUpdateManyWithoutPeersInput>
  }

  export type PathScalarWhereInput = {
    AND?: PathScalarWhereInput | PathScalarWhereInput[]
    OR?: PathScalarWhereInput[]
    NOT?: PathScalarWhereInput | PathScalarWhereInput[]
    id?: StringFilter<"Path"> | string
    title?: StringFilter<"Path"> | string
    description?: StringNullableFilter<"Path"> | string | null
    level?: StringFilter<"Path"> | string
    completedTasks?: IntFilter<"Path"> | number
    remainingTime?: IntFilter<"Path"> | number
    studyTime?: IntFilter<"Path"> | number
    totalTasks?: IntFilter<"Path"> | number
    progress?: FloatFilter<"Path"> | number
    engagement?: FloatFilter<"Path"> | number
    createdAt?: DateTimeFilter<"Path"> | Date | string
    updatedAt?: DateTimeFilter<"Path"> | Date | string
  }

  export type LoginHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: LoginHistoryWhereUniqueInput
    update: XOR<LoginHistoryUpdateWithoutUserInput, LoginHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<LoginHistoryCreateWithoutUserInput, LoginHistoryUncheckedCreateWithoutUserInput>
  }

  export type LoginHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: LoginHistoryWhereUniqueInput
    data: XOR<LoginHistoryUpdateWithoutUserInput, LoginHistoryUncheckedUpdateWithoutUserInput>
  }

  export type LoginHistoryUpdateManyWithWhereWithoutUserInput = {
    where: LoginHistoryScalarWhereInput
    data: XOR<LoginHistoryUpdateManyMutationInput, LoginHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type LoginHistoryScalarWhereInput = {
    AND?: LoginHistoryScalarWhereInput | LoginHistoryScalarWhereInput[]
    OR?: LoginHistoryScalarWhereInput[]
    NOT?: LoginHistoryScalarWhereInput | LoginHistoryScalarWhereInput[]
    id?: StringFilter<"LoginHistory"> | string
    userId?: StringFilter<"LoginHistory"> | string
    success?: BoolFilter<"LoginHistory"> | boolean
    ip?: StringNullableFilter<"LoginHistory"> | string | null
    device?: EnumLoginDeviceNullableFilter<"LoginHistory"> | $Enums.LoginDevice | null
    location?: StringNullableFilter<"LoginHistory"> | string | null
    browser?: StringNullableFilter<"LoginHistory"> | string | null
    os?: StringNullableFilter<"LoginHistory"> | string | null
    createdAt?: DateTimeFilter<"LoginHistory"> | Date | string
  }

  export type TwoFactorUpsertWithWhereUniqueWithoutUserInput = {
    where: TwoFactorWhereUniqueInput
    update: XOR<TwoFactorUpdateWithoutUserInput, TwoFactorUncheckedUpdateWithoutUserInput>
    create: XOR<TwoFactorCreateWithoutUserInput, TwoFactorUncheckedCreateWithoutUserInput>
  }

  export type TwoFactorUpdateWithWhereUniqueWithoutUserInput = {
    where: TwoFactorWhereUniqueInput
    data: XOR<TwoFactorUpdateWithoutUserInput, TwoFactorUncheckedUpdateWithoutUserInput>
  }

  export type TwoFactorUpdateManyWithWhereWithoutUserInput = {
    where: TwoFactorScalarWhereInput
    data: XOR<TwoFactorUpdateManyMutationInput, TwoFactorUncheckedUpdateManyWithoutUserInput>
  }

  export type TwoFactorScalarWhereInput = {
    AND?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
    OR?: TwoFactorScalarWhereInput[]
    NOT?: TwoFactorScalarWhereInput | TwoFactorScalarWhereInput[]
    id?: StringFilter<"TwoFactor"> | string
    userId?: StringFilter<"TwoFactor"> | string
    email?: BoolFilter<"TwoFactor"> | boolean
    sms?: BoolFilter<"TwoFactor"> | boolean
    authenticator?: BoolFilter<"TwoFactor"> | boolean
    secret?: StringNullableFilter<"TwoFactor"> | string | null
    createdAt?: DateTimeFilter<"TwoFactor"> | Date | string
    updatedAt?: DateTimeFilter<"TwoFactor"> | Date | string
  }

  export type UserAcademyCEOUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAcademyCEOWhereUniqueInput
    update: XOR<UserAcademyCEOUpdateWithoutUserInput, UserAcademyCEOUncheckedUpdateWithoutUserInput>
    create: XOR<UserAcademyCEOCreateWithoutUserInput, UserAcademyCEOUncheckedCreateWithoutUserInput>
  }

  export type UserAcademyCEOUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAcademyCEOWhereUniqueInput
    data: XOR<UserAcademyCEOUpdateWithoutUserInput, UserAcademyCEOUncheckedUpdateWithoutUserInput>
  }

  export type UserAcademyCEOUpdateManyWithWhereWithoutUserInput = {
    where: UserAcademyCEOScalarWhereInput
    data: XOR<UserAcademyCEOUpdateManyMutationInput, UserAcademyCEOUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAcademyCEOScalarWhereInput = {
    AND?: UserAcademyCEOScalarWhereInput | UserAcademyCEOScalarWhereInput[]
    OR?: UserAcademyCEOScalarWhereInput[]
    NOT?: UserAcademyCEOScalarWhereInput | UserAcademyCEOScalarWhereInput[]
    id?: StringFilter<"UserAcademyCEO"> | string
    userId?: StringFilter<"UserAcademyCEO"> | string
    academyId?: StringFilter<"UserAcademyCEO"> | string
    createdAt?: DateTimeFilter<"UserAcademyCEO"> | Date | string
    updatedAt?: DateTimeFilter<"UserAcademyCEO"> | Date | string
  }

  export type SalaryPaymentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryPaymentWhereUniqueInput
    update: XOR<SalaryPaymentUpdateWithoutEmployeeInput, SalaryPaymentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SalaryPaymentCreateWithoutEmployeeInput, SalaryPaymentUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryPaymentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryPaymentWhereUniqueInput
    data: XOR<SalaryPaymentUpdateWithoutEmployeeInput, SalaryPaymentUncheckedUpdateWithoutEmployeeInput>
  }

  export type SalaryPaymentUpdateManyWithWhereWithoutEmployeeInput = {
    where: SalaryPaymentScalarWhereInput
    data: XOR<SalaryPaymentUpdateManyMutationInput, SalaryPaymentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type SalaryPaymentScalarWhereInput = {
    AND?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
    OR?: SalaryPaymentScalarWhereInput[]
    NOT?: SalaryPaymentScalarWhereInput | SalaryPaymentScalarWhereInput[]
    id?: StringFilter<"SalaryPayment"> | string
    employeeId?: StringFilter<"SalaryPayment"> | string
    amount?: FloatFilter<"SalaryPayment"> | number
    month?: IntFilter<"SalaryPayment"> | number
    year?: IntFilter<"SalaryPayment"> | number
    accountingEntryId?: StringFilter<"SalaryPayment"> | string
    createdAt?: DateTimeFilter<"SalaryPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryPayment"> | Date | string
  }

  export type MeetingParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: MeetingParticipantWhereUniqueInput
    update: XOR<MeetingParticipantUpdateWithoutUserInput, MeetingParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<MeetingParticipantCreateWithoutUserInput, MeetingParticipantUncheckedCreateWithoutUserInput>
  }

  export type MeetingParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: MeetingParticipantWhereUniqueInput
    data: XOR<MeetingParticipantUpdateWithoutUserInput, MeetingParticipantUncheckedUpdateWithoutUserInput>
  }

  export type MeetingParticipantUpdateManyWithWhereWithoutUserInput = {
    where: MeetingParticipantScalarWhereInput
    data: XOR<MeetingParticipantUpdateManyMutationInput, MeetingParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type MeetingParticipantScalarWhereInput = {
    AND?: MeetingParticipantScalarWhereInput | MeetingParticipantScalarWhereInput[]
    OR?: MeetingParticipantScalarWhereInput[]
    NOT?: MeetingParticipantScalarWhereInput | MeetingParticipantScalarWhereInput[]
    id?: StringFilter<"MeetingParticipant"> | string
    meetingId?: StringFilter<"MeetingParticipant"> | string
    userId?: StringFilter<"MeetingParticipant"> | string
    isAttended?: BoolFilter<"MeetingParticipant"> | boolean
    createdAt?: DateTimeFilter<"MeetingParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingParticipant"> | Date | string
  }

  export type LegalCaseUpsertWithWhereUniqueWithoutRelatedUserInput = {
    where: LegalCaseWhereUniqueInput
    update: XOR<LegalCaseUpdateWithoutRelatedUserInput, LegalCaseUncheckedUpdateWithoutRelatedUserInput>
    create: XOR<LegalCaseCreateWithoutRelatedUserInput, LegalCaseUncheckedCreateWithoutRelatedUserInput>
  }

  export type LegalCaseUpdateWithWhereUniqueWithoutRelatedUserInput = {
    where: LegalCaseWhereUniqueInput
    data: XOR<LegalCaseUpdateWithoutRelatedUserInput, LegalCaseUncheckedUpdateWithoutRelatedUserInput>
  }

  export type LegalCaseUpdateManyWithWhereWithoutRelatedUserInput = {
    where: LegalCaseScalarWhereInput
    data: XOR<LegalCaseUpdateManyMutationInput, LegalCaseUncheckedUpdateManyWithoutRelatedUserInput>
  }

  export type LegalCaseScalarWhereInput = {
    AND?: LegalCaseScalarWhereInput | LegalCaseScalarWhereInput[]
    OR?: LegalCaseScalarWhereInput[]
    NOT?: LegalCaseScalarWhereInput | LegalCaseScalarWhereInput[]
    id?: StringFilter<"LegalCase"> | string
    caseTitle?: StringFilter<"LegalCase"> | string
    caseType?: EnumLegalCaseTypeFilter<"LegalCase"> | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFilter<"LegalCase"> | $Enums.LegalCaseStatus
    description?: StringFilter<"LegalCase"> | string
    courtDate?: DateTimeNullableFilter<"LegalCase"> | Date | string | null
    assignedLawyerId?: StringFilter<"LegalCase"> | string
    academyId?: StringFilter<"LegalCase"> | string
    relatedUserId?: StringNullableFilter<"LegalCase"> | string | null
    createdAt?: DateTimeFilter<"LegalCase"> | Date | string
    updatedAt?: DateTimeFilter<"LegalCase"> | Date | string
  }

  export type UserCreateWithoutLoginHistoryInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutLoginHistoryInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutLoginHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
  }

  export type UserUpsertWithoutLoginHistoryInput = {
    update: XOR<UserUpdateWithoutLoginHistoryInput, UserUncheckedUpdateWithoutLoginHistoryInput>
    create: XOR<UserCreateWithoutLoginHistoryInput, UserUncheckedCreateWithoutLoginHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLoginHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLoginHistoryInput, UserUncheckedUpdateWithoutLoginHistoryInput>
  }

  export type UserUpdateWithoutLoginHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLoginHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserCreateWithoutTwoFactorInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutTwoFactorInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutTwoFactorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTwoFactorInput, UserUncheckedCreateWithoutTwoFactorInput>
  }

  export type UserUpsertWithoutTwoFactorInput = {
    update: XOR<UserUpdateWithoutTwoFactorInput, UserUncheckedUpdateWithoutTwoFactorInput>
    create: XOR<UserCreateWithoutTwoFactorInput, UserUncheckedCreateWithoutTwoFactorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTwoFactorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTwoFactorInput, UserUncheckedUpdateWithoutTwoFactorInput>
  }

  export type UserUpdateWithoutTwoFactorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTwoFactorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserCreateWithoutUserAcademyCEOInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutUserAcademyCEOInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutUserAcademyCEOInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserAcademyCEOInput, UserUncheckedCreateWithoutUserAcademyCEOInput>
  }

  export type AcademyCreateWithoutCeosInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAcademyInput
    courses?: CourseCreateNestedManyWithoutAcademyInput
    instructors?: InstructorCreateNestedManyWithoutAcademyInput
    events?: EventCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUncheckedCreateWithoutCeosInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAcademyInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademyInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutAcademyInput
    events?: EventUncheckedCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryUncheckedCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutAcademyInput
  }

  export type AcademyCreateOrConnectWithoutCeosInput = {
    where: AcademyWhereUniqueInput
    create: XOR<AcademyCreateWithoutCeosInput, AcademyUncheckedCreateWithoutCeosInput>
  }

  export type UserUpsertWithoutUserAcademyCEOInput = {
    update: XOR<UserUpdateWithoutUserAcademyCEOInput, UserUncheckedUpdateWithoutUserAcademyCEOInput>
    create: XOR<UserCreateWithoutUserAcademyCEOInput, UserUncheckedCreateWithoutUserAcademyCEOInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserAcademyCEOInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserAcademyCEOInput, UserUncheckedUpdateWithoutUserAcademyCEOInput>
  }

  export type UserUpdateWithoutUserAcademyCEOInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserAcademyCEOInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type AcademyUpsertWithoutCeosInput = {
    update: XOR<AcademyUpdateWithoutCeosInput, AcademyUncheckedUpdateWithoutCeosInput>
    create: XOR<AcademyCreateWithoutCeosInput, AcademyUncheckedCreateWithoutCeosInput>
    where?: AcademyWhereInput
  }

  export type AcademyUpdateToOneWithWhereWithoutCeosInput = {
    where?: AcademyWhereInput
    data: XOR<AcademyUpdateWithoutCeosInput, AcademyUncheckedUpdateWithoutCeosInput>
  }

  export type AcademyUpdateWithoutCeosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAcademyNestedInput
    courses?: CourseUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUpdateManyWithoutAcademyNestedInput
    events?: EventUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyUncheckedUpdateWithoutCeosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAcademyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutAcademyNestedInput
    events?: EventUncheckedUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUncheckedUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutAcademyNestedInput
  }

  export type UserCreateWithoutAcademyInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutAcademyInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutAcademyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAcademyInput, UserUncheckedCreateWithoutAcademyInput>
  }

  export type UserCreateManyAcademyInputEnvelope = {
    data: UserCreateManyAcademyInput | UserCreateManyAcademyInput[]
    skipDuplicates?: boolean
  }

  export type UserAcademyCEOCreateWithoutAcademyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserAcademyCEOInput
  }

  export type UserAcademyCEOUncheckedCreateWithoutAcademyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAcademyCEOCreateOrConnectWithoutAcademyInput = {
    where: UserAcademyCEOWhereUniqueInput
    create: XOR<UserAcademyCEOCreateWithoutAcademyInput, UserAcademyCEOUncheckedCreateWithoutAcademyInput>
  }

  export type UserAcademyCEOCreateManyAcademyInputEnvelope = {
    data: UserAcademyCEOCreateManyAcademyInput | UserAcademyCEOCreateManyAcademyInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutAcademyInput = {
    id?: string
    title: string
    description: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    lessons?: LessonCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    instructors?: InstructorCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCourseInput
    Path?: PathCreateNestedManyWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutAcademyInput = {
    id?: string
    title: string
    description: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCourseInput
    Path?: PathUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CourseCreateOrConnectWithoutAcademyInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutAcademyInput, CourseUncheckedCreateWithoutAcademyInput>
  }

  export type CourseCreateManyAcademyInputEnvelope = {
    data: CourseCreateManyAcademyInput | CourseCreateManyAcademyInput[]
    skipDuplicates?: boolean
  }

  export type InstructorCreateWithoutAcademyInput = {
    id?: string
    user: UserCreateNestedOneWithoutInstructorInput
    courses?: CourseCreateNestedManyWithoutInstructorsInput
  }

  export type InstructorUncheckedCreateWithoutAcademyInput = {
    id?: string
    userId: string
    courses?: CourseUncheckedCreateNestedManyWithoutInstructorsInput
  }

  export type InstructorCreateOrConnectWithoutAcademyInput = {
    where: InstructorWhereUniqueInput
    create: XOR<InstructorCreateWithoutAcademyInput, InstructorUncheckedCreateWithoutAcademyInput>
  }

  export type InstructorCreateManyAcademyInputEnvelope = {
    data: InstructorCreateManyAcademyInput | InstructorCreateManyAcademyInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutAcademyInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutEventsInput
    adminRole?: AdminRoleCreateNestedOneWithoutEventsInput
    legalCase?: LegalCaseCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutAcademyInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    prRecordId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutAcademyInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutAcademyInput, EventUncheckedCreateWithoutAcademyInput>
  }

  export type EventCreateManyAcademyInputEnvelope = {
    data: EventCreateManyAcademyInput | EventCreateManyAcademyInput[]
    skipDuplicates?: boolean
  }

  export type AccountingEntryCreateWithoutAcademyInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutAccountingEntriesInput
    invoice?: InvoiceCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentCreateNestedOneWithoutAccountingEntryInput
    files?: FileCreateNestedManyWithoutAccountingEntryInput
    reports?: ReportCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryUncheckedCreateWithoutAcademyInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentUncheckedCreateNestedOneWithoutAccountingEntryInput
    files?: FileUncheckedCreateNestedManyWithoutAccountingEntryInput
    reports?: ReportUncheckedCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryCreateOrConnectWithoutAcademyInput = {
    where: AccountingEntryWhereUniqueInput
    create: XOR<AccountingEntryCreateWithoutAcademyInput, AccountingEntryUncheckedCreateWithoutAcademyInput>
  }

  export type AccountingEntryCreateManyAcademyInputEnvelope = {
    data: AccountingEntryCreateManyAcademyInput | AccountingEntryCreateManyAcademyInput[]
    skipDuplicates?: boolean
  }

  export type PublicRelationsRecordCreateWithoutAcademyInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    handledByAdmin: AdminCreateNestedOneWithoutPrRecordsInput
    responses?: PRResponseCreateNestedManyWithoutPrRecordInput
    events?: EventCreateNestedManyWithoutPrRecordInput
    posts?: PostCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileCreateNestedManyWithoutPrRecordInput
    channels?: ChannelCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordUncheckedCreateWithoutAcademyInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    handledByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: PRResponseUncheckedCreateNestedManyWithoutPrRecordInput
    events?: EventUncheckedCreateNestedManyWithoutPrRecordInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileUncheckedCreateNestedManyWithoutPrRecordInput
    channels?: ChannelUncheckedCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordCreateOrConnectWithoutAcademyInput = {
    where: PublicRelationsRecordWhereUniqueInput
    create: XOR<PublicRelationsRecordCreateWithoutAcademyInput, PublicRelationsRecordUncheckedCreateWithoutAcademyInput>
  }

  export type PublicRelationsRecordCreateManyAcademyInputEnvelope = {
    data: PublicRelationsRecordCreateManyAcademyInput | PublicRelationsRecordCreateManyAcademyInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutAcademyInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutMeetingsInput
    participants?: MeetingParticipantCreateNestedManyWithoutMeetingInput
    files?: FileCreateNestedManyWithoutMeetingInput
    reports?: ReportCreateNestedManyWithoutMeetingInput
    channels?: ChannelCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutAcademyInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: MeetingParticipantUncheckedCreateNestedManyWithoutMeetingInput
    files?: FileUncheckedCreateNestedManyWithoutMeetingInput
    reports?: ReportUncheckedCreateNestedManyWithoutMeetingInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutAcademyInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutAcademyInput, MeetingUncheckedCreateWithoutAcademyInput>
  }

  export type MeetingCreateManyAcademyInputEnvelope = {
    data: MeetingCreateManyAcademyInput | MeetingCreateManyAcademyInput[]
    skipDuplicates?: boolean
  }

  export type LegalCaseCreateWithoutAcademyInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedLawyer: AdminCreateNestedOneWithoutLegalCasesInput
    relatedUser?: UserCreateNestedOneWithoutLegalCaseInput
    files?: FileCreateNestedManyWithoutLegalCaseInput
    reports?: ReportCreateNestedManyWithoutLegalCaseInput
    events?: EventCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseUncheckedCreateWithoutAcademyInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLegalCaseInput
    reports?: ReportUncheckedCreateNestedManyWithoutLegalCaseInput
    events?: EventUncheckedCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelUncheckedCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseCreateOrConnectWithoutAcademyInput = {
    where: LegalCaseWhereUniqueInput
    create: XOR<LegalCaseCreateWithoutAcademyInput, LegalCaseUncheckedCreateWithoutAcademyInput>
  }

  export type LegalCaseCreateManyAcademyInputEnvelope = {
    data: LegalCaseCreateManyAcademyInput | LegalCaseCreateManyAcademyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutAcademyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAcademyInput, UserUncheckedUpdateWithoutAcademyInput>
    create: XOR<UserCreateWithoutAcademyInput, UserUncheckedCreateWithoutAcademyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAcademyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAcademyInput, UserUncheckedUpdateWithoutAcademyInput>
  }

  export type UserUpdateManyWithWhereWithoutAcademyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAcademyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    subRole?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    academyId?: StringNullableFilter<"User"> | string | null
    isOnline?: BoolFilter<"User"> | boolean
    isVerified?: BoolFilter<"User"> | boolean
    age?: IntNullableFilter<"User"> | number | null
  }

  export type UserAcademyCEOUpsertWithWhereUniqueWithoutAcademyInput = {
    where: UserAcademyCEOWhereUniqueInput
    update: XOR<UserAcademyCEOUpdateWithoutAcademyInput, UserAcademyCEOUncheckedUpdateWithoutAcademyInput>
    create: XOR<UserAcademyCEOCreateWithoutAcademyInput, UserAcademyCEOUncheckedCreateWithoutAcademyInput>
  }

  export type UserAcademyCEOUpdateWithWhereUniqueWithoutAcademyInput = {
    where: UserAcademyCEOWhereUniqueInput
    data: XOR<UserAcademyCEOUpdateWithoutAcademyInput, UserAcademyCEOUncheckedUpdateWithoutAcademyInput>
  }

  export type UserAcademyCEOUpdateManyWithWhereWithoutAcademyInput = {
    where: UserAcademyCEOScalarWhereInput
    data: XOR<UserAcademyCEOUpdateManyMutationInput, UserAcademyCEOUncheckedUpdateManyWithoutAcademyInput>
  }

  export type CourseUpsertWithWhereUniqueWithoutAcademyInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutAcademyInput, CourseUncheckedUpdateWithoutAcademyInput>
    create: XOR<CourseCreateWithoutAcademyInput, CourseUncheckedCreateWithoutAcademyInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutAcademyInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutAcademyInput, CourseUncheckedUpdateWithoutAcademyInput>
  }

  export type CourseUpdateManyWithWhereWithoutAcademyInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutAcademyInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    academyId?: StringFilter<"Course"> | string
    image?: StringNullableFilter<"Course"> | string | null
    level?: StringFilter<"Course"> | string
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    status?: EnumCourseStatusFilter<"Course"> | $Enums.CourseStatus
  }

  export type InstructorUpsertWithWhereUniqueWithoutAcademyInput = {
    where: InstructorWhereUniqueInput
    update: XOR<InstructorUpdateWithoutAcademyInput, InstructorUncheckedUpdateWithoutAcademyInput>
    create: XOR<InstructorCreateWithoutAcademyInput, InstructorUncheckedCreateWithoutAcademyInput>
  }

  export type InstructorUpdateWithWhereUniqueWithoutAcademyInput = {
    where: InstructorWhereUniqueInput
    data: XOR<InstructorUpdateWithoutAcademyInput, InstructorUncheckedUpdateWithoutAcademyInput>
  }

  export type InstructorUpdateManyWithWhereWithoutAcademyInput = {
    where: InstructorScalarWhereInput
    data: XOR<InstructorUpdateManyMutationInput, InstructorUncheckedUpdateManyWithoutAcademyInput>
  }

  export type EventUpsertWithWhereUniqueWithoutAcademyInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutAcademyInput, EventUncheckedUpdateWithoutAcademyInput>
    create: XOR<EventCreateWithoutAcademyInput, EventUncheckedCreateWithoutAcademyInput>
  }

  export type EventUpdateWithWhereUniqueWithoutAcademyInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutAcademyInput, EventUncheckedUpdateWithoutAcademyInput>
  }

  export type EventUpdateManyWithWhereWithoutAcademyInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutAcademyInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startTime?: DateTimeFilter<"Event"> | Date | string
    endTime?: DateTimeFilter<"Event"> | Date | string
    academyId?: StringFilter<"Event"> | string
    prRecordId?: StringNullableFilter<"Event"> | string | null
    adminRoleId?: StringNullableFilter<"Event"> | string | null
    legalCaseId?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type AccountingEntryUpsertWithWhereUniqueWithoutAcademyInput = {
    where: AccountingEntryWhereUniqueInput
    update: XOR<AccountingEntryUpdateWithoutAcademyInput, AccountingEntryUncheckedUpdateWithoutAcademyInput>
    create: XOR<AccountingEntryCreateWithoutAcademyInput, AccountingEntryUncheckedCreateWithoutAcademyInput>
  }

  export type AccountingEntryUpdateWithWhereUniqueWithoutAcademyInput = {
    where: AccountingEntryWhereUniqueInput
    data: XOR<AccountingEntryUpdateWithoutAcademyInput, AccountingEntryUncheckedUpdateWithoutAcademyInput>
  }

  export type AccountingEntryUpdateManyWithWhereWithoutAcademyInput = {
    where: AccountingEntryScalarWhereInput
    data: XOR<AccountingEntryUpdateManyMutationInput, AccountingEntryUncheckedUpdateManyWithoutAcademyInput>
  }

  export type AccountingEntryScalarWhereInput = {
    AND?: AccountingEntryScalarWhereInput | AccountingEntryScalarWhereInput[]
    OR?: AccountingEntryScalarWhereInput[]
    NOT?: AccountingEntryScalarWhereInput | AccountingEntryScalarWhereInput[]
    id?: StringFilter<"AccountingEntry"> | string
    type?: EnumAccountingTypeFilter<"AccountingEntry"> | $Enums.AccountingType
    amount?: FloatFilter<"AccountingEntry"> | number
    description?: StringFilter<"AccountingEntry"> | string
    date?: DateTimeFilter<"AccountingEntry"> | Date | string
    createdByAdminId?: StringFilter<"AccountingEntry"> | string
    academyId?: StringFilter<"AccountingEntry"> | string
    createdAt?: DateTimeFilter<"AccountingEntry"> | Date | string
    updatedAt?: DateTimeFilter<"AccountingEntry"> | Date | string
  }

  export type PublicRelationsRecordUpsertWithWhereUniqueWithoutAcademyInput = {
    where: PublicRelationsRecordWhereUniqueInput
    update: XOR<PublicRelationsRecordUpdateWithoutAcademyInput, PublicRelationsRecordUncheckedUpdateWithoutAcademyInput>
    create: XOR<PublicRelationsRecordCreateWithoutAcademyInput, PublicRelationsRecordUncheckedCreateWithoutAcademyInput>
  }

  export type PublicRelationsRecordUpdateWithWhereUniqueWithoutAcademyInput = {
    where: PublicRelationsRecordWhereUniqueInput
    data: XOR<PublicRelationsRecordUpdateWithoutAcademyInput, PublicRelationsRecordUncheckedUpdateWithoutAcademyInput>
  }

  export type PublicRelationsRecordUpdateManyWithWhereWithoutAcademyInput = {
    where: PublicRelationsRecordScalarWhereInput
    data: XOR<PublicRelationsRecordUpdateManyMutationInput, PublicRelationsRecordUncheckedUpdateManyWithoutAcademyInput>
  }

  export type PublicRelationsRecordScalarWhereInput = {
    AND?: PublicRelationsRecordScalarWhereInput | PublicRelationsRecordScalarWhereInput[]
    OR?: PublicRelationsRecordScalarWhereInput[]
    NOT?: PublicRelationsRecordScalarWhereInput | PublicRelationsRecordScalarWhereInput[]
    id?: StringFilter<"PublicRelationsRecord"> | string
    message?: StringFilter<"PublicRelationsRecord"> | string
    senderName?: StringFilter<"PublicRelationsRecord"> | string
    senderContact?: StringFilter<"PublicRelationsRecord"> | string
    status?: EnumPRRequestStatusFilter<"PublicRelationsRecord"> | $Enums.PRRequestStatus
    handledByAdminId?: StringFilter<"PublicRelationsRecord"> | string
    academyId?: StringFilter<"PublicRelationsRecord"> | string
    createdAt?: DateTimeFilter<"PublicRelationsRecord"> | Date | string
    updatedAt?: DateTimeFilter<"PublicRelationsRecord"> | Date | string
  }

  export type MeetingUpsertWithWhereUniqueWithoutAcademyInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutAcademyInput, MeetingUncheckedUpdateWithoutAcademyInput>
    create: XOR<MeetingCreateWithoutAcademyInput, MeetingUncheckedCreateWithoutAcademyInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutAcademyInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutAcademyInput, MeetingUncheckedUpdateWithoutAcademyInput>
  }

  export type MeetingUpdateManyWithWhereWithoutAcademyInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutAcademyInput>
  }

  export type MeetingScalarWhereInput = {
    AND?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    OR?: MeetingScalarWhereInput[]
    NOT?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    id?: StringFilter<"Meeting"> | string
    meetingTitle?: StringFilter<"Meeting"> | string
    meetingDate?: DateTimeFilter<"Meeting"> | Date | string
    location?: StringFilter<"Meeting"> | string
    notes?: StringNullableFilter<"Meeting"> | string | null
    createdByAdminId?: StringFilter<"Meeting"> | string
    academyId?: StringFilter<"Meeting"> | string
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
  }

  export type LegalCaseUpsertWithWhereUniqueWithoutAcademyInput = {
    where: LegalCaseWhereUniqueInput
    update: XOR<LegalCaseUpdateWithoutAcademyInput, LegalCaseUncheckedUpdateWithoutAcademyInput>
    create: XOR<LegalCaseCreateWithoutAcademyInput, LegalCaseUncheckedCreateWithoutAcademyInput>
  }

  export type LegalCaseUpdateWithWhereUniqueWithoutAcademyInput = {
    where: LegalCaseWhereUniqueInput
    data: XOR<LegalCaseUpdateWithoutAcademyInput, LegalCaseUncheckedUpdateWithoutAcademyInput>
  }

  export type LegalCaseUpdateManyWithWhereWithoutAcademyInput = {
    where: LegalCaseScalarWhereInput
    data: XOR<LegalCaseUpdateManyMutationInput, LegalCaseUncheckedUpdateManyWithoutAcademyInput>
  }

  export type UserCreateWithoutInstructorInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutInstructorInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutInstructorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
  }

  export type AcademyCreateWithoutInstructorsInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOCreateNestedManyWithoutAcademyInput
    courses?: CourseCreateNestedManyWithoutAcademyInput
    events?: EventCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUncheckedCreateWithoutInstructorsInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOUncheckedCreateNestedManyWithoutAcademyInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademyInput
    events?: EventUncheckedCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryUncheckedCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutAcademyInput
  }

  export type AcademyCreateOrConnectWithoutInstructorsInput = {
    where: AcademyWhereUniqueInput
    create: XOR<AcademyCreateWithoutInstructorsInput, AcademyUncheckedCreateWithoutInstructorsInput>
  }

  export type CourseCreateWithoutInstructorsInput = {
    id?: string
    title: string
    description: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    academy: AcademyCreateNestedOneWithoutCoursesInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCourseInput
    Path?: PathCreateNestedManyWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutInstructorsInput = {
    id?: string
    title: string
    description: string
    academyId: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCourseInput
    Path?: PathUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CourseCreateOrConnectWithoutInstructorsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutInstructorsInput, CourseUncheckedCreateWithoutInstructorsInput>
  }

  export type UserUpsertWithoutInstructorInput = {
    update: XOR<UserUpdateWithoutInstructorInput, UserUncheckedUpdateWithoutInstructorInput>
    create: XOR<UserCreateWithoutInstructorInput, UserUncheckedCreateWithoutInstructorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInstructorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInstructorInput, UserUncheckedUpdateWithoutInstructorInput>
  }

  export type UserUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type AcademyUpsertWithoutInstructorsInput = {
    update: XOR<AcademyUpdateWithoutInstructorsInput, AcademyUncheckedUpdateWithoutInstructorsInput>
    create: XOR<AcademyCreateWithoutInstructorsInput, AcademyUncheckedCreateWithoutInstructorsInput>
    where?: AcademyWhereInput
  }

  export type AcademyUpdateToOneWithWhereWithoutInstructorsInput = {
    where?: AcademyWhereInput
    data: XOR<AcademyUpdateWithoutInstructorsInput, AcademyUncheckedUpdateWithoutInstructorsInput>
  }

  export type AcademyUpdateWithoutInstructorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUpdateManyWithoutAcademyNestedInput
    courses?: CourseUpdateManyWithoutAcademyNestedInput
    events?: EventUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyUncheckedUpdateWithoutInstructorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUncheckedUpdateManyWithoutAcademyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademyNestedInput
    events?: EventUncheckedUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUncheckedUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutAcademyNestedInput
  }

  export type CourseUpsertWithWhereUniqueWithoutInstructorsInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutInstructorsInput, CourseUncheckedUpdateWithoutInstructorsInput>
    create: XOR<CourseCreateWithoutInstructorsInput, CourseUncheckedCreateWithoutInstructorsInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutInstructorsInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutInstructorsInput, CourseUncheckedUpdateWithoutInstructorsInput>
  }

  export type CourseUpdateManyWithWhereWithoutInstructorsInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutInstructorsInput>
  }

  export type AcademyCreateWithoutCoursesInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOCreateNestedManyWithoutAcademyInput
    instructors?: InstructorCreateNestedManyWithoutAcademyInput
    events?: EventCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOUncheckedCreateNestedManyWithoutAcademyInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutAcademyInput
    events?: EventUncheckedCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryUncheckedCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutAcademyInput
  }

  export type AcademyCreateOrConnectWithoutCoursesInput = {
    where: AcademyWhereUniqueInput
    create: XOR<AcademyCreateWithoutCoursesInput, AcademyUncheckedCreateWithoutCoursesInput>
  }

  export type LessonCreateWithoutCourseInput = {
    id?: string
    title: string
    content: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileCreateNestedManyWithoutLessonInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    completedBy?: UserCreateNestedManyWithoutLessonInput
    Attendance?: AttendanceCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    content: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLessonInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    completedBy?: UserUncheckedCreateNestedManyWithoutLessonInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCourseInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput>
  }

  export type LessonCreateManyCourseInputEnvelope = {
    data: LessonCreateManyCourseInput | LessonCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutCourseInput = {
    id?: string
    progress?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    progress?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentCreateManyCourseInputEnvelope = {
    data: EnrollmentCreateManyCourseInput | EnrollmentCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutQuizzesInput
    questions?: QuestionCreateNestedManyWithoutQuizInput
    submissions?: SubmissionCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    lessonId: string
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutQuizInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutCourseInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput>
  }

  export type InstructorCreateWithoutCoursesInput = {
    id?: string
    user: UserCreateNestedOneWithoutInstructorInput
    academy: AcademyCreateNestedOneWithoutInstructorsInput
  }

  export type InstructorUncheckedCreateWithoutCoursesInput = {
    id?: string
    userId: string
    academyId: string
  }

  export type InstructorCreateOrConnectWithoutCoursesInput = {
    where: InstructorWhereUniqueInput
    create: XOR<InstructorCreateWithoutCoursesInput, InstructorUncheckedCreateWithoutCoursesInput>
  }

  export type LiveRoomCreateWithoutCourseInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutLiveRoomInput
    User?: UserCreateNestedManyWithoutLiveRoomInput
  }

  export type LiveRoomUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    communityId: string
    User?: UserUncheckedCreateNestedManyWithoutLiveRoomInput
  }

  export type LiveRoomCreateOrConnectWithoutCourseInput = {
    where: LiveRoomWhereUniqueInput
    create: XOR<LiveRoomCreateWithoutCourseInput, LiveRoomUncheckedCreateWithoutCourseInput>
  }

  export type LiveRoomCreateManyCourseInputEnvelope = {
    data: LiveRoomCreateManyCourseInput | LiveRoomCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type PathCreateWithoutCoursesInput = {
    id?: string
    title: string
    description?: string | null
    level: string
    completedTasks?: number
    remainingTime?: number
    studyTime?: number
    totalTasks?: number
    progress?: number
    engagement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: MilestoneCreateNestedManyWithoutPathInput
    peers?: UserCreateNestedManyWithoutPathInput
  }

  export type PathUncheckedCreateWithoutCoursesInput = {
    id?: string
    title: string
    description?: string | null
    level: string
    completedTasks?: number
    remainingTime?: number
    studyTime?: number
    totalTasks?: number
    progress?: number
    engagement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: MilestoneUncheckedCreateNestedManyWithoutPathInput
    peers?: UserUncheckedCreateNestedManyWithoutPathInput
  }

  export type PathCreateOrConnectWithoutCoursesInput = {
    where: PathWhereUniqueInput
    create: XOR<PathCreateWithoutCoursesInput, PathUncheckedCreateWithoutCoursesInput>
  }

  export type AcademyUpsertWithoutCoursesInput = {
    update: XOR<AcademyUpdateWithoutCoursesInput, AcademyUncheckedUpdateWithoutCoursesInput>
    create: XOR<AcademyCreateWithoutCoursesInput, AcademyUncheckedCreateWithoutCoursesInput>
    where?: AcademyWhereInput
  }

  export type AcademyUpdateToOneWithWhereWithoutCoursesInput = {
    where?: AcademyWhereInput
    data: XOR<AcademyUpdateWithoutCoursesInput, AcademyUncheckedUpdateWithoutCoursesInput>
  }

  export type AcademyUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUpdateManyWithoutAcademyNestedInput
    events?: EventUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUncheckedUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutAcademyNestedInput
    events?: EventUncheckedUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUncheckedUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutAcademyNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutCourseInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutCourseInput, LessonUncheckedUpdateWithoutCourseInput>
    create: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutCourseInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutCourseInput, LessonUncheckedUpdateWithoutCourseInput>
  }

  export type LessonUpdateManyWithWhereWithoutCourseInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutCourseInput>
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<EnrollmentCreateWithoutCourseInput, EnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutCourseInput, EnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type QuizUpsertWithWhereUniqueWithoutCourseInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutCourseInput, QuizUncheckedUpdateWithoutCourseInput>
    create: XOR<QuizCreateWithoutCourseInput, QuizUncheckedCreateWithoutCourseInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutCourseInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutCourseInput, QuizUncheckedUpdateWithoutCourseInput>
  }

  export type QuizUpdateManyWithWhereWithoutCourseInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutCourseInput>
  }

  export type QuizScalarWhereInput = {
    AND?: QuizScalarWhereInput | QuizScalarWhereInput[]
    OR?: QuizScalarWhereInput[]
    NOT?: QuizScalarWhereInput | QuizScalarWhereInput[]
    id?: StringFilter<"Quiz"> | string
    title?: StringFilter<"Quiz"> | string
    description?: StringNullableFilter<"Quiz"> | string | null
    lessonId?: StringFilter<"Quiz"> | string
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    passingScore?: IntNullableFilter<"Quiz"> | number | null
    upComing?: BoolFilter<"Quiz"> | boolean
    isCompleted?: BoolFilter<"Quiz"> | boolean
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
  }

  export type InstructorUpsertWithWhereUniqueWithoutCoursesInput = {
    where: InstructorWhereUniqueInput
    update: XOR<InstructorUpdateWithoutCoursesInput, InstructorUncheckedUpdateWithoutCoursesInput>
    create: XOR<InstructorCreateWithoutCoursesInput, InstructorUncheckedCreateWithoutCoursesInput>
  }

  export type InstructorUpdateWithWhereUniqueWithoutCoursesInput = {
    where: InstructorWhereUniqueInput
    data: XOR<InstructorUpdateWithoutCoursesInput, InstructorUncheckedUpdateWithoutCoursesInput>
  }

  export type InstructorUpdateManyWithWhereWithoutCoursesInput = {
    where: InstructorScalarWhereInput
    data: XOR<InstructorUpdateManyMutationInput, InstructorUncheckedUpdateManyWithoutCoursesInput>
  }

  export type LiveRoomUpsertWithWhereUniqueWithoutCourseInput = {
    where: LiveRoomWhereUniqueInput
    update: XOR<LiveRoomUpdateWithoutCourseInput, LiveRoomUncheckedUpdateWithoutCourseInput>
    create: XOR<LiveRoomCreateWithoutCourseInput, LiveRoomUncheckedCreateWithoutCourseInput>
  }

  export type LiveRoomUpdateWithWhereUniqueWithoutCourseInput = {
    where: LiveRoomWhereUniqueInput
    data: XOR<LiveRoomUpdateWithoutCourseInput, LiveRoomUncheckedUpdateWithoutCourseInput>
  }

  export type LiveRoomUpdateManyWithWhereWithoutCourseInput = {
    where: LiveRoomScalarWhereInput
    data: XOR<LiveRoomUpdateManyMutationInput, LiveRoomUncheckedUpdateManyWithoutCourseInput>
  }

  export type PathUpsertWithWhereUniqueWithoutCoursesInput = {
    where: PathWhereUniqueInput
    update: XOR<PathUpdateWithoutCoursesInput, PathUncheckedUpdateWithoutCoursesInput>
    create: XOR<PathCreateWithoutCoursesInput, PathUncheckedCreateWithoutCoursesInput>
  }

  export type PathUpdateWithWhereUniqueWithoutCoursesInput = {
    where: PathWhereUniqueInput
    data: XOR<PathUpdateWithoutCoursesInput, PathUncheckedUpdateWithoutCoursesInput>
  }

  export type PathUpdateManyWithWhereWithoutCoursesInput = {
    where: PathScalarWhereInput
    data: XOR<PathUpdateManyMutationInput, PathUncheckedUpdateManyWithoutCoursesInput>
  }

  export type MilestoneCreateWithoutPathInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    createdAt?: Date | string
  }

  export type MilestoneUncheckedCreateWithoutPathInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    createdAt?: Date | string
  }

  export type MilestoneCreateOrConnectWithoutPathInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutPathInput, MilestoneUncheckedCreateWithoutPathInput>
  }

  export type MilestoneCreateManyPathInputEnvelope = {
    data: MilestoneCreateManyPathInput | MilestoneCreateManyPathInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutPathInput = {
    id?: string
    title: string
    description: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    academy: AcademyCreateNestedOneWithoutCoursesInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    instructors?: InstructorCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutPathInput = {
    id?: string
    title: string
    description: string
    academyId: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutPathInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutPathInput, CourseUncheckedCreateWithoutPathInput>
  }

  export type UserCreateWithoutPathInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutPathInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutPathInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPathInput, UserUncheckedCreateWithoutPathInput>
  }

  export type MilestoneUpsertWithWhereUniqueWithoutPathInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutPathInput, MilestoneUncheckedUpdateWithoutPathInput>
    create: XOR<MilestoneCreateWithoutPathInput, MilestoneUncheckedCreateWithoutPathInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutPathInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutPathInput, MilestoneUncheckedUpdateWithoutPathInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutPathInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutPathInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    title?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    status?: EnumMilestoneStatusFilter<"Milestone"> | $Enums.MilestoneStatus
    pathId?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
  }

  export type CourseUpsertWithWhereUniqueWithoutPathInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutPathInput, CourseUncheckedUpdateWithoutPathInput>
    create: XOR<CourseCreateWithoutPathInput, CourseUncheckedCreateWithoutPathInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutPathInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutPathInput, CourseUncheckedUpdateWithoutPathInput>
  }

  export type CourseUpdateManyWithWhereWithoutPathInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutPathInput>
  }

  export type UserUpsertWithWhereUniqueWithoutPathInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPathInput, UserUncheckedUpdateWithoutPathInput>
    create: XOR<UserCreateWithoutPathInput, UserUncheckedCreateWithoutPathInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPathInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPathInput, UserUncheckedUpdateWithoutPathInput>
  }

  export type UserUpdateManyWithWhereWithoutPathInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutPathInput>
  }

  export type PathCreateWithoutMilestonesInput = {
    id?: string
    title: string
    description?: string | null
    level: string
    completedTasks?: number
    remainingTime?: number
    studyTime?: number
    totalTasks?: number
    progress?: number
    engagement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseCreateNestedManyWithoutPathInput
    peers?: UserCreateNestedManyWithoutPathInput
  }

  export type PathUncheckedCreateWithoutMilestonesInput = {
    id?: string
    title: string
    description?: string | null
    level: string
    completedTasks?: number
    remainingTime?: number
    studyTime?: number
    totalTasks?: number
    progress?: number
    engagement?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    courses?: CourseUncheckedCreateNestedManyWithoutPathInput
    peers?: UserUncheckedCreateNestedManyWithoutPathInput
  }

  export type PathCreateOrConnectWithoutMilestonesInput = {
    where: PathWhereUniqueInput
    create: XOR<PathCreateWithoutMilestonesInput, PathUncheckedCreateWithoutMilestonesInput>
  }

  export type PathUpsertWithoutMilestonesInput = {
    update: XOR<PathUpdateWithoutMilestonesInput, PathUncheckedUpdateWithoutMilestonesInput>
    create: XOR<PathCreateWithoutMilestonesInput, PathUncheckedCreateWithoutMilestonesInput>
    where?: PathWhereInput
  }

  export type PathUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: PathWhereInput
    data: XOR<PathUpdateWithoutMilestonesInput, PathUncheckedUpdateWithoutMilestonesInput>
  }

  export type PathUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUpdateManyWithoutPathNestedInput
    peers?: UserUpdateManyWithoutPathNestedInput
  }

  export type PathUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courses?: CourseUncheckedUpdateManyWithoutPathNestedInput
    peers?: UserUncheckedUpdateManyWithoutPathNestedInput
  }

  export type CourseCreateWithoutLessonsInput = {
    id?: string
    title: string
    description: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    academy: AcademyCreateNestedOneWithoutCoursesInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    instructors?: InstructorCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCourseInput
    Path?: PathCreateNestedManyWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutLessonsInput = {
    id?: string
    title: string
    description: string
    academyId: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCourseInput
    Path?: PathUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CourseCreateOrConnectWithoutLessonsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
  }

  export type FileCreateWithoutLessonInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    accountingEntry?: AccountingEntryCreateNestedOneWithoutFilesInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutFilesInput
    meeting?: MeetingCreateNestedOneWithoutFilesInput
    adminRole?: AdminRoleCreateNestedOneWithoutFilesInput
    legalCase?: LegalCaseCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutLessonInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    accountingEntryId?: string | null
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutLessonInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutLessonInput, FileUncheckedCreateWithoutLessonInput>
  }

  export type FileCreateManyLessonInputEnvelope = {
    data: FileCreateManyLessonInput | FileCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutLessonInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionCreateNestedManyWithoutQuizInput
    submissions?: SubmissionCreateNestedManyWithoutQuizInput
    Course?: CourseCreateNestedManyWithoutQuizzesInput
  }

  export type QuizUncheckedCreateWithoutLessonInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutQuizInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutQuizInput
    Course?: CourseUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type QuizCreateOrConnectWithoutLessonInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
  }

  export type QuizCreateManyLessonInputEnvelope = {
    data: QuizCreateManyLessonInput | QuizCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutLessonInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutLessonInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutLessonInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonInput, UserUncheckedCreateWithoutLessonInput>
  }

  export type AttendanceCreateWithoutLessonInput = {
    id?: string
    status: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: UserCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutLessonInput = {
    id?: string
    studentId: string
    status: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutLessonInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput>
  }

  export type AttendanceCreateManyLessonInputEnvelope = {
    data: AttendanceCreateManyLessonInput | AttendanceCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutLessonsInput = {
    update: XOR<CourseUpdateWithoutLessonsInput, CourseUncheckedUpdateWithoutLessonsInput>
    create: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLessonsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLessonsInput, CourseUncheckedUpdateWithoutLessonsInput>
  }

  export type CourseUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    academy?: AcademyUpdateOneRequiredWithoutCoursesNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCourseNestedInput
    Path?: PathUpdateManyWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCourseNestedInput
    Path?: PathUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutLessonInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutLessonInput, FileUncheckedUpdateWithoutLessonInput>
    create: XOR<FileCreateWithoutLessonInput, FileUncheckedCreateWithoutLessonInput>
  }

  export type FileUpdateWithWhereUniqueWithoutLessonInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutLessonInput, FileUncheckedUpdateWithoutLessonInput>
  }

  export type FileUpdateManyWithWhereWithoutLessonInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutLessonInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    name?: StringFilter<"File"> | string
    url?: StringFilter<"File"> | string
    type?: EnumFileTypeFilter<"File"> | $Enums.FileType
    lessonId?: StringNullableFilter<"File"> | string | null
    accountingEntryId?: StringNullableFilter<"File"> | string | null
    prRecordId?: StringNullableFilter<"File"> | string | null
    meetingId?: StringNullableFilter<"File"> | string | null
    adminRoleId?: StringNullableFilter<"File"> | string | null
    legalCaseId?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
  }

  export type QuizUpsertWithWhereUniqueWithoutLessonInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutLessonInput, QuizUncheckedUpdateWithoutLessonInput>
    create: XOR<QuizCreateWithoutLessonInput, QuizUncheckedCreateWithoutLessonInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutLessonInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutLessonInput, QuizUncheckedUpdateWithoutLessonInput>
  }

  export type QuizUpdateManyWithWhereWithoutLessonInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutLessonInput>
  }

  export type UserUpsertWithWhereUniqueWithoutLessonInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLessonInput, UserUncheckedUpdateWithoutLessonInput>
    create: XOR<UserCreateWithoutLessonInput, UserUncheckedCreateWithoutLessonInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLessonInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLessonInput, UserUncheckedUpdateWithoutLessonInput>
  }

  export type UserUpdateManyWithWhereWithoutLessonInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLessonInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutLessonInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutLessonInput, AttendanceUncheckedUpdateWithoutLessonInput>
    create: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutLessonInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutLessonInput, AttendanceUncheckedUpdateWithoutLessonInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutLessonInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutLessonInput>
  }

  export type LessonCreateWithoutFilesInput = {
    id?: string
    title: string
    content: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutLessonsInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    completedBy?: UserCreateNestedManyWithoutLessonInput
    Attendance?: AttendanceCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutFilesInput = {
    id?: string
    title: string
    content: string
    courseId: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    completedBy?: UserUncheckedCreateNestedManyWithoutLessonInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutFilesInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutFilesInput, LessonUncheckedCreateWithoutFilesInput>
  }

  export type AccountingEntryCreateWithoutFilesInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutAccountingEntriesInput
    academy: AcademyCreateNestedOneWithoutAccountingEntryInput
    invoice?: InvoiceCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentCreateNestedOneWithoutAccountingEntryInput
    reports?: ReportCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryUncheckedCreateWithoutFilesInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentUncheckedCreateNestedOneWithoutAccountingEntryInput
    reports?: ReportUncheckedCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryCreateOrConnectWithoutFilesInput = {
    where: AccountingEntryWhereUniqueInput
    create: XOR<AccountingEntryCreateWithoutFilesInput, AccountingEntryUncheckedCreateWithoutFilesInput>
  }

  export type PublicRelationsRecordCreateWithoutFilesInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    handledByAdmin: AdminCreateNestedOneWithoutPrRecordsInput
    academy: AcademyCreateNestedOneWithoutPublicRelationsRecordInput
    responses?: PRResponseCreateNestedManyWithoutPrRecordInput
    events?: EventCreateNestedManyWithoutPrRecordInput
    posts?: PostCreateNestedManyWithoutPublicRelationsRecordInput
    channels?: ChannelCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordUncheckedCreateWithoutFilesInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    handledByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: PRResponseUncheckedCreateNestedManyWithoutPrRecordInput
    events?: EventUncheckedCreateNestedManyWithoutPrRecordInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicRelationsRecordInput
    channels?: ChannelUncheckedCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordCreateOrConnectWithoutFilesInput = {
    where: PublicRelationsRecordWhereUniqueInput
    create: XOR<PublicRelationsRecordCreateWithoutFilesInput, PublicRelationsRecordUncheckedCreateWithoutFilesInput>
  }

  export type MeetingCreateWithoutFilesInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutMeetingsInput
    academy: AcademyCreateNestedOneWithoutMeetingInput
    participants?: MeetingParticipantCreateNestedManyWithoutMeetingInput
    reports?: ReportCreateNestedManyWithoutMeetingInput
    channels?: ChannelCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutFilesInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: MeetingParticipantUncheckedCreateNestedManyWithoutMeetingInput
    reports?: ReportUncheckedCreateNestedManyWithoutMeetingInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutFilesInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutFilesInput, MeetingUncheckedCreateWithoutFilesInput>
  }

  export type AdminRoleCreateWithoutFilesInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutAdminRoleInput
    assignments?: AdminAssignmentCreateNestedManyWithoutRoleInput
    permissions?: PermissionCreateNestedManyWithoutAdminRoleInput
    reports?: ReportCreateNestedManyWithoutAdminRoleInput
    events?: EventCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleUncheckedCreateWithoutFilesInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutRoleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutAdminRoleInput
    reports?: ReportUncheckedCreateNestedManyWithoutAdminRoleInput
    events?: EventUncheckedCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelUncheckedCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleCreateOrConnectWithoutFilesInput = {
    where: AdminRoleWhereUniqueInput
    create: XOR<AdminRoleCreateWithoutFilesInput, AdminRoleUncheckedCreateWithoutFilesInput>
  }

  export type LegalCaseCreateWithoutFilesInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedLawyer: AdminCreateNestedOneWithoutLegalCasesInput
    academy: AcademyCreateNestedOneWithoutLegalCaseInput
    relatedUser?: UserCreateNestedOneWithoutLegalCaseInput
    reports?: ReportCreateNestedManyWithoutLegalCaseInput
    events?: EventCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseUncheckedCreateWithoutFilesInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    academyId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutLegalCaseInput
    events?: EventUncheckedCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelUncheckedCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseCreateOrConnectWithoutFilesInput = {
    where: LegalCaseWhereUniqueInput
    create: XOR<LegalCaseCreateWithoutFilesInput, LegalCaseUncheckedCreateWithoutFilesInput>
  }

  export type LessonUpsertWithoutFilesInput = {
    update: XOR<LessonUpdateWithoutFilesInput, LessonUncheckedUpdateWithoutFilesInput>
    create: XOR<LessonCreateWithoutFilesInput, LessonUncheckedCreateWithoutFilesInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutFilesInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutFilesInput, LessonUncheckedUpdateWithoutFilesInput>
  }

  export type LessonUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutLessonsNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    completedBy?: UserUpdateManyWithoutLessonNestedInput
    Attendance?: AttendanceUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    completedBy?: UserUncheckedUpdateManyWithoutLessonNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type AccountingEntryUpsertWithoutFilesInput = {
    update: XOR<AccountingEntryUpdateWithoutFilesInput, AccountingEntryUncheckedUpdateWithoutFilesInput>
    create: XOR<AccountingEntryCreateWithoutFilesInput, AccountingEntryUncheckedCreateWithoutFilesInput>
    where?: AccountingEntryWhereInput
  }

  export type AccountingEntryUpdateToOneWithWhereWithoutFilesInput = {
    where?: AccountingEntryWhereInput
    data: XOR<AccountingEntryUpdateWithoutFilesInput, AccountingEntryUncheckedUpdateWithoutFilesInput>
  }

  export type AccountingEntryUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutAccountingEntriesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutAccountingEntryNestedInput
    invoice?: InvoiceUpdateOneWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUpdateOneWithoutAccountingEntryNestedInput
    reports?: ReportUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AccountingEntryUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUncheckedUpdateOneWithoutAccountingEntryNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAccountingEntryNestedInput
  }

  export type PublicRelationsRecordUpsertWithoutFilesInput = {
    update: XOR<PublicRelationsRecordUpdateWithoutFilesInput, PublicRelationsRecordUncheckedUpdateWithoutFilesInput>
    create: XOR<PublicRelationsRecordCreateWithoutFilesInput, PublicRelationsRecordUncheckedCreateWithoutFilesInput>
    where?: PublicRelationsRecordWhereInput
  }

  export type PublicRelationsRecordUpdateToOneWithWhereWithoutFilesInput = {
    where?: PublicRelationsRecordWhereInput
    data: XOR<PublicRelationsRecordUpdateWithoutFilesInput, PublicRelationsRecordUncheckedUpdateWithoutFilesInput>
  }

  export type PublicRelationsRecordUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledByAdmin?: AdminUpdateOneRequiredWithoutPrRecordsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutPublicRelationsRecordNestedInput
    responses?: PRResponseUpdateManyWithoutPrRecordNestedInput
    events?: EventUpdateManyWithoutPrRecordNestedInput
    posts?: PostUpdateManyWithoutPublicRelationsRecordNestedInput
    channels?: ChannelUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    handledByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PRResponseUncheckedUpdateManyWithoutPrRecordNestedInput
    events?: EventUncheckedUpdateManyWithoutPrRecordNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicRelationsRecordNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutPrRecordNestedInput
  }

  export type MeetingUpsertWithoutFilesInput = {
    update: XOR<MeetingUpdateWithoutFilesInput, MeetingUncheckedUpdateWithoutFilesInput>
    create: XOR<MeetingCreateWithoutFilesInput, MeetingUncheckedCreateWithoutFilesInput>
    where?: MeetingWhereInput
  }

  export type MeetingUpdateToOneWithWhereWithoutFilesInput = {
    where?: MeetingWhereInput
    data: XOR<MeetingUpdateWithoutFilesInput, MeetingUncheckedUpdateWithoutFilesInput>
  }

  export type MeetingUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutMeetingsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutMeetingNestedInput
    participants?: MeetingParticipantUpdateManyWithoutMeetingNestedInput
    reports?: ReportUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MeetingParticipantUncheckedUpdateManyWithoutMeetingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type AdminRoleUpsertWithoutFilesInput = {
    update: XOR<AdminRoleUpdateWithoutFilesInput, AdminRoleUncheckedUpdateWithoutFilesInput>
    create: XOR<AdminRoleCreateWithoutFilesInput, AdminRoleUncheckedCreateWithoutFilesInput>
    where?: AdminRoleWhereInput
  }

  export type AdminRoleUpdateToOneWithWhereWithoutFilesInput = {
    where?: AdminRoleWhereInput
    data: XOR<AdminRoleUpdateWithoutFilesInput, AdminRoleUncheckedUpdateWithoutFilesInput>
  }

  export type AdminRoleUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutAdminRoleNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUpdateManyWithoutAdminRoleNestedInput
    events?: EventUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAdminRoleNestedInput
    events?: EventUncheckedUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutAdminRoleNestedInput
  }

  export type LegalCaseUpsertWithoutFilesInput = {
    update: XOR<LegalCaseUpdateWithoutFilesInput, LegalCaseUncheckedUpdateWithoutFilesInput>
    create: XOR<LegalCaseCreateWithoutFilesInput, LegalCaseUncheckedCreateWithoutFilesInput>
    where?: LegalCaseWhereInput
  }

  export type LegalCaseUpdateToOneWithWhereWithoutFilesInput = {
    where?: LegalCaseWhereInput
    data: XOR<LegalCaseUpdateWithoutFilesInput, LegalCaseUncheckedUpdateWithoutFilesInput>
  }

  export type LegalCaseUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedLawyer?: AdminUpdateOneRequiredWithoutLegalCasesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutLegalCaseNestedInput
    relatedUser?: UserUpdateOneWithoutLegalCaseNestedInput
    reports?: ReportUpdateManyWithoutLegalCaseNestedInput
    events?: EventUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutLegalCaseNestedInput
    events?: EventUncheckedUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLegalCaseNestedInput
  }

  export type UserCreateWithoutEnrollmentsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    academy: AcademyCreateNestedOneWithoutCoursesInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    instructors?: InstructorCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCourseInput
    Path?: PathCreateNestedManyWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    academyId: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCourseInput
    Path?: PathUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserUpsertWithoutEnrollmentsInput = {
    update: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    academy?: AcademyUpdateOneRequiredWithoutCoursesNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCourseNestedInput
    Path?: PathUpdateManyWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCourseNestedInput
    Path?: PathUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type LessonCreateWithoutQuizzesInput = {
    id?: string
    title: string
    content: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutLessonsInput
    files?: FileCreateNestedManyWithoutLessonInput
    completedBy?: UserCreateNestedManyWithoutLessonInput
    Attendance?: AttendanceCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutQuizzesInput = {
    id?: string
    title: string
    content: string
    courseId: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLessonInput
    completedBy?: UserUncheckedCreateNestedManyWithoutLessonInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutQuizzesInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
  }

  export type QuestionCreateWithoutQuizInput = {
    id?: string
    text: string
    type: string
    isMultiple?: boolean
    points: number
    isAnswered?: boolean
    createdAt?: Date | string
    options?: OptionCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutQuizInput = {
    id?: string
    text: string
    type: string
    isMultiple?: boolean
    points: number
    isAnswered?: boolean
    createdAt?: Date | string
    options?: OptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutQuizInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuestionCreateManyQuizInputEnvelope = {
    data: QuestionCreateManyQuizInput | QuestionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionCreateWithoutQuizInput = {
    id?: string
    answers?: SubmissionCreateanswersInput | InputJsonValue[]
    score?: number | null
    feedback?: string | null
    passed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubmissionInput
  }

  export type SubmissionUncheckedCreateWithoutQuizInput = {
    id?: string
    userId: string
    answers?: SubmissionCreateanswersInput | InputJsonValue[]
    score?: number | null
    feedback?: string | null
    passed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubmissionCreateOrConnectWithoutQuizInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutQuizInput, SubmissionUncheckedCreateWithoutQuizInput>
  }

  export type SubmissionCreateManyQuizInputEnvelope = {
    data: SubmissionCreateManyQuizInput | SubmissionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutQuizzesInput = {
    id?: string
    title: string
    description: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    academy: AcademyCreateNestedOneWithoutCoursesInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    instructors?: InstructorCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCourseInput
    Path?: PathCreateNestedManyWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutQuizzesInput = {
    id?: string
    title: string
    description: string
    academyId: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutCoursesInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCourseInput
    Path?: PathUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CourseCreateOrConnectWithoutQuizzesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutQuizzesInput, CourseUncheckedCreateWithoutQuizzesInput>
  }

  export type LessonUpsertWithoutQuizzesInput = {
    update: XOR<LessonUpdateWithoutQuizzesInput, LessonUncheckedUpdateWithoutQuizzesInput>
    create: XOR<LessonCreateWithoutQuizzesInput, LessonUncheckedCreateWithoutQuizzesInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutQuizzesInput, LessonUncheckedUpdateWithoutQuizzesInput>
  }

  export type LessonUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutLessonsNestedInput
    files?: FileUpdateManyWithoutLessonNestedInput
    completedBy?: UserUpdateManyWithoutLessonNestedInput
    Attendance?: AttendanceUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLessonNestedInput
    completedBy?: UserUncheckedUpdateManyWithoutLessonNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type QuestionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutQuizInput, QuestionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuestionCreateWithoutQuizInput, QuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutQuizInput, QuestionUncheckedUpdateWithoutQuizInput>
  }

  export type QuestionUpdateManyWithWhereWithoutQuizInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    type?: StringFilter<"Question"> | string
    isMultiple?: BoolFilter<"Question"> | boolean
    points?: IntFilter<"Question"> | number
    isAnswered?: BoolFilter<"Question"> | boolean
    quizId?: StringFilter<"Question"> | string
    createdAt?: DateTimeFilter<"Question"> | Date | string
  }

  export type SubmissionUpsertWithWhereUniqueWithoutQuizInput = {
    where: SubmissionWhereUniqueInput
    update: XOR<SubmissionUpdateWithoutQuizInput, SubmissionUncheckedUpdateWithoutQuizInput>
    create: XOR<SubmissionCreateWithoutQuizInput, SubmissionUncheckedCreateWithoutQuizInput>
  }

  export type SubmissionUpdateWithWhereUniqueWithoutQuizInput = {
    where: SubmissionWhereUniqueInput
    data: XOR<SubmissionUpdateWithoutQuizInput, SubmissionUncheckedUpdateWithoutQuizInput>
  }

  export type SubmissionUpdateManyWithWhereWithoutQuizInput = {
    where: SubmissionScalarWhereInput
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutQuizInput>
  }

  export type CourseUpsertWithWhereUniqueWithoutQuizzesInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutQuizzesInput, CourseUncheckedUpdateWithoutQuizzesInput>
    create: XOR<CourseCreateWithoutQuizzesInput, CourseUncheckedCreateWithoutQuizzesInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutQuizzesInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutQuizzesInput, CourseUncheckedUpdateWithoutQuizzesInput>
  }

  export type CourseUpdateManyWithWhereWithoutQuizzesInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutQuizzesInput>
  }

  export type OptionCreateWithoutQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionUncheckedCreateWithoutQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionCreateOrConnectWithoutQuestionInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput>
  }

  export type OptionCreateManyQuestionInputEnvelope = {
    data: OptionCreateManyQuestionInput | OptionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutQuizzesInput
    submissions?: SubmissionCreateNestedManyWithoutQuizInput
    Course?: CourseCreateNestedManyWithoutQuizzesInput
  }

  export type QuizUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    lessonId: string
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: SubmissionUncheckedCreateNestedManyWithoutQuizInput
    Course?: CourseUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type QuizCreateOrConnectWithoutQuestionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
  }

  export type OptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: OptionWhereUniqueInput
    update: XOR<OptionUpdateWithoutQuestionInput, OptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<OptionCreateWithoutQuestionInput, OptionUncheckedCreateWithoutQuestionInput>
  }

  export type OptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: OptionWhereUniqueInput
    data: XOR<OptionUpdateWithoutQuestionInput, OptionUncheckedUpdateWithoutQuestionInput>
  }

  export type OptionUpdateManyWithWhereWithoutQuestionInput = {
    where: OptionScalarWhereInput
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type OptionScalarWhereInput = {
    AND?: OptionScalarWhereInput | OptionScalarWhereInput[]
    OR?: OptionScalarWhereInput[]
    NOT?: OptionScalarWhereInput | OptionScalarWhereInput[]
    id?: StringFilter<"Option"> | string
    questionId?: StringFilter<"Option"> | string
    text?: StringFilter<"Option"> | string
    isCorrect?: BoolFilter<"Option"> | boolean
    createdAt?: DateTimeFilter<"Option"> | Date | string
    updatedAt?: DateTimeFilter<"Option"> | Date | string
  }

  export type QuizUpsertWithoutQuestionsInput = {
    update: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
    submissions?: SubmissionUpdateManyWithoutQuizNestedInput
    Course?: CourseUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: StringFieldUpdateOperationsInput | string
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: SubmissionUncheckedUpdateManyWithoutQuizNestedInput
    Course?: CourseUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type QuestionCreateWithoutOptionsInput = {
    id?: string
    text: string
    type: string
    isMultiple?: boolean
    points: number
    isAnswered?: boolean
    createdAt?: Date | string
    quiz: QuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionUncheckedCreateWithoutOptionsInput = {
    id?: string
    text: string
    type: string
    isMultiple?: boolean
    points: number
    isAnswered?: boolean
    quizId: string
    createdAt?: Date | string
  }

  export type QuestionCreateOrConnectWithoutOptionsInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
  }

  export type QuestionUpsertWithoutOptionsInput = {
    update: XOR<QuestionUpdateWithoutOptionsInput, QuestionUncheckedUpdateWithoutOptionsInput>
    create: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutOptionsInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutOptionsInput, QuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type QuestionUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    isAnswered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    isAnswered?: BoolFieldUpdateOperationsInput | boolean
    quizId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSubmissionInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutSubmissionInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutSubmissionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubmissionInput, UserUncheckedCreateWithoutSubmissionInput>
  }

  export type QuizCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lesson: LessonCreateNestedOneWithoutQuizzesInput
    questions?: QuestionCreateNestedManyWithoutQuizInput
    Course?: CourseCreateNestedManyWithoutQuizzesInput
  }

  export type QuizUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description?: string | null
    lessonId: string
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutQuizInput
    Course?: CourseUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type QuizCreateOrConnectWithoutSubmissionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutSubmissionsInput, QuizUncheckedCreateWithoutSubmissionsInput>
  }

  export type UserUpsertWithoutSubmissionInput = {
    update: XOR<UserUpdateWithoutSubmissionInput, UserUncheckedUpdateWithoutSubmissionInput>
    create: XOR<UserCreateWithoutSubmissionInput, UserUncheckedCreateWithoutSubmissionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubmissionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubmissionInput, UserUncheckedUpdateWithoutSubmissionInput>
  }

  export type UserUpdateWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type QuizUpsertWithoutSubmissionsInput = {
    update: XOR<QuizUpdateWithoutSubmissionsInput, QuizUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<QuizCreateWithoutSubmissionsInput, QuizUncheckedCreateWithoutSubmissionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutSubmissionsInput, QuizUncheckedUpdateWithoutSubmissionsInput>
  }

  export type QuizUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
    questions?: QuestionUpdateManyWithoutQuizNestedInput
    Course?: CourseUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: StringFieldUpdateOperationsInput | string
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutQuizNestedInput
    Course?: CourseUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserCreateWithoutNotificationSettingsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutNotificationSettingsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutNotificationSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
  }

  export type UserUpsertWithoutNotificationSettingsInput = {
    update: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
    create: XOR<UserCreateWithoutNotificationSettingsInput, UserUncheckedCreateWithoutNotificationSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationSettingsInput, UserUncheckedUpdateWithoutNotificationSettingsInput>
  }

  export type UserUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ChannelCreateWithoutMessagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutChannelsInput
    owner: OwnerCreateNestedOneWithoutChannelInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutChannelsInput
    meeting?: MeetingCreateNestedOneWithoutChannelsInput
    adminRole?: AdminRoleCreateNestedOneWithoutChannelsInput
    legalCase?: LegalCaseCreateNestedOneWithoutChannelsInput
  }

  export type ChannelUncheckedCreateWithoutMessagesInput = {
    id?: string
    name: string
    ownerId: string
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutChannelsInput
  }

  export type ChannelCreateOrConnectWithoutMessagesInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type ChannelUpsertWithWhereUniqueWithoutMessagesInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutMessagesInput, ChannelUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChannelCreateWithoutMessagesInput, ChannelUncheckedCreateWithoutMessagesInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutMessagesInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutMessagesInput, ChannelUncheckedUpdateWithoutMessagesInput>
  }

  export type ChannelUpdateManyWithWhereWithoutMessagesInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutMessagesInput>
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type GroupCreateWithoutPostsInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutGroupsInput
    admin: AdminCreateNestedOneWithoutGroupInput
    Community?: CommunityCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    adminId: string
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutGroupsInput
    Community?: CommunityUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupCreateOrConnectWithoutPostsInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutPostsInput, GroupUncheckedCreateWithoutPostsInput>
  }

  export type CommunityCreateWithoutPostsInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupCreateNestedManyWithoutCommunityInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCommunityInput
    participants?: UserCreateNestedManyWithoutCommunityInput
    discussions?: DiscussionCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupUncheckedCreateNestedManyWithoutCommunityInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCommunityInput
    participants?: UserUncheckedCreateNestedManyWithoutCommunityInput
    discussions?: DiscussionUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutPostsInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput>
  }

  export type DiscussionCreateWithoutPostInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutDiscussionsInput
  }

  export type DiscussionUncheckedCreateWithoutPostInput = {
    id?: string
    communityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscussionCreateOrConnectWithoutPostInput = {
    where: DiscussionWhereUniqueInput
    create: XOR<DiscussionCreateWithoutPostInput, DiscussionUncheckedCreateWithoutPostInput>
  }

  export type DiscussionCreateManyPostInputEnvelope = {
    data: DiscussionCreateManyPostInput | DiscussionCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PublicRelationsRecordCreateWithoutPostsInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    handledByAdmin: AdminCreateNestedOneWithoutPrRecordsInput
    academy: AcademyCreateNestedOneWithoutPublicRelationsRecordInput
    responses?: PRResponseCreateNestedManyWithoutPrRecordInput
    events?: EventCreateNestedManyWithoutPrRecordInput
    files?: FileCreateNestedManyWithoutPrRecordInput
    channels?: ChannelCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordUncheckedCreateWithoutPostsInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    handledByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: PRResponseUncheckedCreateNestedManyWithoutPrRecordInput
    events?: EventUncheckedCreateNestedManyWithoutPrRecordInput
    files?: FileUncheckedCreateNestedManyWithoutPrRecordInput
    channels?: ChannelUncheckedCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordCreateOrConnectWithoutPostsInput = {
    where: PublicRelationsRecordWhereUniqueInput
    create: XOR<PublicRelationsRecordCreateWithoutPostsInput, PublicRelationsRecordUncheckedCreateWithoutPostsInput>
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type GroupUpsertWithWhereUniqueWithoutPostsInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutPostsInput, GroupUncheckedUpdateWithoutPostsInput>
    create: XOR<GroupCreateWithoutPostsInput, GroupUncheckedCreateWithoutPostsInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutPostsInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutPostsInput, GroupUncheckedUpdateWithoutPostsInput>
  }

  export type GroupUpdateManyWithWhereWithoutPostsInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutPostsInput>
  }

  export type CommunityUpsertWithWhereUniqueWithoutPostsInput = {
    where: CommunityWhereUniqueInput
    update: XOR<CommunityUpdateWithoutPostsInput, CommunityUncheckedUpdateWithoutPostsInput>
    create: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput>
  }

  export type CommunityUpdateWithWhereUniqueWithoutPostsInput = {
    where: CommunityWhereUniqueInput
    data: XOR<CommunityUpdateWithoutPostsInput, CommunityUncheckedUpdateWithoutPostsInput>
  }

  export type CommunityUpdateManyWithWhereWithoutPostsInput = {
    where: CommunityScalarWhereInput
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyWithoutPostsInput>
  }

  export type DiscussionUpsertWithWhereUniqueWithoutPostInput = {
    where: DiscussionWhereUniqueInput
    update: XOR<DiscussionUpdateWithoutPostInput, DiscussionUncheckedUpdateWithoutPostInput>
    create: XOR<DiscussionCreateWithoutPostInput, DiscussionUncheckedCreateWithoutPostInput>
  }

  export type DiscussionUpdateWithWhereUniqueWithoutPostInput = {
    where: DiscussionWhereUniqueInput
    data: XOR<DiscussionUpdateWithoutPostInput, DiscussionUncheckedUpdateWithoutPostInput>
  }

  export type DiscussionUpdateManyWithWhereWithoutPostInput = {
    where: DiscussionScalarWhereInput
    data: XOR<DiscussionUpdateManyMutationInput, DiscussionUncheckedUpdateManyWithoutPostInput>
  }

  export type DiscussionScalarWhereInput = {
    AND?: DiscussionScalarWhereInput | DiscussionScalarWhereInput[]
    OR?: DiscussionScalarWhereInput[]
    NOT?: DiscussionScalarWhereInput | DiscussionScalarWhereInput[]
    id?: StringFilter<"Discussion"> | string
    communityId?: StringFilter<"Discussion"> | string
    postId?: StringNullableFilter<"Discussion"> | string | null
    createdAt?: DateTimeFilter<"Discussion"> | Date | string
    updatedAt?: DateTimeFilter<"Discussion"> | Date | string
  }

  export type PublicRelationsRecordUpsertWithoutPostsInput = {
    update: XOR<PublicRelationsRecordUpdateWithoutPostsInput, PublicRelationsRecordUncheckedUpdateWithoutPostsInput>
    create: XOR<PublicRelationsRecordCreateWithoutPostsInput, PublicRelationsRecordUncheckedCreateWithoutPostsInput>
    where?: PublicRelationsRecordWhereInput
  }

  export type PublicRelationsRecordUpdateToOneWithWhereWithoutPostsInput = {
    where?: PublicRelationsRecordWhereInput
    data: XOR<PublicRelationsRecordUpdateWithoutPostsInput, PublicRelationsRecordUncheckedUpdateWithoutPostsInput>
  }

  export type PublicRelationsRecordUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledByAdmin?: AdminUpdateOneRequiredWithoutPrRecordsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutPublicRelationsRecordNestedInput
    responses?: PRResponseUpdateManyWithoutPrRecordNestedInput
    events?: EventUpdateManyWithoutPrRecordNestedInput
    files?: FileUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    handledByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PRResponseUncheckedUpdateManyWithoutPrRecordNestedInput
    events?: EventUncheckedUpdateManyWithoutPrRecordNestedInput
    files?: FileUncheckedUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutPrRecordNestedInput
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    author: UserCreateNestedOneWithoutPostsInput
    Group?: GroupCreateNestedManyWithoutPostsInput
    Community?: CommunityCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionCreateNestedManyWithoutPostInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    publicRelationsRecordId?: string | null
    Group?: GroupUncheckedCreateNestedManyWithoutPostsInput
    Community?: CommunityUncheckedCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    Group?: GroupUpdateManyWithoutPostsNestedInput
    Community?: CommunityUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUpdateManyWithoutPostNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    publicRelationsRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    Group?: GroupUncheckedUpdateManyWithoutPostsNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserCreateWithoutGroupsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutGroupsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type PostCreateWithoutGroupInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    author: UserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    Community?: CommunityCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionCreateNestedManyWithoutPostInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutGroupInput = {
    id?: string
    authorId: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    publicRelationsRecordId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    Community?: CommunityUncheckedCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutGroupInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutGroupInput, PostUncheckedCreateWithoutGroupInput>
  }

  export type AdminCreateWithoutGroupInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordUncheckedCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseUncheckedCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseUncheckedCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutGroupInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutGroupInput, AdminUncheckedCreateWithoutGroupInput>
  }

  export type CommunityCreateWithoutGroupsInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    liveRoom?: LiveRoomCreateNestedManyWithoutCommunityInput
    participants?: UserCreateNestedManyWithoutCommunityInput
    posts?: PostCreateNestedManyWithoutCommunityInput
    discussions?: DiscussionCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutGroupsInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCommunityInput
    participants?: UserUncheckedCreateNestedManyWithoutCommunityInput
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
    discussions?: DiscussionUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutGroupsInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutGroupsInput, CommunityUncheckedCreateWithoutGroupsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutGroupsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
    create: XOR<UserCreateWithoutGroupsInput, UserUncheckedCreateWithoutGroupsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutGroupsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutGroupsInput, UserUncheckedUpdateWithoutGroupsInput>
  }

  export type UserUpdateManyWithWhereWithoutGroupsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutGroupsInput>
  }

  export type PostUpsertWithWhereUniqueWithoutGroupInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutGroupInput, PostUncheckedUpdateWithoutGroupInput>
    create: XOR<PostCreateWithoutGroupInput, PostUncheckedCreateWithoutGroupInput>
  }

  export type PostUpdateWithWhereUniqueWithoutGroupInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutGroupInput, PostUncheckedUpdateWithoutGroupInput>
  }

  export type PostUpdateManyWithWhereWithoutGroupInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutGroupInput>
  }

  export type AdminUpsertWithoutGroupInput = {
    update: XOR<AdminUpdateWithoutGroupInput, AdminUncheckedUpdateWithoutGroupInput>
    create: XOR<AdminCreateWithoutGroupInput, AdminUncheckedCreateWithoutGroupInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutGroupInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutGroupInput, AdminUncheckedUpdateWithoutGroupInput>
  }

  export type AdminUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUncheckedUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUncheckedUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type CommunityUpsertWithWhereUniqueWithoutGroupsInput = {
    where: CommunityWhereUniqueInput
    update: XOR<CommunityUpdateWithoutGroupsInput, CommunityUncheckedUpdateWithoutGroupsInput>
    create: XOR<CommunityCreateWithoutGroupsInput, CommunityUncheckedCreateWithoutGroupsInput>
  }

  export type CommunityUpdateWithWhereUniqueWithoutGroupsInput = {
    where: CommunityWhereUniqueInput
    data: XOR<CommunityUpdateWithoutGroupsInput, CommunityUncheckedUpdateWithoutGroupsInput>
  }

  export type CommunityUpdateManyWithWhereWithoutGroupsInput = {
    where: CommunityScalarWhereInput
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyWithoutGroupsInput>
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type GroupCreateWithoutAdminInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutGroupsInput
    posts?: PostCreateNestedManyWithoutGroupInput
    Community?: CommunityCreateNestedManyWithoutGroupsInput
  }

  export type GroupUncheckedCreateWithoutAdminInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutGroupsInput
    posts?: PostUncheckedCreateNestedManyWithoutGroupInput
    Community?: CommunityUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupCreateOrConnectWithoutAdminInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutAdminInput, GroupUncheckedCreateWithoutAdminInput>
  }

  export type GroupCreateManyAdminInputEnvelope = {
    data: GroupCreateManyAdminInput | GroupCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AccountingEntryCreateWithoutCreatedByAdminInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    academy: AcademyCreateNestedOneWithoutAccountingEntryInput
    invoice?: InvoiceCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentCreateNestedOneWithoutAccountingEntryInput
    files?: FileCreateNestedManyWithoutAccountingEntryInput
    reports?: ReportCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryUncheckedCreateWithoutCreatedByAdminInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentUncheckedCreateNestedOneWithoutAccountingEntryInput
    files?: FileUncheckedCreateNestedManyWithoutAccountingEntryInput
    reports?: ReportUncheckedCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryCreateOrConnectWithoutCreatedByAdminInput = {
    where: AccountingEntryWhereUniqueInput
    create: XOR<AccountingEntryCreateWithoutCreatedByAdminInput, AccountingEntryUncheckedCreateWithoutCreatedByAdminInput>
  }

  export type AccountingEntryCreateManyCreatedByAdminInputEnvelope = {
    data: AccountingEntryCreateManyCreatedByAdminInput | AccountingEntryCreateManyCreatedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type PublicRelationsRecordCreateWithoutHandledByAdminInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    academy: AcademyCreateNestedOneWithoutPublicRelationsRecordInput
    responses?: PRResponseCreateNestedManyWithoutPrRecordInput
    events?: EventCreateNestedManyWithoutPrRecordInput
    posts?: PostCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileCreateNestedManyWithoutPrRecordInput
    channels?: ChannelCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: PRResponseUncheckedCreateNestedManyWithoutPrRecordInput
    events?: EventUncheckedCreateNestedManyWithoutPrRecordInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileUncheckedCreateNestedManyWithoutPrRecordInput
    channels?: ChannelUncheckedCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordCreateOrConnectWithoutHandledByAdminInput = {
    where: PublicRelationsRecordWhereUniqueInput
    create: XOR<PublicRelationsRecordCreateWithoutHandledByAdminInput, PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput>
  }

  export type PublicRelationsRecordCreateManyHandledByAdminInputEnvelope = {
    data: PublicRelationsRecordCreateManyHandledByAdminInput | PublicRelationsRecordCreateManyHandledByAdminInput[]
    skipDuplicates?: boolean
  }

  export type PRResponseCreateWithoutRespondedByAdminInput = {
    id?: string
    response: string
    createdAt?: Date | string
    prRecord: PublicRelationsRecordCreateNestedOneWithoutResponsesInput
  }

  export type PRResponseUncheckedCreateWithoutRespondedByAdminInput = {
    id?: string
    response: string
    prRecordId: string
    createdAt?: Date | string
  }

  export type PRResponseCreateOrConnectWithoutRespondedByAdminInput = {
    where: PRResponseWhereUniqueInput
    create: XOR<PRResponseCreateWithoutRespondedByAdminInput, PRResponseUncheckedCreateWithoutRespondedByAdminInput>
  }

  export type PRResponseCreateManyRespondedByAdminInputEnvelope = {
    data: PRResponseCreateManyRespondedByAdminInput | PRResponseCreateManyRespondedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutCreatedByAdminInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academy: AcademyCreateNestedOneWithoutMeetingInput
    participants?: MeetingParticipantCreateNestedManyWithoutMeetingInput
    files?: FileCreateNestedManyWithoutMeetingInput
    reports?: ReportCreateNestedManyWithoutMeetingInput
    channels?: ChannelCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutCreatedByAdminInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: MeetingParticipantUncheckedCreateNestedManyWithoutMeetingInput
    files?: FileUncheckedCreateNestedManyWithoutMeetingInput
    reports?: ReportUncheckedCreateNestedManyWithoutMeetingInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutCreatedByAdminInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutCreatedByAdminInput, MeetingUncheckedCreateWithoutCreatedByAdminInput>
  }

  export type MeetingCreateManyCreatedByAdminInputEnvelope = {
    data: MeetingCreateManyCreatedByAdminInput | MeetingCreateManyCreatedByAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminAssignmentCreateWithoutAdminInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: AdminRoleCreateNestedOneWithoutAssignmentsInput
  }

  export type AdminAssignmentUncheckedCreateWithoutAdminInput = {
    id?: string
    roleId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminAssignmentCreateOrConnectWithoutAdminInput = {
    where: AdminAssignmentWhereUniqueInput
    create: XOR<AdminAssignmentCreateWithoutAdminInput, AdminAssignmentUncheckedCreateWithoutAdminInput>
  }

  export type AdminAssignmentCreateManyAdminInputEnvelope = {
    data: AdminAssignmentCreateManyAdminInput | AdminAssignmentCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type LegalCaseCreateWithoutAssignedLawyerInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academy: AcademyCreateNestedOneWithoutLegalCaseInput
    relatedUser?: UserCreateNestedOneWithoutLegalCaseInput
    files?: FileCreateNestedManyWithoutLegalCaseInput
    reports?: ReportCreateNestedManyWithoutLegalCaseInput
    events?: EventCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseUncheckedCreateWithoutAssignedLawyerInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    academyId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLegalCaseInput
    reports?: ReportUncheckedCreateNestedManyWithoutLegalCaseInput
    events?: EventUncheckedCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelUncheckedCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseCreateOrConnectWithoutAssignedLawyerInput = {
    where: LegalCaseWhereUniqueInput
    create: XOR<LegalCaseCreateWithoutAssignedLawyerInput, LegalCaseUncheckedCreateWithoutAssignedLawyerInput>
  }

  export type LegalCaseCreateManyAssignedLawyerInputEnvelope = {
    data: LegalCaseCreateManyAssignedLawyerInput | LegalCaseCreateManyAssignedLawyerInput[]
    skipDuplicates?: boolean
  }

  export type AdminRoleCreateWithoutAdminInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AdminAssignmentCreateNestedManyWithoutRoleInput
    permissions?: PermissionCreateNestedManyWithoutAdminRoleInput
    reports?: ReportCreateNestedManyWithoutAdminRoleInput
    files?: FileCreateNestedManyWithoutAdminRoleInput
    events?: EventCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleUncheckedCreateWithoutAdminInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutRoleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutAdminRoleInput
    reports?: ReportUncheckedCreateNestedManyWithoutAdminRoleInput
    files?: FileUncheckedCreateNestedManyWithoutAdminRoleInput
    events?: EventUncheckedCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelUncheckedCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleCreateOrConnectWithoutAdminInput = {
    where: AdminRoleWhereUniqueInput
    create: XOR<AdminRoleCreateWithoutAdminInput, AdminRoleUncheckedCreateWithoutAdminInput>
  }

  export type AdminRoleCreateManyAdminInputEnvelope = {
    data: AdminRoleCreateManyAdminInput | AdminRoleCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type GroupUpsertWithWhereUniqueWithoutAdminInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutAdminInput, GroupUncheckedUpdateWithoutAdminInput>
    create: XOR<GroupCreateWithoutAdminInput, GroupUncheckedCreateWithoutAdminInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutAdminInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutAdminInput, GroupUncheckedUpdateWithoutAdminInput>
  }

  export type GroupUpdateManyWithWhereWithoutAdminInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutAdminInput>
  }

  export type AccountingEntryUpsertWithWhereUniqueWithoutCreatedByAdminInput = {
    where: AccountingEntryWhereUniqueInput
    update: XOR<AccountingEntryUpdateWithoutCreatedByAdminInput, AccountingEntryUncheckedUpdateWithoutCreatedByAdminInput>
    create: XOR<AccountingEntryCreateWithoutCreatedByAdminInput, AccountingEntryUncheckedCreateWithoutCreatedByAdminInput>
  }

  export type AccountingEntryUpdateWithWhereUniqueWithoutCreatedByAdminInput = {
    where: AccountingEntryWhereUniqueInput
    data: XOR<AccountingEntryUpdateWithoutCreatedByAdminInput, AccountingEntryUncheckedUpdateWithoutCreatedByAdminInput>
  }

  export type AccountingEntryUpdateManyWithWhereWithoutCreatedByAdminInput = {
    where: AccountingEntryScalarWhereInput
    data: XOR<AccountingEntryUpdateManyMutationInput, AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminInput>
  }

  export type PublicRelationsRecordUpsertWithWhereUniqueWithoutHandledByAdminInput = {
    where: PublicRelationsRecordWhereUniqueInput
    update: XOR<PublicRelationsRecordUpdateWithoutHandledByAdminInput, PublicRelationsRecordUncheckedUpdateWithoutHandledByAdminInput>
    create: XOR<PublicRelationsRecordCreateWithoutHandledByAdminInput, PublicRelationsRecordUncheckedCreateWithoutHandledByAdminInput>
  }

  export type PublicRelationsRecordUpdateWithWhereUniqueWithoutHandledByAdminInput = {
    where: PublicRelationsRecordWhereUniqueInput
    data: XOR<PublicRelationsRecordUpdateWithoutHandledByAdminInput, PublicRelationsRecordUncheckedUpdateWithoutHandledByAdminInput>
  }

  export type PublicRelationsRecordUpdateManyWithWhereWithoutHandledByAdminInput = {
    where: PublicRelationsRecordScalarWhereInput
    data: XOR<PublicRelationsRecordUpdateManyMutationInput, PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminInput>
  }

  export type PRResponseUpsertWithWhereUniqueWithoutRespondedByAdminInput = {
    where: PRResponseWhereUniqueInput
    update: XOR<PRResponseUpdateWithoutRespondedByAdminInput, PRResponseUncheckedUpdateWithoutRespondedByAdminInput>
    create: XOR<PRResponseCreateWithoutRespondedByAdminInput, PRResponseUncheckedCreateWithoutRespondedByAdminInput>
  }

  export type PRResponseUpdateWithWhereUniqueWithoutRespondedByAdminInput = {
    where: PRResponseWhereUniqueInput
    data: XOR<PRResponseUpdateWithoutRespondedByAdminInput, PRResponseUncheckedUpdateWithoutRespondedByAdminInput>
  }

  export type PRResponseUpdateManyWithWhereWithoutRespondedByAdminInput = {
    where: PRResponseScalarWhereInput
    data: XOR<PRResponseUpdateManyMutationInput, PRResponseUncheckedUpdateManyWithoutRespondedByAdminInput>
  }

  export type PRResponseScalarWhereInput = {
    AND?: PRResponseScalarWhereInput | PRResponseScalarWhereInput[]
    OR?: PRResponseScalarWhereInput[]
    NOT?: PRResponseScalarWhereInput | PRResponseScalarWhereInput[]
    id?: StringFilter<"PRResponse"> | string
    response?: StringFilter<"PRResponse"> | string
    prRecordId?: StringFilter<"PRResponse"> | string
    respondedByAdminId?: StringFilter<"PRResponse"> | string
    createdAt?: DateTimeFilter<"PRResponse"> | Date | string
  }

  export type MeetingUpsertWithWhereUniqueWithoutCreatedByAdminInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutCreatedByAdminInput, MeetingUncheckedUpdateWithoutCreatedByAdminInput>
    create: XOR<MeetingCreateWithoutCreatedByAdminInput, MeetingUncheckedCreateWithoutCreatedByAdminInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutCreatedByAdminInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutCreatedByAdminInput, MeetingUncheckedUpdateWithoutCreatedByAdminInput>
  }

  export type MeetingUpdateManyWithWhereWithoutCreatedByAdminInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutCreatedByAdminInput>
  }

  export type AdminAssignmentUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAssignmentWhereUniqueInput
    update: XOR<AdminAssignmentUpdateWithoutAdminInput, AdminAssignmentUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAssignmentCreateWithoutAdminInput, AdminAssignmentUncheckedCreateWithoutAdminInput>
  }

  export type AdminAssignmentUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAssignmentWhereUniqueInput
    data: XOR<AdminAssignmentUpdateWithoutAdminInput, AdminAssignmentUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAssignmentUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAssignmentScalarWhereInput
    data: XOR<AdminAssignmentUpdateManyMutationInput, AdminAssignmentUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminAssignmentScalarWhereInput = {
    AND?: AdminAssignmentScalarWhereInput | AdminAssignmentScalarWhereInput[]
    OR?: AdminAssignmentScalarWhereInput[]
    NOT?: AdminAssignmentScalarWhereInput | AdminAssignmentScalarWhereInput[]
    id?: StringFilter<"AdminAssignment"> | string
    adminId?: StringFilter<"AdminAssignment"> | string
    roleId?: StringFilter<"AdminAssignment"> | string
    startDate?: DateTimeFilter<"AdminAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"AdminAssignment"> | Date | string | null
    status?: StringFilter<"AdminAssignment"> | string
    createdAt?: DateTimeFilter<"AdminAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"AdminAssignment"> | Date | string
  }

  export type LegalCaseUpsertWithWhereUniqueWithoutAssignedLawyerInput = {
    where: LegalCaseWhereUniqueInput
    update: XOR<LegalCaseUpdateWithoutAssignedLawyerInput, LegalCaseUncheckedUpdateWithoutAssignedLawyerInput>
    create: XOR<LegalCaseCreateWithoutAssignedLawyerInput, LegalCaseUncheckedCreateWithoutAssignedLawyerInput>
  }

  export type LegalCaseUpdateWithWhereUniqueWithoutAssignedLawyerInput = {
    where: LegalCaseWhereUniqueInput
    data: XOR<LegalCaseUpdateWithoutAssignedLawyerInput, LegalCaseUncheckedUpdateWithoutAssignedLawyerInput>
  }

  export type LegalCaseUpdateManyWithWhereWithoutAssignedLawyerInput = {
    where: LegalCaseScalarWhereInput
    data: XOR<LegalCaseUpdateManyMutationInput, LegalCaseUncheckedUpdateManyWithoutAssignedLawyerInput>
  }

  export type AdminRoleUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminRoleWhereUniqueInput
    update: XOR<AdminRoleUpdateWithoutAdminInput, AdminRoleUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminRoleCreateWithoutAdminInput, AdminRoleUncheckedCreateWithoutAdminInput>
  }

  export type AdminRoleUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminRoleWhereUniqueInput
    data: XOR<AdminRoleUpdateWithoutAdminInput, AdminRoleUncheckedUpdateWithoutAdminInput>
  }

  export type AdminRoleUpdateManyWithWhereWithoutAdminInput = {
    where: AdminRoleScalarWhereInput
    data: XOR<AdminRoleUpdateManyMutationInput, AdminRoleUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminRoleScalarWhereInput = {
    AND?: AdminRoleScalarWhereInput | AdminRoleScalarWhereInput[]
    OR?: AdminRoleScalarWhereInput[]
    NOT?: AdminRoleScalarWhereInput | AdminRoleScalarWhereInput[]
    id?: StringFilter<"AdminRole"> | string
    name?: EnumAdminRoleTypeFilter<"AdminRole"> | $Enums.AdminRoleType
    description?: StringNullableFilter<"AdminRole"> | string | null
    adminId?: StringFilter<"AdminRole"> | string
    createdAt?: DateTimeFilter<"AdminRole"> | Date | string
    updatedAt?: DateTimeFilter<"AdminRole"> | Date | string
  }

  export type UserCreateWithoutChannelsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutChannelsInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutChannelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChannelsInput, UserUncheckedCreateWithoutChannelsInput>
  }

  export type OwnerCreateWithoutChannelInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOwnerInput
  }

  export type OwnerUncheckedCreateWithoutChannelInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type OwnerCreateOrConnectWithoutChannelInput = {
    where: OwnerWhereUniqueInput
    create: XOR<OwnerCreateWithoutChannelInput, OwnerUncheckedCreateWithoutChannelInput>
  }

  export type MessageCreateWithoutChannelInput = {
    id?: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutChannelInput = {
    id?: string
    senderId: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
  }

  export type MessageCreateOrConnectWithoutChannelInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput>
  }

  export type PublicRelationsRecordCreateWithoutChannelsInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    handledByAdmin: AdminCreateNestedOneWithoutPrRecordsInput
    academy: AcademyCreateNestedOneWithoutPublicRelationsRecordInput
    responses?: PRResponseCreateNestedManyWithoutPrRecordInput
    events?: EventCreateNestedManyWithoutPrRecordInput
    posts?: PostCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordUncheckedCreateWithoutChannelsInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    handledByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: PRResponseUncheckedCreateNestedManyWithoutPrRecordInput
    events?: EventUncheckedCreateNestedManyWithoutPrRecordInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileUncheckedCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordCreateOrConnectWithoutChannelsInput = {
    where: PublicRelationsRecordWhereUniqueInput
    create: XOR<PublicRelationsRecordCreateWithoutChannelsInput, PublicRelationsRecordUncheckedCreateWithoutChannelsInput>
  }

  export type MeetingCreateWithoutChannelsInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutMeetingsInput
    academy: AcademyCreateNestedOneWithoutMeetingInput
    participants?: MeetingParticipantCreateNestedManyWithoutMeetingInput
    files?: FileCreateNestedManyWithoutMeetingInput
    reports?: ReportCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutChannelsInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: MeetingParticipantUncheckedCreateNestedManyWithoutMeetingInput
    files?: FileUncheckedCreateNestedManyWithoutMeetingInput
    reports?: ReportUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutChannelsInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutChannelsInput, MeetingUncheckedCreateWithoutChannelsInput>
  }

  export type AdminRoleCreateWithoutChannelsInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutAdminRoleInput
    assignments?: AdminAssignmentCreateNestedManyWithoutRoleInput
    permissions?: PermissionCreateNestedManyWithoutAdminRoleInput
    reports?: ReportCreateNestedManyWithoutAdminRoleInput
    files?: FileCreateNestedManyWithoutAdminRoleInput
    events?: EventCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleUncheckedCreateWithoutChannelsInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutRoleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutAdminRoleInput
    reports?: ReportUncheckedCreateNestedManyWithoutAdminRoleInput
    files?: FileUncheckedCreateNestedManyWithoutAdminRoleInput
    events?: EventUncheckedCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleCreateOrConnectWithoutChannelsInput = {
    where: AdminRoleWhereUniqueInput
    create: XOR<AdminRoleCreateWithoutChannelsInput, AdminRoleUncheckedCreateWithoutChannelsInput>
  }

  export type LegalCaseCreateWithoutChannelsInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedLawyer: AdminCreateNestedOneWithoutLegalCasesInput
    academy: AcademyCreateNestedOneWithoutLegalCaseInput
    relatedUser?: UserCreateNestedOneWithoutLegalCaseInput
    files?: FileCreateNestedManyWithoutLegalCaseInput
    reports?: ReportCreateNestedManyWithoutLegalCaseInput
    events?: EventCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseUncheckedCreateWithoutChannelsInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    academyId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLegalCaseInput
    reports?: ReportUncheckedCreateNestedManyWithoutLegalCaseInput
    events?: EventUncheckedCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseCreateOrConnectWithoutChannelsInput = {
    where: LegalCaseWhereUniqueInput
    create: XOR<LegalCaseCreateWithoutChannelsInput, LegalCaseUncheckedCreateWithoutChannelsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutChannelsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutChannelsInput, UserUncheckedUpdateWithoutChannelsInput>
    create: XOR<UserCreateWithoutChannelsInput, UserUncheckedCreateWithoutChannelsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutChannelsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutChannelsInput, UserUncheckedUpdateWithoutChannelsInput>
  }

  export type UserUpdateManyWithWhereWithoutChannelsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutChannelsInput>
  }

  export type OwnerUpsertWithoutChannelInput = {
    update: XOR<OwnerUpdateWithoutChannelInput, OwnerUncheckedUpdateWithoutChannelInput>
    create: XOR<OwnerCreateWithoutChannelInput, OwnerUncheckedCreateWithoutChannelInput>
    where?: OwnerWhereInput
  }

  export type OwnerUpdateToOneWithWhereWithoutChannelInput = {
    where?: OwnerWhereInput
    data: XOR<OwnerUpdateWithoutChannelInput, OwnerUncheckedUpdateWithoutChannelInput>
  }

  export type OwnerUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutChannelInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutChannelInput, MessageUncheckedUpdateWithoutChannelInput>
    create: XOR<MessageCreateWithoutChannelInput, MessageUncheckedCreateWithoutChannelInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutChannelInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutChannelInput, MessageUncheckedUpdateWithoutChannelInput>
  }

  export type MessageUpdateManyWithWhereWithoutChannelInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutChannelInput>
  }

  export type PublicRelationsRecordUpsertWithoutChannelsInput = {
    update: XOR<PublicRelationsRecordUpdateWithoutChannelsInput, PublicRelationsRecordUncheckedUpdateWithoutChannelsInput>
    create: XOR<PublicRelationsRecordCreateWithoutChannelsInput, PublicRelationsRecordUncheckedCreateWithoutChannelsInput>
    where?: PublicRelationsRecordWhereInput
  }

  export type PublicRelationsRecordUpdateToOneWithWhereWithoutChannelsInput = {
    where?: PublicRelationsRecordWhereInput
    data: XOR<PublicRelationsRecordUpdateWithoutChannelsInput, PublicRelationsRecordUncheckedUpdateWithoutChannelsInput>
  }

  export type PublicRelationsRecordUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledByAdmin?: AdminUpdateOneRequiredWithoutPrRecordsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutPublicRelationsRecordNestedInput
    responses?: PRResponseUpdateManyWithoutPrRecordNestedInput
    events?: EventUpdateManyWithoutPrRecordNestedInput
    posts?: PostUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    handledByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PRResponseUncheckedUpdateManyWithoutPrRecordNestedInput
    events?: EventUncheckedUpdateManyWithoutPrRecordNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUncheckedUpdateManyWithoutPrRecordNestedInput
  }

  export type MeetingUpsertWithoutChannelsInput = {
    update: XOR<MeetingUpdateWithoutChannelsInput, MeetingUncheckedUpdateWithoutChannelsInput>
    create: XOR<MeetingCreateWithoutChannelsInput, MeetingUncheckedCreateWithoutChannelsInput>
    where?: MeetingWhereInput
  }

  export type MeetingUpdateToOneWithWhereWithoutChannelsInput = {
    where?: MeetingWhereInput
    data: XOR<MeetingUpdateWithoutChannelsInput, MeetingUncheckedUpdateWithoutChannelsInput>
  }

  export type MeetingUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutMeetingsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutMeetingNestedInput
    participants?: MeetingParticipantUpdateManyWithoutMeetingNestedInput
    files?: FileUpdateManyWithoutMeetingNestedInput
    reports?: ReportUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MeetingParticipantUncheckedUpdateManyWithoutMeetingNestedInput
    files?: FileUncheckedUpdateManyWithoutMeetingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type AdminRoleUpsertWithoutChannelsInput = {
    update: XOR<AdminRoleUpdateWithoutChannelsInput, AdminRoleUncheckedUpdateWithoutChannelsInput>
    create: XOR<AdminRoleCreateWithoutChannelsInput, AdminRoleUncheckedCreateWithoutChannelsInput>
    where?: AdminRoleWhereInput
  }

  export type AdminRoleUpdateToOneWithWhereWithoutChannelsInput = {
    where?: AdminRoleWhereInput
    data: XOR<AdminRoleUpdateWithoutChannelsInput, AdminRoleUncheckedUpdateWithoutChannelsInput>
  }

  export type AdminRoleUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutAdminRoleNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUpdateManyWithoutAdminRoleNestedInput
    files?: FileUpdateManyWithoutAdminRoleNestedInput
    events?: EventUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAdminRoleNestedInput
    files?: FileUncheckedUpdateManyWithoutAdminRoleNestedInput
    events?: EventUncheckedUpdateManyWithoutAdminRoleNestedInput
  }

  export type LegalCaseUpsertWithoutChannelsInput = {
    update: XOR<LegalCaseUpdateWithoutChannelsInput, LegalCaseUncheckedUpdateWithoutChannelsInput>
    create: XOR<LegalCaseCreateWithoutChannelsInput, LegalCaseUncheckedCreateWithoutChannelsInput>
    where?: LegalCaseWhereInput
  }

  export type LegalCaseUpdateToOneWithWhereWithoutChannelsInput = {
    where?: LegalCaseWhereInput
    data: XOR<LegalCaseUpdateWithoutChannelsInput, LegalCaseUncheckedUpdateWithoutChannelsInput>
  }

  export type LegalCaseUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedLawyer?: AdminUpdateOneRequiredWithoutLegalCasesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutLegalCaseNestedInput
    relatedUser?: UserUpdateOneWithoutLegalCaseNestedInput
    files?: FileUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUpdateManyWithoutLegalCaseNestedInput
    events?: EventUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLegalCaseNestedInput
    events?: EventUncheckedUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLegalCaseNestedInput
  }

  export type UserCreateWithoutOwnerInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutOwnerInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutOwnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnerInput, UserUncheckedCreateWithoutOwnerInput>
  }

  export type ChannelCreateWithoutOwnerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutChannelsInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutChannelsInput
    meeting?: MeetingCreateNestedOneWithoutChannelsInput
    adminRole?: AdminRoleCreateNestedOneWithoutChannelsInput
    legalCase?: LegalCaseCreateNestedOneWithoutChannelsInput
  }

  export type ChannelUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutChannelsInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutOwnerInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput>
  }

  export type ChannelCreateManyOwnerInputEnvelope = {
    data: ChannelCreateManyOwnerInput | ChannelCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnerInput = {
    update: XOR<UserUpdateWithoutOwnerInput, UserUncheckedUpdateWithoutOwnerInput>
    create: XOR<UserCreateWithoutOwnerInput, UserUncheckedCreateWithoutOwnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnerInput, UserUncheckedUpdateWithoutOwnerInput>
  }

  export type UserUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type ChannelUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutOwnerInput, ChannelUncheckedUpdateWithoutOwnerInput>
    create: XOR<ChannelCreateWithoutOwnerInput, ChannelUncheckedCreateWithoutOwnerInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutOwnerInput, ChannelUncheckedUpdateWithoutOwnerInput>
  }

  export type ChannelUpdateManyWithWhereWithoutOwnerInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutOwnerInput>
  }

  export type UserCreateWithoutBookmarksInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutBookmarksInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutBookmarksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
  }

  export type UserUpsertWithoutBookmarksInput = {
    update: XOR<UserUpdateWithoutBookmarksInput, UserUncheckedUpdateWithoutBookmarksInput>
    create: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookmarksInput, UserUncheckedUpdateWithoutBookmarksInput>
  }

  export type UserUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type AcademyCreateWithoutEventsInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOCreateNestedManyWithoutAcademyInput
    courses?: CourseCreateNestedManyWithoutAcademyInput
    instructors?: InstructorCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOUncheckedCreateNestedManyWithoutAcademyInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademyInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryUncheckedCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutAcademyInput
  }

  export type AcademyCreateOrConnectWithoutEventsInput = {
    where: AcademyWhereUniqueInput
    create: XOR<AcademyCreateWithoutEventsInput, AcademyUncheckedCreateWithoutEventsInput>
  }

  export type PublicRelationsRecordCreateWithoutEventsInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    handledByAdmin: AdminCreateNestedOneWithoutPrRecordsInput
    academy: AcademyCreateNestedOneWithoutPublicRelationsRecordInput
    responses?: PRResponseCreateNestedManyWithoutPrRecordInput
    posts?: PostCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileCreateNestedManyWithoutPrRecordInput
    channels?: ChannelCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordUncheckedCreateWithoutEventsInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    handledByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: PRResponseUncheckedCreateNestedManyWithoutPrRecordInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileUncheckedCreateNestedManyWithoutPrRecordInput
    channels?: ChannelUncheckedCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordCreateOrConnectWithoutEventsInput = {
    where: PublicRelationsRecordWhereUniqueInput
    create: XOR<PublicRelationsRecordCreateWithoutEventsInput, PublicRelationsRecordUncheckedCreateWithoutEventsInput>
  }

  export type AdminRoleCreateWithoutEventsInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutAdminRoleInput
    assignments?: AdminAssignmentCreateNestedManyWithoutRoleInput
    permissions?: PermissionCreateNestedManyWithoutAdminRoleInput
    reports?: ReportCreateNestedManyWithoutAdminRoleInput
    files?: FileCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleUncheckedCreateWithoutEventsInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutRoleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutAdminRoleInput
    reports?: ReportUncheckedCreateNestedManyWithoutAdminRoleInput
    files?: FileUncheckedCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelUncheckedCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleCreateOrConnectWithoutEventsInput = {
    where: AdminRoleWhereUniqueInput
    create: XOR<AdminRoleCreateWithoutEventsInput, AdminRoleUncheckedCreateWithoutEventsInput>
  }

  export type LegalCaseCreateWithoutEventsInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedLawyer: AdminCreateNestedOneWithoutLegalCasesInput
    academy: AcademyCreateNestedOneWithoutLegalCaseInput
    relatedUser?: UserCreateNestedOneWithoutLegalCaseInput
    files?: FileCreateNestedManyWithoutLegalCaseInput
    reports?: ReportCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseUncheckedCreateWithoutEventsInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    academyId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLegalCaseInput
    reports?: ReportUncheckedCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelUncheckedCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseCreateOrConnectWithoutEventsInput = {
    where: LegalCaseWhereUniqueInput
    create: XOR<LegalCaseCreateWithoutEventsInput, LegalCaseUncheckedCreateWithoutEventsInput>
  }

  export type AcademyUpsertWithoutEventsInput = {
    update: XOR<AcademyUpdateWithoutEventsInput, AcademyUncheckedUpdateWithoutEventsInput>
    create: XOR<AcademyCreateWithoutEventsInput, AcademyUncheckedCreateWithoutEventsInput>
    where?: AcademyWhereInput
  }

  export type AcademyUpdateToOneWithWhereWithoutEventsInput = {
    where?: AcademyWhereInput
    data: XOR<AcademyUpdateWithoutEventsInput, AcademyUncheckedUpdateWithoutEventsInput>
  }

  export type AcademyUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUpdateManyWithoutAcademyNestedInput
    courses?: CourseUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUncheckedUpdateManyWithoutAcademyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUncheckedUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutAcademyNestedInput
  }

  export type PublicRelationsRecordUpsertWithoutEventsInput = {
    update: XOR<PublicRelationsRecordUpdateWithoutEventsInput, PublicRelationsRecordUncheckedUpdateWithoutEventsInput>
    create: XOR<PublicRelationsRecordCreateWithoutEventsInput, PublicRelationsRecordUncheckedCreateWithoutEventsInput>
    where?: PublicRelationsRecordWhereInput
  }

  export type PublicRelationsRecordUpdateToOneWithWhereWithoutEventsInput = {
    where?: PublicRelationsRecordWhereInput
    data: XOR<PublicRelationsRecordUpdateWithoutEventsInput, PublicRelationsRecordUncheckedUpdateWithoutEventsInput>
  }

  export type PublicRelationsRecordUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledByAdmin?: AdminUpdateOneRequiredWithoutPrRecordsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutPublicRelationsRecordNestedInput
    responses?: PRResponseUpdateManyWithoutPrRecordNestedInput
    posts?: PostUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    handledByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PRResponseUncheckedUpdateManyWithoutPrRecordNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUncheckedUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutPrRecordNestedInput
  }

  export type AdminRoleUpsertWithoutEventsInput = {
    update: XOR<AdminRoleUpdateWithoutEventsInput, AdminRoleUncheckedUpdateWithoutEventsInput>
    create: XOR<AdminRoleCreateWithoutEventsInput, AdminRoleUncheckedCreateWithoutEventsInput>
    where?: AdminRoleWhereInput
  }

  export type AdminRoleUpdateToOneWithWhereWithoutEventsInput = {
    where?: AdminRoleWhereInput
    data: XOR<AdminRoleUpdateWithoutEventsInput, AdminRoleUncheckedUpdateWithoutEventsInput>
  }

  export type AdminRoleUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutAdminRoleNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUpdateManyWithoutAdminRoleNestedInput
    files?: FileUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAdminRoleNestedInput
    files?: FileUncheckedUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutAdminRoleNestedInput
  }

  export type LegalCaseUpsertWithoutEventsInput = {
    update: XOR<LegalCaseUpdateWithoutEventsInput, LegalCaseUncheckedUpdateWithoutEventsInput>
    create: XOR<LegalCaseCreateWithoutEventsInput, LegalCaseUncheckedCreateWithoutEventsInput>
    where?: LegalCaseWhereInput
  }

  export type LegalCaseUpdateToOneWithWhereWithoutEventsInput = {
    where?: LegalCaseWhereInput
    data: XOR<LegalCaseUpdateWithoutEventsInput, LegalCaseUncheckedUpdateWithoutEventsInput>
  }

  export type LegalCaseUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedLawyer?: AdminUpdateOneRequiredWithoutLegalCasesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutLegalCaseNestedInput
    relatedUser?: UserUpdateOneWithoutLegalCaseNestedInput
    files?: FileUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLegalCaseNestedInput
  }

  export type UserCreateWithoutAttendanceInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutAttendanceInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutAttendanceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
  }

  export type LessonCreateWithoutAttendanceInput = {
    id?: string
    title: string
    content: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutLessonsInput
    files?: FileCreateNestedManyWithoutLessonInput
    quizzes?: QuizCreateNestedManyWithoutLessonInput
    completedBy?: UserCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutAttendanceInput = {
    id?: string
    title: string
    content: string
    courseId: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLessonInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutLessonInput
    completedBy?: UserUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutAttendanceInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutAttendanceInput, LessonUncheckedCreateWithoutAttendanceInput>
  }

  export type UserUpsertWithoutAttendanceInput = {
    update: XOR<UserUpdateWithoutAttendanceInput, UserUncheckedUpdateWithoutAttendanceInput>
    create: XOR<UserCreateWithoutAttendanceInput, UserUncheckedCreateWithoutAttendanceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendanceInput, UserUncheckedUpdateWithoutAttendanceInput>
  }

  export type UserUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type LessonUpsertWithoutAttendanceInput = {
    update: XOR<LessonUpdateWithoutAttendanceInput, LessonUncheckedUpdateWithoutAttendanceInput>
    create: XOR<LessonCreateWithoutAttendanceInput, LessonUncheckedCreateWithoutAttendanceInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutAttendanceInput, LessonUncheckedUpdateWithoutAttendanceInput>
  }

  export type LessonUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutLessonsNestedInput
    files?: FileUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    completedBy?: UserUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    completedBy?: UserUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserCreateWithoutPaymentInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutPaymentInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutPaymentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>
  }

  export type LegalCaseCreateWithoutPaymentsInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedLawyer: AdminCreateNestedOneWithoutLegalCasesInput
    academy: AcademyCreateNestedOneWithoutLegalCaseInput
    relatedUser?: UserCreateNestedOneWithoutLegalCaseInput
    files?: FileCreateNestedManyWithoutLegalCaseInput
    reports?: ReportCreateNestedManyWithoutLegalCaseInput
    events?: EventCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseUncheckedCreateWithoutPaymentsInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    academyId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLegalCaseInput
    reports?: ReportUncheckedCreateNestedManyWithoutLegalCaseInput
    events?: EventUncheckedCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelUncheckedCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseCreateOrConnectWithoutPaymentsInput = {
    where: LegalCaseWhereUniqueInput
    create: XOR<LegalCaseCreateWithoutPaymentsInput, LegalCaseUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentInput = {
    update: XOR<UserUpdateWithoutPaymentInput, UserUncheckedUpdateWithoutPaymentInput>
    create: XOR<UserCreateWithoutPaymentInput, UserUncheckedCreateWithoutPaymentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentInput, UserUncheckedUpdateWithoutPaymentInput>
  }

  export type UserUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type LegalCaseUpsertWithoutPaymentsInput = {
    update: XOR<LegalCaseUpdateWithoutPaymentsInput, LegalCaseUncheckedUpdateWithoutPaymentsInput>
    create: XOR<LegalCaseCreateWithoutPaymentsInput, LegalCaseUncheckedCreateWithoutPaymentsInput>
    where?: LegalCaseWhereInput
  }

  export type LegalCaseUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: LegalCaseWhereInput
    data: XOR<LegalCaseUpdateWithoutPaymentsInput, LegalCaseUncheckedUpdateWithoutPaymentsInput>
  }

  export type LegalCaseUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedLawyer?: AdminUpdateOneRequiredWithoutLegalCasesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutLegalCaseNestedInput
    relatedUser?: UserUpdateOneWithoutLegalCaseNestedInput
    files?: FileUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUpdateManyWithoutLegalCaseNestedInput
    events?: EventUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLegalCaseNestedInput
    events?: EventUncheckedUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutLegalCaseNestedInput
  }

  export type UserCreateWithoutReportInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutReportInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutReportInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportInput, UserUncheckedCreateWithoutReportInput>
  }

  export type AccountingEntryCreateWithoutReportsInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutAccountingEntriesInput
    academy: AcademyCreateNestedOneWithoutAccountingEntryInput
    invoice?: InvoiceCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentCreateNestedOneWithoutAccountingEntryInput
    files?: FileCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryUncheckedCreateWithoutReportsInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentUncheckedCreateNestedOneWithoutAccountingEntryInput
    files?: FileUncheckedCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryCreateOrConnectWithoutReportsInput = {
    where: AccountingEntryWhereUniqueInput
    create: XOR<AccountingEntryCreateWithoutReportsInput, AccountingEntryUncheckedCreateWithoutReportsInput>
  }

  export type MeetingCreateWithoutReportsInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutMeetingsInput
    academy: AcademyCreateNestedOneWithoutMeetingInput
    participants?: MeetingParticipantCreateNestedManyWithoutMeetingInput
    files?: FileCreateNestedManyWithoutMeetingInput
    channels?: ChannelCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutReportsInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: MeetingParticipantUncheckedCreateNestedManyWithoutMeetingInput
    files?: FileUncheckedCreateNestedManyWithoutMeetingInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutReportsInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutReportsInput, MeetingUncheckedCreateWithoutReportsInput>
  }

  export type AdminRoleCreateWithoutReportsInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutAdminRoleInput
    assignments?: AdminAssignmentCreateNestedManyWithoutRoleInput
    permissions?: PermissionCreateNestedManyWithoutAdminRoleInput
    files?: FileCreateNestedManyWithoutAdminRoleInput
    events?: EventCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleUncheckedCreateWithoutReportsInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutRoleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutAdminRoleInput
    files?: FileUncheckedCreateNestedManyWithoutAdminRoleInput
    events?: EventUncheckedCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelUncheckedCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleCreateOrConnectWithoutReportsInput = {
    where: AdminRoleWhereUniqueInput
    create: XOR<AdminRoleCreateWithoutReportsInput, AdminRoleUncheckedCreateWithoutReportsInput>
  }

  export type LegalCaseCreateWithoutReportsInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedLawyer: AdminCreateNestedOneWithoutLegalCasesInput
    academy: AcademyCreateNestedOneWithoutLegalCaseInput
    relatedUser?: UserCreateNestedOneWithoutLegalCaseInput
    files?: FileCreateNestedManyWithoutLegalCaseInput
    events?: EventCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseUncheckedCreateWithoutReportsInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    academyId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutLegalCaseInput
    events?: EventUncheckedCreateNestedManyWithoutLegalCaseInput
    channels?: ChannelUncheckedCreateNestedManyWithoutLegalCaseInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLegalCaseInput
  }

  export type LegalCaseCreateOrConnectWithoutReportsInput = {
    where: LegalCaseWhereUniqueInput
    create: XOR<LegalCaseCreateWithoutReportsInput, LegalCaseUncheckedCreateWithoutReportsInput>
  }

  export type UserUpsertWithoutReportInput = {
    update: XOR<UserUpdateWithoutReportInput, UserUncheckedUpdateWithoutReportInput>
    create: XOR<UserCreateWithoutReportInput, UserUncheckedCreateWithoutReportInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportInput, UserUncheckedUpdateWithoutReportInput>
  }

  export type UserUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type AccountingEntryUpsertWithoutReportsInput = {
    update: XOR<AccountingEntryUpdateWithoutReportsInput, AccountingEntryUncheckedUpdateWithoutReportsInput>
    create: XOR<AccountingEntryCreateWithoutReportsInput, AccountingEntryUncheckedCreateWithoutReportsInput>
    where?: AccountingEntryWhereInput
  }

  export type AccountingEntryUpdateToOneWithWhereWithoutReportsInput = {
    where?: AccountingEntryWhereInput
    data: XOR<AccountingEntryUpdateWithoutReportsInput, AccountingEntryUncheckedUpdateWithoutReportsInput>
  }

  export type AccountingEntryUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutAccountingEntriesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutAccountingEntryNestedInput
    invoice?: InvoiceUpdateOneWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AccountingEntryUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUncheckedUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUncheckedUpdateManyWithoutAccountingEntryNestedInput
  }

  export type MeetingUpsertWithoutReportsInput = {
    update: XOR<MeetingUpdateWithoutReportsInput, MeetingUncheckedUpdateWithoutReportsInput>
    create: XOR<MeetingCreateWithoutReportsInput, MeetingUncheckedCreateWithoutReportsInput>
    where?: MeetingWhereInput
  }

  export type MeetingUpdateToOneWithWhereWithoutReportsInput = {
    where?: MeetingWhereInput
    data: XOR<MeetingUpdateWithoutReportsInput, MeetingUncheckedUpdateWithoutReportsInput>
  }

  export type MeetingUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutMeetingsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutMeetingNestedInput
    participants?: MeetingParticipantUpdateManyWithoutMeetingNestedInput
    files?: FileUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MeetingParticipantUncheckedUpdateManyWithoutMeetingNestedInput
    files?: FileUncheckedUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type AdminRoleUpsertWithoutReportsInput = {
    update: XOR<AdminRoleUpdateWithoutReportsInput, AdminRoleUncheckedUpdateWithoutReportsInput>
    create: XOR<AdminRoleCreateWithoutReportsInput, AdminRoleUncheckedCreateWithoutReportsInput>
    where?: AdminRoleWhereInput
  }

  export type AdminRoleUpdateToOneWithWhereWithoutReportsInput = {
    where?: AdminRoleWhereInput
    data: XOR<AdminRoleUpdateWithoutReportsInput, AdminRoleUncheckedUpdateWithoutReportsInput>
  }

  export type AdminRoleUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutAdminRoleNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUpdateManyWithoutAdminRoleNestedInput
    files?: FileUpdateManyWithoutAdminRoleNestedInput
    events?: EventUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutAdminRoleNestedInput
    files?: FileUncheckedUpdateManyWithoutAdminRoleNestedInput
    events?: EventUncheckedUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutAdminRoleNestedInput
  }

  export type LegalCaseUpsertWithoutReportsInput = {
    update: XOR<LegalCaseUpdateWithoutReportsInput, LegalCaseUncheckedUpdateWithoutReportsInput>
    create: XOR<LegalCaseCreateWithoutReportsInput, LegalCaseUncheckedCreateWithoutReportsInput>
    where?: LegalCaseWhereInput
  }

  export type LegalCaseUpdateToOneWithWhereWithoutReportsInput = {
    where?: LegalCaseWhereInput
    data: XOR<LegalCaseUpdateWithoutReportsInput, LegalCaseUncheckedUpdateWithoutReportsInput>
  }

  export type LegalCaseUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedLawyer?: AdminUpdateOneRequiredWithoutLegalCasesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutLegalCaseNestedInput
    relatedUser?: UserUpdateOneWithoutLegalCaseNestedInput
    files?: FileUpdateManyWithoutLegalCaseNestedInput
    events?: EventUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLegalCaseNestedInput
    events?: EventUncheckedUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLegalCaseNestedInput
  }

  export type UserCreateWithoutBadgeInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutBadgeInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutBadgeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBadgeInput, UserUncheckedCreateWithoutBadgeInput>
  }

  export type UserUpsertWithoutBadgeInput = {
    update: XOR<UserUpdateWithoutBadgeInput, UserUncheckedUpdateWithoutBadgeInput>
    create: XOR<UserCreateWithoutBadgeInput, UserUncheckedCreateWithoutBadgeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBadgeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBadgeInput, UserUncheckedUpdateWithoutBadgeInput>
  }

  export type UserUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBadgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserCreateWithoutCertificateInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutCertificateInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutCertificateInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
  }

  export type UserUpsertWithoutCertificateInput = {
    update: XOR<UserUpdateWithoutCertificateInput, UserUncheckedUpdateWithoutCertificateInput>
    create: XOR<UserCreateWithoutCertificateInput, UserUncheckedCreateWithoutCertificateInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificateInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificateInput, UserUncheckedUpdateWithoutCertificateInput>
  }

  export type UserUpdateWithoutCertificateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type GroupCreateWithoutCommunityInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutGroupsInput
    posts?: PostCreateNestedManyWithoutGroupInput
    admin: AdminCreateNestedOneWithoutGroupInput
  }

  export type GroupUncheckedCreateWithoutCommunityInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    adminId: string
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutGroupsInput
    posts?: PostUncheckedCreateNestedManyWithoutGroupInput
  }

  export type GroupCreateOrConnectWithoutCommunityInput = {
    where: GroupWhereUniqueInput
    create: XOR<GroupCreateWithoutCommunityInput, GroupUncheckedCreateWithoutCommunityInput>
  }

  export type LiveRoomCreateWithoutCommunityInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedManyWithoutLiveRoomInput
    course?: CourseCreateNestedOneWithoutLiveRoomInput
  }

  export type LiveRoomUncheckedCreateWithoutCommunityInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
    User?: UserUncheckedCreateNestedManyWithoutLiveRoomInput
  }

  export type LiveRoomCreateOrConnectWithoutCommunityInput = {
    where: LiveRoomWhereUniqueInput
    create: XOR<LiveRoomCreateWithoutCommunityInput, LiveRoomUncheckedCreateWithoutCommunityInput>
  }

  export type LiveRoomCreateManyCommunityInputEnvelope = {
    data: LiveRoomCreateManyCommunityInput | LiveRoomCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCommunityInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutCommunityInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutCommunityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunityInput, UserUncheckedCreateWithoutCommunityInput>
  }

  export type PostCreateWithoutCommunityInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    author: UserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    Group?: GroupCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionCreateNestedManyWithoutPostInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCommunityInput = {
    id?: string
    authorId: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    publicRelationsRecordId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    Group?: GroupUncheckedCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommunityInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput>
  }

  export type DiscussionCreateWithoutCommunityInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: PostCreateNestedOneWithoutDiscussionInput
  }

  export type DiscussionUncheckedCreateWithoutCommunityInput = {
    id?: string
    postId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscussionCreateOrConnectWithoutCommunityInput = {
    where: DiscussionWhereUniqueInput
    create: XOR<DiscussionCreateWithoutCommunityInput, DiscussionUncheckedCreateWithoutCommunityInput>
  }

  export type DiscussionCreateManyCommunityInputEnvelope = {
    data: DiscussionCreateManyCommunityInput | DiscussionCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type GroupUpsertWithWhereUniqueWithoutCommunityInput = {
    where: GroupWhereUniqueInput
    update: XOR<GroupUpdateWithoutCommunityInput, GroupUncheckedUpdateWithoutCommunityInput>
    create: XOR<GroupCreateWithoutCommunityInput, GroupUncheckedCreateWithoutCommunityInput>
  }

  export type GroupUpdateWithWhereUniqueWithoutCommunityInput = {
    where: GroupWhereUniqueInput
    data: XOR<GroupUpdateWithoutCommunityInput, GroupUncheckedUpdateWithoutCommunityInput>
  }

  export type GroupUpdateManyWithWhereWithoutCommunityInput = {
    where: GroupScalarWhereInput
    data: XOR<GroupUpdateManyMutationInput, GroupUncheckedUpdateManyWithoutCommunityInput>
  }

  export type LiveRoomUpsertWithWhereUniqueWithoutCommunityInput = {
    where: LiveRoomWhereUniqueInput
    update: XOR<LiveRoomUpdateWithoutCommunityInput, LiveRoomUncheckedUpdateWithoutCommunityInput>
    create: XOR<LiveRoomCreateWithoutCommunityInput, LiveRoomUncheckedCreateWithoutCommunityInput>
  }

  export type LiveRoomUpdateWithWhereUniqueWithoutCommunityInput = {
    where: LiveRoomWhereUniqueInput
    data: XOR<LiveRoomUpdateWithoutCommunityInput, LiveRoomUncheckedUpdateWithoutCommunityInput>
  }

  export type LiveRoomUpdateManyWithWhereWithoutCommunityInput = {
    where: LiveRoomScalarWhereInput
    data: XOR<LiveRoomUpdateManyMutationInput, LiveRoomUncheckedUpdateManyWithoutCommunityInput>
  }

  export type UserUpsertWithWhereUniqueWithoutCommunityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCommunityInput, UserUncheckedUpdateWithoutCommunityInput>
    create: XOR<UserCreateWithoutCommunityInput, UserUncheckedCreateWithoutCommunityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCommunityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCommunityInput, UserUncheckedUpdateWithoutCommunityInput>
  }

  export type UserUpdateManyWithWhereWithoutCommunityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCommunityInput>
  }

  export type PostUpsertWithWhereUniqueWithoutCommunityInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutCommunityInput, PostUncheckedUpdateWithoutCommunityInput>
    create: XOR<PostCreateWithoutCommunityInput, PostUncheckedCreateWithoutCommunityInput>
  }

  export type PostUpdateWithWhereUniqueWithoutCommunityInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutCommunityInput, PostUncheckedUpdateWithoutCommunityInput>
  }

  export type PostUpdateManyWithWhereWithoutCommunityInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutCommunityInput>
  }

  export type DiscussionUpsertWithWhereUniqueWithoutCommunityInput = {
    where: DiscussionWhereUniqueInput
    update: XOR<DiscussionUpdateWithoutCommunityInput, DiscussionUncheckedUpdateWithoutCommunityInput>
    create: XOR<DiscussionCreateWithoutCommunityInput, DiscussionUncheckedCreateWithoutCommunityInput>
  }

  export type DiscussionUpdateWithWhereUniqueWithoutCommunityInput = {
    where: DiscussionWhereUniqueInput
    data: XOR<DiscussionUpdateWithoutCommunityInput, DiscussionUncheckedUpdateWithoutCommunityInput>
  }

  export type DiscussionUpdateManyWithWhereWithoutCommunityInput = {
    where: DiscussionScalarWhereInput
    data: XOR<DiscussionUpdateManyMutationInput, DiscussionUncheckedUpdateManyWithoutCommunityInput>
  }

  export type CommunityCreateWithoutDiscussionsInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupCreateNestedManyWithoutCommunityInput
    liveRoom?: LiveRoomCreateNestedManyWithoutCommunityInput
    participants?: UserCreateNestedManyWithoutCommunityInput
    posts?: PostCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutDiscussionsInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupUncheckedCreateNestedManyWithoutCommunityInput
    liveRoom?: LiveRoomUncheckedCreateNestedManyWithoutCommunityInput
    participants?: UserUncheckedCreateNestedManyWithoutCommunityInput
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutDiscussionsInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutDiscussionsInput, CommunityUncheckedCreateWithoutDiscussionsInput>
  }

  export type PostCreateWithoutDiscussionInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    author: UserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    Group?: GroupCreateNestedManyWithoutPostsInput
    Community?: CommunityCreateNestedManyWithoutPostsInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutDiscussionInput = {
    id?: string
    authorId: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    publicRelationsRecordId?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    Group?: GroupUncheckedCreateNestedManyWithoutPostsInput
    Community?: CommunityUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutDiscussionInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutDiscussionInput, PostUncheckedCreateWithoutDiscussionInput>
  }

  export type CommunityUpsertWithoutDiscussionsInput = {
    update: XOR<CommunityUpdateWithoutDiscussionsInput, CommunityUncheckedUpdateWithoutDiscussionsInput>
    create: XOR<CommunityCreateWithoutDiscussionsInput, CommunityUncheckedCreateWithoutDiscussionsInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutDiscussionsInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutDiscussionsInput, CommunityUncheckedUpdateWithoutDiscussionsInput>
  }

  export type CommunityUpdateWithoutDiscussionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUpdateManyWithoutCommunityNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCommunityNestedInput
    participants?: UserUpdateManyWithoutCommunityNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutDiscussionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUncheckedUpdateManyWithoutCommunityNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCommunityNestedInput
    participants?: UserUncheckedUpdateManyWithoutCommunityNestedInput
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type PostUpsertWithoutDiscussionInput = {
    update: XOR<PostUpdateWithoutDiscussionInput, PostUncheckedUpdateWithoutDiscussionInput>
    create: XOR<PostCreateWithoutDiscussionInput, PostUncheckedCreateWithoutDiscussionInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutDiscussionInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutDiscussionInput, PostUncheckedUpdateWithoutDiscussionInput>
  }

  export type PostUpdateWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    Group?: GroupUpdateManyWithoutPostsNestedInput
    Community?: CommunityUpdateManyWithoutPostsNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutDiscussionInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    publicRelationsRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Group?: GroupUncheckedUpdateManyWithoutPostsNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type CommunityCreateWithoutLiveRoomInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupCreateNestedManyWithoutCommunityInput
    participants?: UserCreateNestedManyWithoutCommunityInput
    posts?: PostCreateNestedManyWithoutCommunityInput
    discussions?: DiscussionCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutLiveRoomInput = {
    id?: string
    name: string
    image?: string | null
    description?: string | null
    type: string
    likes?: number
    dislikes?: number
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    groups?: GroupUncheckedCreateNestedManyWithoutCommunityInput
    participants?: UserUncheckedCreateNestedManyWithoutCommunityInput
    posts?: PostUncheckedCreateNestedManyWithoutCommunityInput
    discussions?: DiscussionUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutLiveRoomInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutLiveRoomInput, CommunityUncheckedCreateWithoutLiveRoomInput>
  }

  export type UserCreateWithoutLiveRoomInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutLiveRoomInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutLiveRoomInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLiveRoomInput, UserUncheckedCreateWithoutLiveRoomInput>
  }

  export type CourseCreateWithoutLiveRoomInput = {
    id?: string
    title: string
    description: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    academy: AcademyCreateNestedOneWithoutCoursesInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentCreateNestedManyWithoutCourseInput
    quizzes?: QuizCreateNestedManyWithoutCourseInput
    instructors?: InstructorCreateNestedManyWithoutCoursesInput
    Path?: PathCreateNestedManyWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutLiveRoomInput = {
    id?: string
    title: string
    description: string
    academyId: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutCourseInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutCourseInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutCoursesInput
    Path?: PathUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type CourseCreateOrConnectWithoutLiveRoomInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLiveRoomInput, CourseUncheckedCreateWithoutLiveRoomInput>
  }

  export type CommunityUpsertWithoutLiveRoomInput = {
    update: XOR<CommunityUpdateWithoutLiveRoomInput, CommunityUncheckedUpdateWithoutLiveRoomInput>
    create: XOR<CommunityCreateWithoutLiveRoomInput, CommunityUncheckedCreateWithoutLiveRoomInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutLiveRoomInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutLiveRoomInput, CommunityUncheckedUpdateWithoutLiveRoomInput>
  }

  export type CommunityUpdateWithoutLiveRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUpdateManyWithoutCommunityNestedInput
    participants?: UserUpdateManyWithoutCommunityNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
    discussions?: DiscussionUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutLiveRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUncheckedUpdateManyWithoutCommunityNestedInput
    participants?: UserUncheckedUpdateManyWithoutCommunityNestedInput
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    discussions?: DiscussionUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutLiveRoomInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLiveRoomInput, UserUncheckedUpdateWithoutLiveRoomInput>
    create: XOR<UserCreateWithoutLiveRoomInput, UserUncheckedCreateWithoutLiveRoomInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLiveRoomInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLiveRoomInput, UserUncheckedUpdateWithoutLiveRoomInput>
  }

  export type UserUpdateManyWithWhereWithoutLiveRoomInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLiveRoomInput>
  }

  export type CourseUpsertWithoutLiveRoomInput = {
    update: XOR<CourseUpdateWithoutLiveRoomInput, CourseUncheckedUpdateWithoutLiveRoomInput>
    create: XOR<CourseCreateWithoutLiveRoomInput, CourseUncheckedCreateWithoutLiveRoomInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLiveRoomInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLiveRoomInput, CourseUncheckedUpdateWithoutLiveRoomInput>
  }

  export type CourseUpdateWithoutLiveRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    academy?: AcademyUpdateOneRequiredWithoutCoursesNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUpdateManyWithoutCoursesNestedInput
    Path?: PathUpdateManyWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutLiveRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutCoursesNestedInput
    Path?: PathUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type AdminCreateWithoutAccountingEntriesInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
    Group?: GroupCreateNestedManyWithoutAdminInput
    prRecords?: PublicRelationsRecordCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutAccountingEntriesInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    Group?: GroupUncheckedCreateNestedManyWithoutAdminInput
    prRecords?: PublicRelationsRecordUncheckedCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseUncheckedCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseUncheckedCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutAccountingEntriesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAccountingEntriesInput, AdminUncheckedCreateWithoutAccountingEntriesInput>
  }

  export type AcademyCreateWithoutAccountingEntryInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOCreateNestedManyWithoutAcademyInput
    courses?: CourseCreateNestedManyWithoutAcademyInput
    instructors?: InstructorCreateNestedManyWithoutAcademyInput
    events?: EventCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUncheckedCreateWithoutAccountingEntryInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOUncheckedCreateNestedManyWithoutAcademyInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademyInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutAcademyInput
    events?: EventUncheckedCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutAcademyInput
  }

  export type AcademyCreateOrConnectWithoutAccountingEntryInput = {
    where: AcademyWhereUniqueInput
    create: XOR<AcademyCreateWithoutAccountingEntryInput, AcademyUncheckedCreateWithoutAccountingEntryInput>
  }

  export type InvoiceCreateWithoutAccountingEntryInput = {
    id?: string
    invoiceNumber: string
    amount: number
    description: string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUncheckedCreateWithoutAccountingEntryInput = {
    id?: string
    invoiceNumber: string
    amount: number
    description: string
    dueDate: Date | string
    status?: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutAccountingEntryInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutAccountingEntryInput, InvoiceUncheckedCreateWithoutAccountingEntryInput>
  }

  export type SalaryPaymentCreateWithoutAccountingEntryInput = {
    id?: string
    amount: number
    month: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutSalaryPaymentInput
  }

  export type SalaryPaymentUncheckedCreateWithoutAccountingEntryInput = {
    id?: string
    employeeId: string
    amount: number
    month: number
    year: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryPaymentCreateOrConnectWithoutAccountingEntryInput = {
    where: SalaryPaymentWhereUniqueInput
    create: XOR<SalaryPaymentCreateWithoutAccountingEntryInput, SalaryPaymentUncheckedCreateWithoutAccountingEntryInput>
  }

  export type FileCreateWithoutAccountingEntryInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    lesson?: LessonCreateNestedOneWithoutFilesInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutFilesInput
    meeting?: MeetingCreateNestedOneWithoutFilesInput
    adminRole?: AdminRoleCreateNestedOneWithoutFilesInput
    legalCase?: LegalCaseCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutAccountingEntryInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutAccountingEntryInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutAccountingEntryInput, FileUncheckedCreateWithoutAccountingEntryInput>
  }

  export type FileCreateManyAccountingEntryInputEnvelope = {
    data: FileCreateManyAccountingEntryInput | FileCreateManyAccountingEntryInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutAccountingEntryInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReportInput
    meeting?: MeetingCreateNestedOneWithoutReportsInput
    adminRole?: AdminRoleCreateNestedOneWithoutReportsInput
    legalCase?: LegalCaseCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutAccountingEntryInput = {
    id?: string
    userId: string
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutAccountingEntryInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutAccountingEntryInput, ReportUncheckedCreateWithoutAccountingEntryInput>
  }

  export type ReportCreateManyAccountingEntryInputEnvelope = {
    data: ReportCreateManyAccountingEntryInput | ReportCreateManyAccountingEntryInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutAccountingEntriesInput = {
    update: XOR<AdminUpdateWithoutAccountingEntriesInput, AdminUncheckedUpdateWithoutAccountingEntriesInput>
    create: XOR<AdminCreateWithoutAccountingEntriesInput, AdminUncheckedCreateWithoutAccountingEntriesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAccountingEntriesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAccountingEntriesInput, AdminUncheckedUpdateWithoutAccountingEntriesInput>
  }

  export type AdminUpdateWithoutAccountingEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    Group?: GroupUpdateManyWithoutAdminNestedInput
    prRecords?: PublicRelationsRecordUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutAccountingEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Group?: GroupUncheckedUpdateManyWithoutAdminNestedInput
    prRecords?: PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUncheckedUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUncheckedUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AcademyUpsertWithoutAccountingEntryInput = {
    update: XOR<AcademyUpdateWithoutAccountingEntryInput, AcademyUncheckedUpdateWithoutAccountingEntryInput>
    create: XOR<AcademyCreateWithoutAccountingEntryInput, AcademyUncheckedCreateWithoutAccountingEntryInput>
    where?: AcademyWhereInput
  }

  export type AcademyUpdateToOneWithWhereWithoutAccountingEntryInput = {
    where?: AcademyWhereInput
    data: XOR<AcademyUpdateWithoutAccountingEntryInput, AcademyUncheckedUpdateWithoutAccountingEntryInput>
  }

  export type AcademyUpdateWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUpdateManyWithoutAcademyNestedInput
    courses?: CourseUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUpdateManyWithoutAcademyNestedInput
    events?: EventUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyUncheckedUpdateWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUncheckedUpdateManyWithoutAcademyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutAcademyNestedInput
    events?: EventUncheckedUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutAcademyNestedInput
  }

  export type InvoiceUpsertWithoutAccountingEntryInput = {
    update: XOR<InvoiceUpdateWithoutAccountingEntryInput, InvoiceUncheckedUpdateWithoutAccountingEntryInput>
    create: XOR<InvoiceCreateWithoutAccountingEntryInput, InvoiceUncheckedCreateWithoutAccountingEntryInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutAccountingEntryInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutAccountingEntryInput, InvoiceUncheckedUpdateWithoutAccountingEntryInput>
  }

  export type InvoiceUpdateWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUpsertWithoutAccountingEntryInput = {
    update: XOR<SalaryPaymentUpdateWithoutAccountingEntryInput, SalaryPaymentUncheckedUpdateWithoutAccountingEntryInput>
    create: XOR<SalaryPaymentCreateWithoutAccountingEntryInput, SalaryPaymentUncheckedCreateWithoutAccountingEntryInput>
    where?: SalaryPaymentWhereInput
  }

  export type SalaryPaymentUpdateToOneWithWhereWithoutAccountingEntryInput = {
    where?: SalaryPaymentWhereInput
    data: XOR<SalaryPaymentUpdateWithoutAccountingEntryInput, SalaryPaymentUncheckedUpdateWithoutAccountingEntryInput>
  }

  export type SalaryPaymentUpdateWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutSalaryPaymentNestedInput
  }

  export type SalaryPaymentUncheckedUpdateWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpsertWithWhereUniqueWithoutAccountingEntryInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutAccountingEntryInput, FileUncheckedUpdateWithoutAccountingEntryInput>
    create: XOR<FileCreateWithoutAccountingEntryInput, FileUncheckedCreateWithoutAccountingEntryInput>
  }

  export type FileUpdateWithWhereUniqueWithoutAccountingEntryInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutAccountingEntryInput, FileUncheckedUpdateWithoutAccountingEntryInput>
  }

  export type FileUpdateManyWithWhereWithoutAccountingEntryInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutAccountingEntryInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutAccountingEntryInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutAccountingEntryInput, ReportUncheckedUpdateWithoutAccountingEntryInput>
    create: XOR<ReportCreateWithoutAccountingEntryInput, ReportUncheckedCreateWithoutAccountingEntryInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutAccountingEntryInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutAccountingEntryInput, ReportUncheckedUpdateWithoutAccountingEntryInput>
  }

  export type ReportUpdateManyWithWhereWithoutAccountingEntryInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutAccountingEntryInput>
  }

  export type AccountingEntryCreateWithoutInvoiceInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutAccountingEntriesInput
    academy: AcademyCreateNestedOneWithoutAccountingEntryInput
    salaryPayment?: SalaryPaymentCreateNestedOneWithoutAccountingEntryInput
    files?: FileCreateNestedManyWithoutAccountingEntryInput
    reports?: ReportCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryUncheckedCreateWithoutInvoiceInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    salaryPayment?: SalaryPaymentUncheckedCreateNestedOneWithoutAccountingEntryInput
    files?: FileUncheckedCreateNestedManyWithoutAccountingEntryInput
    reports?: ReportUncheckedCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryCreateOrConnectWithoutInvoiceInput = {
    where: AccountingEntryWhereUniqueInput
    create: XOR<AccountingEntryCreateWithoutInvoiceInput, AccountingEntryUncheckedCreateWithoutInvoiceInput>
  }

  export type AccountingEntryUpsertWithoutInvoiceInput = {
    update: XOR<AccountingEntryUpdateWithoutInvoiceInput, AccountingEntryUncheckedUpdateWithoutInvoiceInput>
    create: XOR<AccountingEntryCreateWithoutInvoiceInput, AccountingEntryUncheckedCreateWithoutInvoiceInput>
    where?: AccountingEntryWhereInput
  }

  export type AccountingEntryUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: AccountingEntryWhereInput
    data: XOR<AccountingEntryUpdateWithoutInvoiceInput, AccountingEntryUncheckedUpdateWithoutInvoiceInput>
  }

  export type AccountingEntryUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutAccountingEntriesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUpdateManyWithoutAccountingEntryNestedInput
    reports?: ReportUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AccountingEntryUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salaryPayment?: SalaryPaymentUncheckedUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUncheckedUpdateManyWithoutAccountingEntryNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAccountingEntryNestedInput
  }

  export type UserCreateWithoutSalaryPaymentInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutSalaryPaymentInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutSalaryPaymentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalaryPaymentInput, UserUncheckedCreateWithoutSalaryPaymentInput>
  }

  export type AccountingEntryCreateWithoutSalaryPaymentInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutAccountingEntriesInput
    academy: AcademyCreateNestedOneWithoutAccountingEntryInput
    invoice?: InvoiceCreateNestedOneWithoutAccountingEntryInput
    files?: FileCreateNestedManyWithoutAccountingEntryInput
    reports?: ReportCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryUncheckedCreateWithoutSalaryPaymentInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceUncheckedCreateNestedOneWithoutAccountingEntryInput
    files?: FileUncheckedCreateNestedManyWithoutAccountingEntryInput
    reports?: ReportUncheckedCreateNestedManyWithoutAccountingEntryInput
  }

  export type AccountingEntryCreateOrConnectWithoutSalaryPaymentInput = {
    where: AccountingEntryWhereUniqueInput
    create: XOR<AccountingEntryCreateWithoutSalaryPaymentInput, AccountingEntryUncheckedCreateWithoutSalaryPaymentInput>
  }

  export type UserUpsertWithoutSalaryPaymentInput = {
    update: XOR<UserUpdateWithoutSalaryPaymentInput, UserUncheckedUpdateWithoutSalaryPaymentInput>
    create: XOR<UserCreateWithoutSalaryPaymentInput, UserUncheckedCreateWithoutSalaryPaymentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalaryPaymentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalaryPaymentInput, UserUncheckedUpdateWithoutSalaryPaymentInput>
  }

  export type UserUpdateWithoutSalaryPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSalaryPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type AccountingEntryUpsertWithoutSalaryPaymentInput = {
    update: XOR<AccountingEntryUpdateWithoutSalaryPaymentInput, AccountingEntryUncheckedUpdateWithoutSalaryPaymentInput>
    create: XOR<AccountingEntryCreateWithoutSalaryPaymentInput, AccountingEntryUncheckedCreateWithoutSalaryPaymentInput>
    where?: AccountingEntryWhereInput
  }

  export type AccountingEntryUpdateToOneWithWhereWithoutSalaryPaymentInput = {
    where?: AccountingEntryWhereInput
    data: XOR<AccountingEntryUpdateWithoutSalaryPaymentInput, AccountingEntryUncheckedUpdateWithoutSalaryPaymentInput>
  }

  export type AccountingEntryUpdateWithoutSalaryPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutAccountingEntriesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutAccountingEntryNestedInput
    invoice?: InvoiceUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUpdateManyWithoutAccountingEntryNestedInput
    reports?: ReportUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AccountingEntryUncheckedUpdateWithoutSalaryPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUncheckedUpdateManyWithoutAccountingEntryNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AdminCreateWithoutPrRecordsInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
    Group?: GroupCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatedByAdminInput
    prResponses?: PRResponseCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutPrRecordsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    Group?: GroupUncheckedCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatedByAdminInput
    prResponses?: PRResponseUncheckedCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseUncheckedCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutPrRecordsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutPrRecordsInput, AdminUncheckedCreateWithoutPrRecordsInput>
  }

  export type AcademyCreateWithoutPublicRelationsRecordInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOCreateNestedManyWithoutAcademyInput
    courses?: CourseCreateNestedManyWithoutAcademyInput
    instructors?: InstructorCreateNestedManyWithoutAcademyInput
    events?: EventCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUncheckedCreateWithoutPublicRelationsRecordInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOUncheckedCreateNestedManyWithoutAcademyInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademyInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutAcademyInput
    events?: EventUncheckedCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryUncheckedCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutAcademyInput
  }

  export type AcademyCreateOrConnectWithoutPublicRelationsRecordInput = {
    where: AcademyWhereUniqueInput
    create: XOR<AcademyCreateWithoutPublicRelationsRecordInput, AcademyUncheckedCreateWithoutPublicRelationsRecordInput>
  }

  export type PRResponseCreateWithoutPrRecordInput = {
    id?: string
    response: string
    createdAt?: Date | string
    respondedByAdmin: AdminCreateNestedOneWithoutPrResponsesInput
  }

  export type PRResponseUncheckedCreateWithoutPrRecordInput = {
    id?: string
    response: string
    respondedByAdminId: string
    createdAt?: Date | string
  }

  export type PRResponseCreateOrConnectWithoutPrRecordInput = {
    where: PRResponseWhereUniqueInput
    create: XOR<PRResponseCreateWithoutPrRecordInput, PRResponseUncheckedCreateWithoutPrRecordInput>
  }

  export type PRResponseCreateManyPrRecordInputEnvelope = {
    data: PRResponseCreateManyPrRecordInput | PRResponseCreateManyPrRecordInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutPrRecordInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    academy: AcademyCreateNestedOneWithoutEventsInput
    adminRole?: AdminRoleCreateNestedOneWithoutEventsInput
    legalCase?: LegalCaseCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutPrRecordInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    academyId: string
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutPrRecordInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutPrRecordInput, EventUncheckedCreateWithoutPrRecordInput>
  }

  export type EventCreateManyPrRecordInputEnvelope = {
    data: EventCreateManyPrRecordInput | EventCreateManyPrRecordInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutPublicRelationsRecordInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    author: UserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    Group?: GroupCreateNestedManyWithoutPostsInput
    Community?: CommunityCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPublicRelationsRecordInput = {
    id?: string
    authorId: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    Group?: GroupUncheckedCreateNestedManyWithoutPostsInput
    Community?: CommunityUncheckedCreateNestedManyWithoutPostsInput
    Discussion?: DiscussionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPublicRelationsRecordInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPublicRelationsRecordInput, PostUncheckedCreateWithoutPublicRelationsRecordInput>
  }

  export type PostCreateManyPublicRelationsRecordInputEnvelope = {
    data: PostCreateManyPublicRelationsRecordInput | PostCreateManyPublicRelationsRecordInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutPrRecordInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    lesson?: LessonCreateNestedOneWithoutFilesInput
    accountingEntry?: AccountingEntryCreateNestedOneWithoutFilesInput
    meeting?: MeetingCreateNestedOneWithoutFilesInput
    adminRole?: AdminRoleCreateNestedOneWithoutFilesInput
    legalCase?: LegalCaseCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutPrRecordInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    accountingEntryId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutPrRecordInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutPrRecordInput, FileUncheckedCreateWithoutPrRecordInput>
  }

  export type FileCreateManyPrRecordInputEnvelope = {
    data: FileCreateManyPrRecordInput | FileCreateManyPrRecordInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCreateWithoutPrRecordInput = {
    id?: string
    name: string
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutChannelsInput
    owner: OwnerCreateNestedOneWithoutChannelInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    meeting?: MeetingCreateNestedOneWithoutChannelsInput
    adminRole?: AdminRoleCreateNestedOneWithoutChannelsInput
    legalCase?: LegalCaseCreateNestedOneWithoutChannelsInput
  }

  export type ChannelUncheckedCreateWithoutPrRecordInput = {
    id?: string
    name: string
    ownerId: string
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutChannelsInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutPrRecordInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutPrRecordInput, ChannelUncheckedCreateWithoutPrRecordInput>
  }

  export type ChannelCreateManyPrRecordInputEnvelope = {
    data: ChannelCreateManyPrRecordInput | ChannelCreateManyPrRecordInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutPrRecordsInput = {
    update: XOR<AdminUpdateWithoutPrRecordsInput, AdminUncheckedUpdateWithoutPrRecordsInput>
    create: XOR<AdminCreateWithoutPrRecordsInput, AdminUncheckedCreateWithoutPrRecordsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutPrRecordsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutPrRecordsInput, AdminUncheckedUpdateWithoutPrRecordsInput>
  }

  export type AdminUpdateWithoutPrRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    Group?: GroupUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatedByAdminNestedInput
    prResponses?: PRResponseUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutPrRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Group?: GroupUncheckedUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    prResponses?: PRResponseUncheckedUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUncheckedUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AcademyUpsertWithoutPublicRelationsRecordInput = {
    update: XOR<AcademyUpdateWithoutPublicRelationsRecordInput, AcademyUncheckedUpdateWithoutPublicRelationsRecordInput>
    create: XOR<AcademyCreateWithoutPublicRelationsRecordInput, AcademyUncheckedCreateWithoutPublicRelationsRecordInput>
    where?: AcademyWhereInput
  }

  export type AcademyUpdateToOneWithWhereWithoutPublicRelationsRecordInput = {
    where?: AcademyWhereInput
    data: XOR<AcademyUpdateWithoutPublicRelationsRecordInput, AcademyUncheckedUpdateWithoutPublicRelationsRecordInput>
  }

  export type AcademyUpdateWithoutPublicRelationsRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUpdateManyWithoutAcademyNestedInput
    courses?: CourseUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUpdateManyWithoutAcademyNestedInput
    events?: EventUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyUncheckedUpdateWithoutPublicRelationsRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUncheckedUpdateManyWithoutAcademyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutAcademyNestedInput
    events?: EventUncheckedUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUncheckedUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutAcademyNestedInput
  }

  export type PRResponseUpsertWithWhereUniqueWithoutPrRecordInput = {
    where: PRResponseWhereUniqueInput
    update: XOR<PRResponseUpdateWithoutPrRecordInput, PRResponseUncheckedUpdateWithoutPrRecordInput>
    create: XOR<PRResponseCreateWithoutPrRecordInput, PRResponseUncheckedCreateWithoutPrRecordInput>
  }

  export type PRResponseUpdateWithWhereUniqueWithoutPrRecordInput = {
    where: PRResponseWhereUniqueInput
    data: XOR<PRResponseUpdateWithoutPrRecordInput, PRResponseUncheckedUpdateWithoutPrRecordInput>
  }

  export type PRResponseUpdateManyWithWhereWithoutPrRecordInput = {
    where: PRResponseScalarWhereInput
    data: XOR<PRResponseUpdateManyMutationInput, PRResponseUncheckedUpdateManyWithoutPrRecordInput>
  }

  export type EventUpsertWithWhereUniqueWithoutPrRecordInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutPrRecordInput, EventUncheckedUpdateWithoutPrRecordInput>
    create: XOR<EventCreateWithoutPrRecordInput, EventUncheckedCreateWithoutPrRecordInput>
  }

  export type EventUpdateWithWhereUniqueWithoutPrRecordInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutPrRecordInput, EventUncheckedUpdateWithoutPrRecordInput>
  }

  export type EventUpdateManyWithWhereWithoutPrRecordInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutPrRecordInput>
  }

  export type PostUpsertWithWhereUniqueWithoutPublicRelationsRecordInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutPublicRelationsRecordInput, PostUncheckedUpdateWithoutPublicRelationsRecordInput>
    create: XOR<PostCreateWithoutPublicRelationsRecordInput, PostUncheckedCreateWithoutPublicRelationsRecordInput>
  }

  export type PostUpdateWithWhereUniqueWithoutPublicRelationsRecordInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutPublicRelationsRecordInput, PostUncheckedUpdateWithoutPublicRelationsRecordInput>
  }

  export type PostUpdateManyWithWhereWithoutPublicRelationsRecordInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPublicRelationsRecordInput>
  }

  export type FileUpsertWithWhereUniqueWithoutPrRecordInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutPrRecordInput, FileUncheckedUpdateWithoutPrRecordInput>
    create: XOR<FileCreateWithoutPrRecordInput, FileUncheckedCreateWithoutPrRecordInput>
  }

  export type FileUpdateWithWhereUniqueWithoutPrRecordInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutPrRecordInput, FileUncheckedUpdateWithoutPrRecordInput>
  }

  export type FileUpdateManyWithWhereWithoutPrRecordInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutPrRecordInput>
  }

  export type ChannelUpsertWithWhereUniqueWithoutPrRecordInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutPrRecordInput, ChannelUncheckedUpdateWithoutPrRecordInput>
    create: XOR<ChannelCreateWithoutPrRecordInput, ChannelUncheckedCreateWithoutPrRecordInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutPrRecordInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutPrRecordInput, ChannelUncheckedUpdateWithoutPrRecordInput>
  }

  export type ChannelUpdateManyWithWhereWithoutPrRecordInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutPrRecordInput>
  }

  export type PublicRelationsRecordCreateWithoutResponsesInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    handledByAdmin: AdminCreateNestedOneWithoutPrRecordsInput
    academy: AcademyCreateNestedOneWithoutPublicRelationsRecordInput
    events?: EventCreateNestedManyWithoutPrRecordInput
    posts?: PostCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileCreateNestedManyWithoutPrRecordInput
    channels?: ChannelCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordUncheckedCreateWithoutResponsesInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    handledByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutPrRecordInput
    posts?: PostUncheckedCreateNestedManyWithoutPublicRelationsRecordInput
    files?: FileUncheckedCreateNestedManyWithoutPrRecordInput
    channels?: ChannelUncheckedCreateNestedManyWithoutPrRecordInput
  }

  export type PublicRelationsRecordCreateOrConnectWithoutResponsesInput = {
    where: PublicRelationsRecordWhereUniqueInput
    create: XOR<PublicRelationsRecordCreateWithoutResponsesInput, PublicRelationsRecordUncheckedCreateWithoutResponsesInput>
  }

  export type AdminCreateWithoutPrResponsesInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
    Group?: GroupCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordCreateNestedManyWithoutHandledByAdminInput
    meetings?: MeetingCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutPrResponsesInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    Group?: GroupUncheckedCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordUncheckedCreateNestedManyWithoutHandledByAdminInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseUncheckedCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutPrResponsesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutPrResponsesInput, AdminUncheckedCreateWithoutPrResponsesInput>
  }

  export type PublicRelationsRecordUpsertWithoutResponsesInput = {
    update: XOR<PublicRelationsRecordUpdateWithoutResponsesInput, PublicRelationsRecordUncheckedUpdateWithoutResponsesInput>
    create: XOR<PublicRelationsRecordCreateWithoutResponsesInput, PublicRelationsRecordUncheckedCreateWithoutResponsesInput>
    where?: PublicRelationsRecordWhereInput
  }

  export type PublicRelationsRecordUpdateToOneWithWhereWithoutResponsesInput = {
    where?: PublicRelationsRecordWhereInput
    data: XOR<PublicRelationsRecordUpdateWithoutResponsesInput, PublicRelationsRecordUncheckedUpdateWithoutResponsesInput>
  }

  export type PublicRelationsRecordUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledByAdmin?: AdminUpdateOneRequiredWithoutPrRecordsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutPublicRelationsRecordNestedInput
    events?: EventUpdateManyWithoutPrRecordNestedInput
    posts?: PostUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    handledByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutPrRecordNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUncheckedUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutPrRecordNestedInput
  }

  export type AdminUpsertWithoutPrResponsesInput = {
    update: XOR<AdminUpdateWithoutPrResponsesInput, AdminUncheckedUpdateWithoutPrResponsesInput>
    create: XOR<AdminCreateWithoutPrResponsesInput, AdminUncheckedCreateWithoutPrResponsesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutPrResponsesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutPrResponsesInput, AdminUncheckedUpdateWithoutPrResponsesInput>
  }

  export type AdminUpdateWithoutPrResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    Group?: GroupUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUpdateManyWithoutHandledByAdminNestedInput
    meetings?: MeetingUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutPrResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Group?: GroupUncheckedUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUncheckedUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateWithoutMeetingsInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
    Group?: GroupCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseCreateNestedManyWithoutRespondedByAdminInput
    assignments?: AdminAssignmentCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutMeetingsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    Group?: GroupUncheckedCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordUncheckedCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseUncheckedCreateNestedManyWithoutRespondedByAdminInput
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseUncheckedCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutMeetingsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutMeetingsInput, AdminUncheckedCreateWithoutMeetingsInput>
  }

  export type AcademyCreateWithoutMeetingInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOCreateNestedManyWithoutAcademyInput
    courses?: CourseCreateNestedManyWithoutAcademyInput
    instructors?: InstructorCreateNestedManyWithoutAcademyInput
    events?: EventCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUncheckedCreateWithoutMeetingInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOUncheckedCreateNestedManyWithoutAcademyInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademyInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutAcademyInput
    events?: EventUncheckedCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryUncheckedCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedCreateNestedManyWithoutAcademyInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutAcademyInput
  }

  export type AcademyCreateOrConnectWithoutMeetingInput = {
    where: AcademyWhereUniqueInput
    create: XOR<AcademyCreateWithoutMeetingInput, AcademyUncheckedCreateWithoutMeetingInput>
  }

  export type MeetingParticipantCreateWithoutMeetingInput = {
    id?: string
    isAttended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMeetingParticipantInput
  }

  export type MeetingParticipantUncheckedCreateWithoutMeetingInput = {
    id?: string
    userId: string
    isAttended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingParticipantCreateOrConnectWithoutMeetingInput = {
    where: MeetingParticipantWhereUniqueInput
    create: XOR<MeetingParticipantCreateWithoutMeetingInput, MeetingParticipantUncheckedCreateWithoutMeetingInput>
  }

  export type MeetingParticipantCreateManyMeetingInputEnvelope = {
    data: MeetingParticipantCreateManyMeetingInput | MeetingParticipantCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutMeetingInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    lesson?: LessonCreateNestedOneWithoutFilesInput
    accountingEntry?: AccountingEntryCreateNestedOneWithoutFilesInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutFilesInput
    adminRole?: AdminRoleCreateNestedOneWithoutFilesInput
    legalCase?: LegalCaseCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutMeetingInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    accountingEntryId?: string | null
    prRecordId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutMeetingInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutMeetingInput, FileUncheckedCreateWithoutMeetingInput>
  }

  export type FileCreateManyMeetingInputEnvelope = {
    data: FileCreateManyMeetingInput | FileCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutMeetingInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReportInput
    accountingEntry?: AccountingEntryCreateNestedOneWithoutReportsInput
    adminRole?: AdminRoleCreateNestedOneWithoutReportsInput
    legalCase?: LegalCaseCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutMeetingInput = {
    id?: string
    userId: string
    accountingEntryId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutMeetingInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutMeetingInput, ReportUncheckedCreateWithoutMeetingInput>
  }

  export type ReportCreateManyMeetingInputEnvelope = {
    data: ReportCreateManyMeetingInput | ReportCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCreateWithoutMeetingInput = {
    id?: string
    name: string
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutChannelsInput
    owner: OwnerCreateNestedOneWithoutChannelInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutChannelsInput
    adminRole?: AdminRoleCreateNestedOneWithoutChannelsInput
    legalCase?: LegalCaseCreateNestedOneWithoutChannelsInput
  }

  export type ChannelUncheckedCreateWithoutMeetingInput = {
    id?: string
    name: string
    ownerId: string
    prRecordId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutChannelsInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutMeetingInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutMeetingInput, ChannelUncheckedCreateWithoutMeetingInput>
  }

  export type ChannelCreateManyMeetingInputEnvelope = {
    data: ChannelCreateManyMeetingInput | ChannelCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutMeetingsInput = {
    update: XOR<AdminUpdateWithoutMeetingsInput, AdminUncheckedUpdateWithoutMeetingsInput>
    create: XOR<AdminCreateWithoutMeetingsInput, AdminUncheckedCreateWithoutMeetingsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutMeetingsInput, AdminUncheckedUpdateWithoutMeetingsInput>
  }

  export type AdminUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    Group?: GroupUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUpdateManyWithoutRespondedByAdminNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Group?: GroupUncheckedUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUncheckedUpdateManyWithoutRespondedByAdminNestedInput
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUncheckedUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AcademyUpsertWithoutMeetingInput = {
    update: XOR<AcademyUpdateWithoutMeetingInput, AcademyUncheckedUpdateWithoutMeetingInput>
    create: XOR<AcademyCreateWithoutMeetingInput, AcademyUncheckedCreateWithoutMeetingInput>
    where?: AcademyWhereInput
  }

  export type AcademyUpdateToOneWithWhereWithoutMeetingInput = {
    where?: AcademyWhereInput
    data: XOR<AcademyUpdateWithoutMeetingInput, AcademyUncheckedUpdateWithoutMeetingInput>
  }

  export type AcademyUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUpdateManyWithoutAcademyNestedInput
    courses?: CourseUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUpdateManyWithoutAcademyNestedInput
    events?: EventUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUncheckedUpdateManyWithoutAcademyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutAcademyNestedInput
    events?: EventUncheckedUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUncheckedUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedUpdateManyWithoutAcademyNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutAcademyNestedInput
  }

  export type MeetingParticipantUpsertWithWhereUniqueWithoutMeetingInput = {
    where: MeetingParticipantWhereUniqueInput
    update: XOR<MeetingParticipantUpdateWithoutMeetingInput, MeetingParticipantUncheckedUpdateWithoutMeetingInput>
    create: XOR<MeetingParticipantCreateWithoutMeetingInput, MeetingParticipantUncheckedCreateWithoutMeetingInput>
  }

  export type MeetingParticipantUpdateWithWhereUniqueWithoutMeetingInput = {
    where: MeetingParticipantWhereUniqueInput
    data: XOR<MeetingParticipantUpdateWithoutMeetingInput, MeetingParticipantUncheckedUpdateWithoutMeetingInput>
  }

  export type MeetingParticipantUpdateManyWithWhereWithoutMeetingInput = {
    where: MeetingParticipantScalarWhereInput
    data: XOR<MeetingParticipantUpdateManyMutationInput, MeetingParticipantUncheckedUpdateManyWithoutMeetingInput>
  }

  export type FileUpsertWithWhereUniqueWithoutMeetingInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutMeetingInput, FileUncheckedUpdateWithoutMeetingInput>
    create: XOR<FileCreateWithoutMeetingInput, FileUncheckedCreateWithoutMeetingInput>
  }

  export type FileUpdateWithWhereUniqueWithoutMeetingInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutMeetingInput, FileUncheckedUpdateWithoutMeetingInput>
  }

  export type FileUpdateManyWithWhereWithoutMeetingInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutMeetingInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutMeetingInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutMeetingInput, ReportUncheckedUpdateWithoutMeetingInput>
    create: XOR<ReportCreateWithoutMeetingInput, ReportUncheckedCreateWithoutMeetingInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutMeetingInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutMeetingInput, ReportUncheckedUpdateWithoutMeetingInput>
  }

  export type ReportUpdateManyWithWhereWithoutMeetingInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutMeetingInput>
  }

  export type ChannelUpsertWithWhereUniqueWithoutMeetingInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutMeetingInput, ChannelUncheckedUpdateWithoutMeetingInput>
    create: XOR<ChannelCreateWithoutMeetingInput, ChannelUncheckedCreateWithoutMeetingInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutMeetingInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutMeetingInput, ChannelUncheckedUpdateWithoutMeetingInput>
  }

  export type ChannelUpdateManyWithWhereWithoutMeetingInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutMeetingInput>
  }

  export type MeetingCreateWithoutParticipantsInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByAdmin: AdminCreateNestedOneWithoutMeetingsInput
    academy: AcademyCreateNestedOneWithoutMeetingInput
    files?: FileCreateNestedManyWithoutMeetingInput
    reports?: ReportCreateNestedManyWithoutMeetingInput
    channels?: ChannelCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutParticipantsInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdByAdminId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: FileUncheckedCreateNestedManyWithoutMeetingInput
    reports?: ReportUncheckedCreateNestedManyWithoutMeetingInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutParticipantsInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutParticipantsInput, MeetingUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutMeetingParticipantInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    LegalCase?: LegalCaseCreateNestedManyWithoutRelatedUserInput
  }

  export type UserUncheckedCreateWithoutMeetingParticipantInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    LegalCase?: LegalCaseUncheckedCreateNestedManyWithoutRelatedUserInput
  }

  export type UserCreateOrConnectWithoutMeetingParticipantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMeetingParticipantInput, UserUncheckedCreateWithoutMeetingParticipantInput>
  }

  export type MeetingUpsertWithoutParticipantsInput = {
    update: XOR<MeetingUpdateWithoutParticipantsInput, MeetingUncheckedUpdateWithoutParticipantsInput>
    create: XOR<MeetingCreateWithoutParticipantsInput, MeetingUncheckedCreateWithoutParticipantsInput>
    where?: MeetingWhereInput
  }

  export type MeetingUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: MeetingWhereInput
    data: XOR<MeetingUpdateWithoutParticipantsInput, MeetingUncheckedUpdateWithoutParticipantsInput>
  }

  export type MeetingUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutMeetingsNestedInput
    academy?: AcademyUpdateOneRequiredWithoutMeetingNestedInput
    files?: FileUpdateManyWithoutMeetingNestedInput
    reports?: ReportUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutMeetingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type UserUpsertWithoutMeetingParticipantInput = {
    update: XOR<UserUpdateWithoutMeetingParticipantInput, UserUncheckedUpdateWithoutMeetingParticipantInput>
    create: XOR<UserCreateWithoutMeetingParticipantInput, UserUncheckedCreateWithoutMeetingParticipantInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMeetingParticipantInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMeetingParticipantInput, UserUncheckedUpdateWithoutMeetingParticipantInput>
  }

  export type UserUpdateWithoutMeetingParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMeetingParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type AdminRoleCreateWithoutPermissionsInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutAdminRoleInput
    assignments?: AdminAssignmentCreateNestedManyWithoutRoleInput
    reports?: ReportCreateNestedManyWithoutAdminRoleInput
    files?: FileCreateNestedManyWithoutAdminRoleInput
    events?: EventCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutRoleInput
    reports?: ReportUncheckedCreateNestedManyWithoutAdminRoleInput
    files?: FileUncheckedCreateNestedManyWithoutAdminRoleInput
    events?: EventUncheckedCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelUncheckedCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleCreateOrConnectWithoutPermissionsInput = {
    where: AdminRoleWhereUniqueInput
    create: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput>
  }

  export type AdminRoleUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: AdminRoleWhereUniqueInput
    update: XOR<AdminRoleUpdateWithoutPermissionsInput, AdminRoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<AdminRoleCreateWithoutPermissionsInput, AdminRoleUncheckedCreateWithoutPermissionsInput>
  }

  export type AdminRoleUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: AdminRoleWhereUniqueInput
    data: XOR<AdminRoleUpdateWithoutPermissionsInput, AdminRoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type AdminRoleUpdateManyWithWhereWithoutPermissionsInput = {
    where: AdminRoleScalarWhereInput
    data: XOR<AdminRoleUpdateManyMutationInput, AdminRoleUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type AdminCreateWithoutAdminRoleInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
    Group?: GroupCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseCreateNestedManyWithoutAssignedLawyerInput
  }

  export type AdminUncheckedCreateWithoutAdminRoleInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    Group?: GroupUncheckedCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordUncheckedCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseUncheckedCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutAdminInput
    legalCases?: LegalCaseUncheckedCreateNestedManyWithoutAssignedLawyerInput
  }

  export type AdminCreateOrConnectWithoutAdminRoleInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAdminRoleInput, AdminUncheckedCreateWithoutAdminRoleInput>
  }

  export type AdminAssignmentCreateWithoutRoleInput = {
    id?: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutAssignmentsInput
  }

  export type AdminAssignmentUncheckedCreateWithoutRoleInput = {
    id?: string
    adminId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminAssignmentCreateOrConnectWithoutRoleInput = {
    where: AdminAssignmentWhereUniqueInput
    create: XOR<AdminAssignmentCreateWithoutRoleInput, AdminAssignmentUncheckedCreateWithoutRoleInput>
  }

  export type AdminAssignmentCreateManyRoleInputEnvelope = {
    data: AdminAssignmentCreateManyRoleInput | AdminAssignmentCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type PermissionCreateWithoutAdminRoleInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutAdminRoleInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutAdminRoleInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutAdminRoleInput, PermissionUncheckedCreateWithoutAdminRoleInput>
  }

  export type ReportCreateWithoutAdminRoleInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReportInput
    accountingEntry?: AccountingEntryCreateNestedOneWithoutReportsInput
    meeting?: MeetingCreateNestedOneWithoutReportsInput
    legalCase?: LegalCaseCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutAdminRoleInput = {
    id?: string
    userId: string
    accountingEntryId?: string | null
    meetingId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutAdminRoleInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutAdminRoleInput, ReportUncheckedCreateWithoutAdminRoleInput>
  }

  export type ReportCreateManyAdminRoleInputEnvelope = {
    data: ReportCreateManyAdminRoleInput | ReportCreateManyAdminRoleInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutAdminRoleInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    lesson?: LessonCreateNestedOneWithoutFilesInput
    accountingEntry?: AccountingEntryCreateNestedOneWithoutFilesInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutFilesInput
    meeting?: MeetingCreateNestedOneWithoutFilesInput
    legalCase?: LegalCaseCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutAdminRoleInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    accountingEntryId?: string | null
    prRecordId?: string | null
    meetingId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutAdminRoleInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutAdminRoleInput, FileUncheckedCreateWithoutAdminRoleInput>
  }

  export type FileCreateManyAdminRoleInputEnvelope = {
    data: FileCreateManyAdminRoleInput | FileCreateManyAdminRoleInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutAdminRoleInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    academy: AcademyCreateNestedOneWithoutEventsInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutEventsInput
    legalCase?: LegalCaseCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutAdminRoleInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    academyId: string
    prRecordId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutAdminRoleInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutAdminRoleInput, EventUncheckedCreateWithoutAdminRoleInput>
  }

  export type EventCreateManyAdminRoleInputEnvelope = {
    data: EventCreateManyAdminRoleInput | EventCreateManyAdminRoleInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCreateWithoutAdminRoleInput = {
    id?: string
    name: string
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutChannelsInput
    owner: OwnerCreateNestedOneWithoutChannelInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutChannelsInput
    meeting?: MeetingCreateNestedOneWithoutChannelsInput
    legalCase?: LegalCaseCreateNestedOneWithoutChannelsInput
  }

  export type ChannelUncheckedCreateWithoutAdminRoleInput = {
    id?: string
    name: string
    ownerId: string
    prRecordId?: string | null
    meetingId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutChannelsInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutAdminRoleInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutAdminRoleInput, ChannelUncheckedCreateWithoutAdminRoleInput>
  }

  export type ChannelCreateManyAdminRoleInputEnvelope = {
    data: ChannelCreateManyAdminRoleInput | ChannelCreateManyAdminRoleInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutAdminRoleInput = {
    update: XOR<AdminUpdateWithoutAdminRoleInput, AdminUncheckedUpdateWithoutAdminRoleInput>
    create: XOR<AdminCreateWithoutAdminRoleInput, AdminUncheckedCreateWithoutAdminRoleInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAdminRoleInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAdminRoleInput, AdminUncheckedUpdateWithoutAdminRoleInput>
  }

  export type AdminUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    Group?: GroupUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUpdateManyWithoutAssignedLawyerNestedInput
  }

  export type AdminUncheckedUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Group?: GroupUncheckedUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUncheckedUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUncheckedUpdateManyWithoutAssignedLawyerNestedInput
  }

  export type AdminAssignmentUpsertWithWhereUniqueWithoutRoleInput = {
    where: AdminAssignmentWhereUniqueInput
    update: XOR<AdminAssignmentUpdateWithoutRoleInput, AdminAssignmentUncheckedUpdateWithoutRoleInput>
    create: XOR<AdminAssignmentCreateWithoutRoleInput, AdminAssignmentUncheckedCreateWithoutRoleInput>
  }

  export type AdminAssignmentUpdateWithWhereUniqueWithoutRoleInput = {
    where: AdminAssignmentWhereUniqueInput
    data: XOR<AdminAssignmentUpdateWithoutRoleInput, AdminAssignmentUncheckedUpdateWithoutRoleInput>
  }

  export type AdminAssignmentUpdateManyWithWhereWithoutRoleInput = {
    where: AdminAssignmentScalarWhereInput
    data: XOR<AdminAssignmentUpdateManyMutationInput, AdminAssignmentUncheckedUpdateManyWithoutRoleInput>
  }

  export type PermissionUpsertWithWhereUniqueWithoutAdminRoleInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutAdminRoleInput, PermissionUncheckedUpdateWithoutAdminRoleInput>
    create: XOR<PermissionCreateWithoutAdminRoleInput, PermissionUncheckedCreateWithoutAdminRoleInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutAdminRoleInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutAdminRoleInput, PermissionUncheckedUpdateWithoutAdminRoleInput>
  }

  export type PermissionUpdateManyWithWhereWithoutAdminRoleInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutAdminRoleInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    id?: StringFilter<"Permission"> | string
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    isActive?: BoolFilter<"Permission"> | boolean
    createdAt?: DateTimeFilter<"Permission"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutAdminRoleInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutAdminRoleInput, ReportUncheckedUpdateWithoutAdminRoleInput>
    create: XOR<ReportCreateWithoutAdminRoleInput, ReportUncheckedCreateWithoutAdminRoleInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutAdminRoleInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutAdminRoleInput, ReportUncheckedUpdateWithoutAdminRoleInput>
  }

  export type ReportUpdateManyWithWhereWithoutAdminRoleInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutAdminRoleInput>
  }

  export type FileUpsertWithWhereUniqueWithoutAdminRoleInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutAdminRoleInput, FileUncheckedUpdateWithoutAdminRoleInput>
    create: XOR<FileCreateWithoutAdminRoleInput, FileUncheckedCreateWithoutAdminRoleInput>
  }

  export type FileUpdateWithWhereUniqueWithoutAdminRoleInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutAdminRoleInput, FileUncheckedUpdateWithoutAdminRoleInput>
  }

  export type FileUpdateManyWithWhereWithoutAdminRoleInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutAdminRoleInput>
  }

  export type EventUpsertWithWhereUniqueWithoutAdminRoleInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutAdminRoleInput, EventUncheckedUpdateWithoutAdminRoleInput>
    create: XOR<EventCreateWithoutAdminRoleInput, EventUncheckedCreateWithoutAdminRoleInput>
  }

  export type EventUpdateWithWhereUniqueWithoutAdminRoleInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutAdminRoleInput, EventUncheckedUpdateWithoutAdminRoleInput>
  }

  export type EventUpdateManyWithWhereWithoutAdminRoleInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutAdminRoleInput>
  }

  export type ChannelUpsertWithWhereUniqueWithoutAdminRoleInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutAdminRoleInput, ChannelUncheckedUpdateWithoutAdminRoleInput>
    create: XOR<ChannelCreateWithoutAdminRoleInput, ChannelUncheckedCreateWithoutAdminRoleInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutAdminRoleInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutAdminRoleInput, ChannelUncheckedUpdateWithoutAdminRoleInput>
  }

  export type ChannelUpdateManyWithWhereWithoutAdminRoleInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutAdminRoleInput>
  }

  export type AdminCreateWithoutAssignmentsInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
    Group?: GroupCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingCreateNestedManyWithoutCreatedByAdminInput
    legalCases?: LegalCaseCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    Group?: GroupUncheckedCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordUncheckedCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseUncheckedCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutCreatedByAdminInput
    legalCases?: LegalCaseUncheckedCreateNestedManyWithoutAssignedLawyerInput
    AdminRole?: AdminRoleUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutAssignmentsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutAssignmentsInput, AdminUncheckedCreateWithoutAssignmentsInput>
  }

  export type AdminRoleCreateWithoutAssignmentsInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutAdminRoleInput
    permissions?: PermissionCreateNestedManyWithoutAdminRoleInput
    reports?: ReportCreateNestedManyWithoutAdminRoleInput
    files?: FileCreateNestedManyWithoutAdminRoleInput
    events?: EventCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    adminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: PermissionUncheckedCreateNestedManyWithoutAdminRoleInput
    reports?: ReportUncheckedCreateNestedManyWithoutAdminRoleInput
    files?: FileUncheckedCreateNestedManyWithoutAdminRoleInput
    events?: EventUncheckedCreateNestedManyWithoutAdminRoleInput
    channels?: ChannelUncheckedCreateNestedManyWithoutAdminRoleInput
  }

  export type AdminRoleCreateOrConnectWithoutAssignmentsInput = {
    where: AdminRoleWhereUniqueInput
    create: XOR<AdminRoleCreateWithoutAssignmentsInput, AdminRoleUncheckedCreateWithoutAssignmentsInput>
  }

  export type AdminUpsertWithoutAssignmentsInput = {
    update: XOR<AdminUpdateWithoutAssignmentsInput, AdminUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<AdminCreateWithoutAssignmentsInput, AdminUncheckedCreateWithoutAssignmentsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutAssignmentsInput, AdminUncheckedUpdateWithoutAssignmentsInput>
  }

  export type AdminUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    Group?: GroupUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUpdateManyWithoutCreatedByAdminNestedInput
    legalCases?: LegalCaseUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Group?: GroupUncheckedUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUncheckedUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    legalCases?: LegalCaseUncheckedUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminRoleUpsertWithoutAssignmentsInput = {
    update: XOR<AdminRoleUpdateWithoutAssignmentsInput, AdminRoleUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<AdminRoleCreateWithoutAssignmentsInput, AdminRoleUncheckedCreateWithoutAssignmentsInput>
    where?: AdminRoleWhereInput
  }

  export type AdminRoleUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: AdminRoleWhereInput
    data: XOR<AdminRoleUpdateWithoutAssignmentsInput, AdminRoleUncheckedUpdateWithoutAssignmentsInput>
  }

  export type AdminRoleUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutAdminRoleNestedInput
    permissions?: PermissionUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUpdateManyWithoutAdminRoleNestedInput
    files?: FileUpdateManyWithoutAdminRoleNestedInput
    events?: EventUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: PermissionUncheckedUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAdminRoleNestedInput
    files?: FileUncheckedUpdateManyWithoutAdminRoleNestedInput
    events?: EventUncheckedUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminCreateWithoutLegalCasesInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
    Group?: GroupCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentCreateNestedManyWithoutAdminInput
    AdminRole?: AdminRoleCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutLegalCasesInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    Group?: GroupUncheckedCreateNestedManyWithoutAdminInput
    accountingEntries?: AccountingEntryUncheckedCreateNestedManyWithoutCreatedByAdminInput
    prRecords?: PublicRelationsRecordUncheckedCreateNestedManyWithoutHandledByAdminInput
    prResponses?: PRResponseUncheckedCreateNestedManyWithoutRespondedByAdminInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutCreatedByAdminInput
    assignments?: AdminAssignmentUncheckedCreateNestedManyWithoutAdminInput
    AdminRole?: AdminRoleUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutLegalCasesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutLegalCasesInput, AdminUncheckedCreateWithoutLegalCasesInput>
  }

  export type AcademyCreateWithoutLegalCaseInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOCreateNestedManyWithoutAcademyInput
    courses?: CourseCreateNestedManyWithoutAcademyInput
    instructors?: InstructorCreateNestedManyWithoutAcademyInput
    events?: EventCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingCreateNestedManyWithoutAcademyInput
  }

  export type AcademyUncheckedCreateWithoutLegalCaseInput = {
    id?: string
    name: string
    description?: string | null
    logo?: string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutAcademyInput
    ceos?: UserAcademyCEOUncheckedCreateNestedManyWithoutAcademyInput
    courses?: CourseUncheckedCreateNestedManyWithoutAcademyInput
    instructors?: InstructorUncheckedCreateNestedManyWithoutAcademyInput
    events?: EventUncheckedCreateNestedManyWithoutAcademyInput
    AccountingEntry?: AccountingEntryUncheckedCreateNestedManyWithoutAcademyInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedCreateNestedManyWithoutAcademyInput
    Meeting?: MeetingUncheckedCreateNestedManyWithoutAcademyInput
  }

  export type AcademyCreateOrConnectWithoutLegalCaseInput = {
    where: AcademyWhereUniqueInput
    create: XOR<AcademyCreateWithoutLegalCaseInput, AcademyUncheckedCreateWithoutLegalCaseInput>
  }

  export type UserCreateWithoutLegalCaseInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    academy?: AcademyCreateNestedOneWithoutUsersInput
    profile?: ProfileCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    groups?: GroupCreateNestedManyWithoutMembersInput
    channels?: ChannelCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    Submission?: SubmissionCreateNestedManyWithoutUserInput
    Attendance?: AttendanceCreateNestedManyWithoutStudentInput
    Instructor?: InstructorCreateNestedManyWithoutUserInput
    Owner?: OwnerCreateNestedManyWithoutUserInput
    Admin?: AdminCreateNestedManyWithoutUserInput
    Lesson?: LessonCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentCreateNestedManyWithoutUserInput
    Report?: ReportCreateNestedManyWithoutUserInput
    Badge?: BadgeCreateNestedManyWithoutUserInput
    Certificate?: CertificateCreateNestedManyWithoutUserInput
    Community?: CommunityCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsCreateNestedManyWithoutUserInput
    Path?: PathCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLegalCaseInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    academyId?: string | null
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    groups?: GroupUncheckedCreateNestedManyWithoutMembersInput
    channels?: ChannelUncheckedCreateNestedManyWithoutMembersInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    Submission?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    Attendance?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
    Instructor?: InstructorUncheckedCreateNestedManyWithoutUserInput
    Owner?: OwnerUncheckedCreateNestedManyWithoutUserInput
    Admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutCompletedByInput
    Payment?: PaymentUncheckedCreateNestedManyWithoutUserInput
    Report?: ReportUncheckedCreateNestedManyWithoutUserInput
    Badge?: BadgeUncheckedCreateNestedManyWithoutUserInput
    Certificate?: CertificateUncheckedCreateNestedManyWithoutUserInput
    Community?: CommunityUncheckedCreateNestedManyWithoutParticipantsInput
    LiveRoom?: LiveRoomUncheckedCreateNestedManyWithoutUserInput
    NotificationSettings?: NotificationSettingsUncheckedCreateNestedManyWithoutUserInput
    Path?: PathUncheckedCreateNestedManyWithoutPeersInput
    LoginHistory?: LoginHistoryUncheckedCreateNestedManyWithoutUserInput
    TwoFactor?: TwoFactorUncheckedCreateNestedManyWithoutUserInput
    UserAcademyCEO?: UserAcademyCEOUncheckedCreateNestedManyWithoutUserInput
    SalaryPayment?: SalaryPaymentUncheckedCreateNestedManyWithoutEmployeeInput
    MeetingParticipant?: MeetingParticipantUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLegalCaseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLegalCaseInput, UserUncheckedCreateWithoutLegalCaseInput>
  }

  export type FileCreateWithoutLegalCaseInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    createdAt?: Date | string
    lesson?: LessonCreateNestedOneWithoutFilesInput
    accountingEntry?: AccountingEntryCreateNestedOneWithoutFilesInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutFilesInput
    meeting?: MeetingCreateNestedOneWithoutFilesInput
    adminRole?: AdminRoleCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateWithoutLegalCaseInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    accountingEntryId?: string | null
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    createdAt?: Date | string
  }

  export type FileCreateOrConnectWithoutLegalCaseInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutLegalCaseInput, FileUncheckedCreateWithoutLegalCaseInput>
  }

  export type FileCreateManyLegalCaseInputEnvelope = {
    data: FileCreateManyLegalCaseInput | FileCreateManyLegalCaseInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutLegalCaseInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReportInput
    accountingEntry?: AccountingEntryCreateNestedOneWithoutReportsInput
    meeting?: MeetingCreateNestedOneWithoutReportsInput
    adminRole?: AdminRoleCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutLegalCaseInput = {
    id?: string
    userId: string
    accountingEntryId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutLegalCaseInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutLegalCaseInput, ReportUncheckedCreateWithoutLegalCaseInput>
  }

  export type ReportCreateManyLegalCaseInputEnvelope = {
    data: ReportCreateManyLegalCaseInput | ReportCreateManyLegalCaseInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutLegalCaseInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    academy: AcademyCreateNestedOneWithoutEventsInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutEventsInput
    adminRole?: AdminRoleCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutLegalCaseInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    academyId: string
    prRecordId?: string | null
    adminRoleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutLegalCaseInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutLegalCaseInput, EventUncheckedCreateWithoutLegalCaseInput>
  }

  export type EventCreateManyLegalCaseInputEnvelope = {
    data: EventCreateManyLegalCaseInput | EventCreateManyLegalCaseInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCreateWithoutLegalCaseInput = {
    id?: string
    name: string
    createdAt?: Date | string
    members?: UserCreateNestedManyWithoutChannelsInput
    owner: OwnerCreateNestedOneWithoutChannelInput
    messages?: MessageCreateNestedManyWithoutChannelInput
    prRecord?: PublicRelationsRecordCreateNestedOneWithoutChannelsInput
    meeting?: MeetingCreateNestedOneWithoutChannelsInput
    adminRole?: AdminRoleCreateNestedOneWithoutChannelsInput
  }

  export type ChannelUncheckedCreateWithoutLegalCaseInput = {
    id?: string
    name: string
    ownerId: string
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    createdAt?: Date | string
    members?: UserUncheckedCreateNestedManyWithoutChannelsInput
    messages?: MessageUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelCreateOrConnectWithoutLegalCaseInput = {
    where: ChannelWhereUniqueInput
    create: XOR<ChannelCreateWithoutLegalCaseInput, ChannelUncheckedCreateWithoutLegalCaseInput>
  }

  export type ChannelCreateManyLegalCaseInputEnvelope = {
    data: ChannelCreateManyLegalCaseInput | ChannelCreateManyLegalCaseInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutLegalCaseInput = {
    id?: string
    amount: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutLegalCaseInput = {
    id?: string
    userId: string
    amount: number
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutLegalCaseInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutLegalCaseInput, PaymentUncheckedCreateWithoutLegalCaseInput>
  }

  export type PaymentCreateManyLegalCaseInputEnvelope = {
    data: PaymentCreateManyLegalCaseInput | PaymentCreateManyLegalCaseInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutLegalCasesInput = {
    update: XOR<AdminUpdateWithoutLegalCasesInput, AdminUncheckedUpdateWithoutLegalCasesInput>
    create: XOR<AdminCreateWithoutLegalCasesInput, AdminUncheckedCreateWithoutLegalCasesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutLegalCasesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutLegalCasesInput, AdminUncheckedUpdateWithoutLegalCasesInput>
  }

  export type AdminUpdateWithoutLegalCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
    Group?: GroupUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutAdminNestedInput
    AdminRole?: AdminRoleUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutLegalCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Group?: GroupUncheckedUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUncheckedUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutAdminNestedInput
    AdminRole?: AdminRoleUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AcademyUpsertWithoutLegalCaseInput = {
    update: XOR<AcademyUpdateWithoutLegalCaseInput, AcademyUncheckedUpdateWithoutLegalCaseInput>
    create: XOR<AcademyCreateWithoutLegalCaseInput, AcademyUncheckedCreateWithoutLegalCaseInput>
    where?: AcademyWhereInput
  }

  export type AcademyUpdateToOneWithWhereWithoutLegalCaseInput = {
    where?: AcademyWhereInput
    data: XOR<AcademyUpdateWithoutLegalCaseInput, AcademyUncheckedUpdateWithoutLegalCaseInput>
  }

  export type AcademyUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUpdateManyWithoutAcademyNestedInput
    courses?: CourseUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUpdateManyWithoutAcademyNestedInput
    events?: EventUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUpdateManyWithoutAcademyNestedInput
  }

  export type AcademyUncheckedUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutAcademyNestedInput
    ceos?: UserAcademyCEOUncheckedUpdateManyWithoutAcademyNestedInput
    courses?: CourseUncheckedUpdateManyWithoutAcademyNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutAcademyNestedInput
    events?: EventUncheckedUpdateManyWithoutAcademyNestedInput
    AccountingEntry?: AccountingEntryUncheckedUpdateManyWithoutAcademyNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUncheckedUpdateManyWithoutAcademyNestedInput
    Meeting?: MeetingUncheckedUpdateManyWithoutAcademyNestedInput
  }

  export type UserUpsertWithoutLegalCaseInput = {
    update: XOR<UserUpdateWithoutLegalCaseInput, UserUncheckedUpdateWithoutLegalCaseInput>
    create: XOR<UserCreateWithoutLegalCaseInput, UserUncheckedCreateWithoutLegalCaseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLegalCaseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLegalCaseInput, UserUncheckedUpdateWithoutLegalCaseInput>
  }

  export type UserUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FileUpsertWithWhereUniqueWithoutLegalCaseInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutLegalCaseInput, FileUncheckedUpdateWithoutLegalCaseInput>
    create: XOR<FileCreateWithoutLegalCaseInput, FileUncheckedCreateWithoutLegalCaseInput>
  }

  export type FileUpdateWithWhereUniqueWithoutLegalCaseInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutLegalCaseInput, FileUncheckedUpdateWithoutLegalCaseInput>
  }

  export type FileUpdateManyWithWhereWithoutLegalCaseInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutLegalCaseInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutLegalCaseInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutLegalCaseInput, ReportUncheckedUpdateWithoutLegalCaseInput>
    create: XOR<ReportCreateWithoutLegalCaseInput, ReportUncheckedCreateWithoutLegalCaseInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutLegalCaseInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutLegalCaseInput, ReportUncheckedUpdateWithoutLegalCaseInput>
  }

  export type ReportUpdateManyWithWhereWithoutLegalCaseInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutLegalCaseInput>
  }

  export type EventUpsertWithWhereUniqueWithoutLegalCaseInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutLegalCaseInput, EventUncheckedUpdateWithoutLegalCaseInput>
    create: XOR<EventCreateWithoutLegalCaseInput, EventUncheckedCreateWithoutLegalCaseInput>
  }

  export type EventUpdateWithWhereUniqueWithoutLegalCaseInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutLegalCaseInput, EventUncheckedUpdateWithoutLegalCaseInput>
  }

  export type EventUpdateManyWithWhereWithoutLegalCaseInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutLegalCaseInput>
  }

  export type ChannelUpsertWithWhereUniqueWithoutLegalCaseInput = {
    where: ChannelWhereUniqueInput
    update: XOR<ChannelUpdateWithoutLegalCaseInput, ChannelUncheckedUpdateWithoutLegalCaseInput>
    create: XOR<ChannelCreateWithoutLegalCaseInput, ChannelUncheckedCreateWithoutLegalCaseInput>
  }

  export type ChannelUpdateWithWhereUniqueWithoutLegalCaseInput = {
    where: ChannelWhereUniqueInput
    data: XOR<ChannelUpdateWithoutLegalCaseInput, ChannelUncheckedUpdateWithoutLegalCaseInput>
  }

  export type ChannelUpdateManyWithWhereWithoutLegalCaseInput = {
    where: ChannelScalarWhereInput
    data: XOR<ChannelUpdateManyMutationInput, ChannelUncheckedUpdateManyWithoutLegalCaseInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutLegalCaseInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutLegalCaseInput, PaymentUncheckedUpdateWithoutLegalCaseInput>
    create: XOR<PaymentCreateWithoutLegalCaseInput, PaymentUncheckedCreateWithoutLegalCaseInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutLegalCaseInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutLegalCaseInput, PaymentUncheckedUpdateWithoutLegalCaseInput>
  }

  export type PaymentUpdateManyWithWhereWithoutLegalCaseInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutLegalCaseInput>
  }

  export type EnrollmentCreateManyUserInput = {
    id?: string
    courseId: string
    progress?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateManyUserInput = {
    id?: string
    type: string
    value: JsonNullValueInput | InputJsonValue
    isNew?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type?: $Enums.NotificationType
    message: string
    isImportant?: boolean
    urgent?: boolean
    title: string
    actionUrl?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    content: string
    createdAt?: Date | string
    isRead?: boolean
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
    publicRelationsRecordId?: string | null
  }

  export type BookmarkCreateManyUserInput = {
    id?: string
    type: string
    itemId: string
    createdAt?: Date | string
  }

  export type SubmissionCreateManyUserInput = {
    id?: string
    quizId: string
    answers?: SubmissionCreateanswersInput | InputJsonValue[]
    score?: number | null
    feedback?: string | null
    passed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyStudentInput = {
    id?: string
    lessonId: string
    status: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstructorCreateManyUserInput = {
    id?: string
    academyId: string
  }

  export type OwnerCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
  }

  export type AdminCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    amount: number
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateManyUserInput = {
    id?: string
    accountingEntryId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type BadgeCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
  }

  export type CertificateCreateManyUserInput = {
    id?: string
    name: string
    address: string
    phone: string
    notes: string
    title: string
    description?: string | null
    url?: string | null
    image?: string | null
    points: number
    type: string
    earnedAt: Date | string
    createdAt?: Date | string
  }

  export type NotificationSettingsCreateManyUserInput = {
    id?: string
    assignments?: boolean
    grades?: boolean
    messages?: boolean
    achievements?: boolean
    urgent?: boolean
    email?: boolean
    push?: boolean
    createdAt?: Date | string
  }

  export type LoginHistoryCreateManyUserInput = {
    id?: string
    success?: boolean
    ip?: string | null
    device?: $Enums.LoginDevice | null
    location?: string | null
    browser?: string | null
    os?: string | null
    createdAt?: Date | string
  }

  export type TwoFactorCreateManyUserInput = {
    id?: string
    email?: boolean
    sms?: boolean
    authenticator?: boolean
    secret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAcademyCEOCreateManyUserInput = {
    id?: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryPaymentCreateManyEmployeeInput = {
    id?: string
    amount: number
    month: number
    year: number
    accountingEntryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingParticipantCreateManyUserInput = {
    id?: string
    meetingId: string
    isAttended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LegalCaseCreateManyRelatedUserInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isNew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isNew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    isNew?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    message?: StringFieldUpdateOperationsInput | string
    isImportant?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    Channel?: ChannelUpdateManyWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    Channel?: ChannelUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutPostNestedInput
    Group?: GroupUpdateManyWithoutPostsNestedInput
    Community?: CommunityUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUpdateManyWithoutPostNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    publicRelationsRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Group?: GroupUncheckedUpdateManyWithoutPostsNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    publicRelationsRecordId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutGroupNestedInput
    admin?: AdminUpdateOneRequiredWithoutGroupNestedInput
    Community?: CommunityUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutGroupNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: OwnerUpdateOneRequiredWithoutChannelNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutChannelsNestedInput
    meeting?: MeetingUpdateOneWithoutChannelsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutChannelsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: SubmissionUpdateanswersInput | InputJsonValue[]
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    answers?: SubmissionUpdateanswersInput | InputJsonValue[]
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    answers?: SubmissionUpdateanswersInput | InputJsonValue[]
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    academy?: AcademyUpdateOneRequiredWithoutInstructorsNestedInput
    courses?: CourseUpdateManyWithoutInstructorsNestedInput
  }

  export type InstructorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    courses?: CourseUncheckedUpdateManyWithoutInstructorsNestedInput
  }

  export type InstructorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
  }

  export type OwnerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Channel?: ChannelUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Channel?: ChannelUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type OwnerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Group?: GroupUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Group?: GroupUncheckedUpdateManyWithoutAdminNestedInput
    accountingEntries?: AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    prRecords?: PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminNestedInput
    prResponses?: PRResponseUncheckedUpdateManyWithoutRespondedByAdminNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutCreatedByAdminNestedInput
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutAdminNestedInput
    legalCases?: LegalCaseUncheckedUpdateManyWithoutAssignedLawyerNestedInput
    AdminRole?: AdminRoleUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUpdateWithoutCompletedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutLessonsNestedInput
    files?: FileUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    Attendance?: AttendanceUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutCompletedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutCompletedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    legalCase?: LegalCaseUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingEntry?: AccountingEntryUpdateOneWithoutReportsNestedInput
    meeting?: MeetingUpdateOneWithoutReportsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutReportsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUpdateManyWithoutCommunityNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCommunityNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
    discussions?: DiscussionUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUncheckedUpdateManyWithoutCommunityNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCommunityNestedInput
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    discussions?: DiscussionUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateManyWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveRoomUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutLiveRoomNestedInput
    course?: CourseUpdateOneWithoutLiveRoomNestedInput
  }

  export type LiveRoomUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LiveRoomUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityId?: StringFieldUpdateOperationsInput | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignments?: BoolFieldUpdateOperationsInput | boolean
    grades?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    achievements?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    push?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignments?: BoolFieldUpdateOperationsInput | boolean
    grades?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    achievements?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    push?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignments?: BoolFieldUpdateOperationsInput | boolean
    grades?: BoolFieldUpdateOperationsInput | boolean
    messages?: BoolFieldUpdateOperationsInput | boolean
    achievements?: BoolFieldUpdateOperationsInput | boolean
    urgent?: BoolFieldUpdateOperationsInput | boolean
    email?: BoolFieldUpdateOperationsInput | boolean
    push?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PathUpdateWithoutPeersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUpdateManyWithoutPathNestedInput
    courses?: CourseUpdateManyWithoutPathNestedInput
  }

  export type PathUncheckedUpdateWithoutPeersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUncheckedUpdateManyWithoutPathNestedInput
    courses?: CourseUncheckedUpdateManyWithoutPathNestedInput
  }

  export type PathUncheckedUpdateManyWithoutPeersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableEnumLoginDeviceFieldUpdateOperationsInput | $Enums.LoginDevice | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableEnumLoginDeviceFieldUpdateOperationsInput | $Enums.LoginDevice | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableEnumLoginDeviceFieldUpdateOperationsInput | $Enums.LoginDevice | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: BoolFieldUpdateOperationsInput | boolean
    sms?: BoolFieldUpdateOperationsInput | boolean
    authenticator?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: BoolFieldUpdateOperationsInput | boolean
    sms?: BoolFieldUpdateOperationsInput | boolean
    authenticator?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwoFactorUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: BoolFieldUpdateOperationsInput | boolean
    sms?: BoolFieldUpdateOperationsInput | boolean
    authenticator?: BoolFieldUpdateOperationsInput | boolean
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAcademyCEOUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academy?: AcademyUpdateOneRequiredWithoutCeosNestedInput
  }

  export type UserAcademyCEOUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAcademyCEOUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingEntry?: AccountingEntryUpdateOneRequiredWithoutSalaryPaymentNestedInput
  }

  export type SalaryPaymentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    accountingEntryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryPaymentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    accountingEntryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAttended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type MeetingParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    isAttended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    isAttended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalCaseUpdateWithoutRelatedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedLawyer?: AdminUpdateOneRequiredWithoutLegalCasesNestedInput
    academy?: AcademyUpdateOneRequiredWithoutLegalCaseNestedInput
    files?: FileUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUpdateManyWithoutLegalCaseNestedInput
    events?: EventUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateWithoutRelatedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLegalCaseNestedInput
    events?: EventUncheckedUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateManyWithoutRelatedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyAcademyInput = {
    id?: string
    email: string
    password: string
    phone?: string | null
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    subRole?: string | null
    avatar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isOnline?: boolean
    isVerified?: boolean
    age?: number | null
  }

  export type UserAcademyCEOCreateManyAcademyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreateManyAcademyInput = {
    id?: string
    title: string
    description: string
    image?: string | null
    level: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.CourseStatus
  }

  export type InstructorCreateManyAcademyInput = {
    id?: string
    userId: string
  }

  export type EventCreateManyAcademyInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    prRecordId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountingEntryCreateManyAcademyInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicRelationsRecordCreateManyAcademyInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    handledByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingCreateManyAcademyInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    createdByAdminId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LegalCaseCreateManyAcademyInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    assignedLawyerId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserAcademyCEOUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserAcademyCEONestedInput
  }

  export type UserAcademyCEOUncheckedUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAcademyCEOUncheckedUpdateManyWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCourseNestedInput
    Path?: PathUpdateManyWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCourseNestedInput
    Path?: PathUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
  }

  export type InstructorUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInstructorNestedInput
    courses?: CourseUpdateManyWithoutInstructorsNestedInput
  }

  export type InstructorUncheckedUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courses?: CourseUncheckedUpdateManyWithoutInstructorsNestedInput
  }

  export type InstructorUncheckedUpdateManyWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EventUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prRecord?: PublicRelationsRecordUpdateOneWithoutEventsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutEventsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountingEntryUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutAccountingEntriesNestedInput
    invoice?: InvoiceUpdateOneWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUpdateManyWithoutAccountingEntryNestedInput
    reports?: ReportUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AccountingEntryUncheckedUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUncheckedUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUncheckedUpdateManyWithoutAccountingEntryNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AccountingEntryUncheckedUpdateManyWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicRelationsRecordUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledByAdmin?: AdminUpdateOneRequiredWithoutPrRecordsNestedInput
    responses?: PRResponseUpdateManyWithoutPrRecordNestedInput
    events?: EventUpdateManyWithoutPrRecordNestedInput
    posts?: PostUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordUncheckedUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    handledByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PRResponseUncheckedUpdateManyWithoutPrRecordNestedInput
    events?: EventUncheckedUpdateManyWithoutPrRecordNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUncheckedUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordUncheckedUpdateManyWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    handledByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByAdmin?: AdminUpdateOneRequiredWithoutMeetingsNestedInput
    participants?: MeetingParticipantUpdateManyWithoutMeetingNestedInput
    files?: FileUpdateManyWithoutMeetingNestedInput
    reports?: ReportUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MeetingParticipantUncheckedUpdateManyWithoutMeetingNestedInput
    files?: FileUncheckedUpdateManyWithoutMeetingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateManyWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalCaseUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedLawyer?: AdminUpdateOneRequiredWithoutLegalCasesNestedInput
    relatedUser?: UserUpdateOneWithoutLegalCaseNestedInput
    files?: FileUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUpdateManyWithoutLegalCaseNestedInput
    events?: EventUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLegalCaseNestedInput
    events?: EventUncheckedUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateManyWithoutAcademyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedLawyerId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutInstructorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    academy?: AcademyUpdateOneRequiredWithoutCoursesNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCourseNestedInput
    Path?: PathUpdateManyWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutInstructorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCourseNestedInput
    Path?: PathUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutInstructorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
  }

  export type LessonCreateManyCourseInput = {
    id?: string
    title: string
    content: string
    status?: $Enums.LessonStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EnrollmentCreateManyCourseInput = {
    id?: string
    userId: string
    progress?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LiveRoomCreateManyCourseInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    communityId: string
  }

  export type LessonUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUpdateManyWithoutLessonNestedInput
    completedBy?: UserUpdateManyWithoutLessonNestedInput
    Attendance?: AttendanceUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLessonNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutLessonNestedInput
    completedBy?: UserUncheckedUpdateManyWithoutLessonNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutQuizzesNestedInput
    questions?: QuestionUpdateManyWithoutQuizNestedInput
    submissions?: SubmissionUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: StringFieldUpdateOperationsInput | string
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutQuizNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lessonId?: StringFieldUpdateOperationsInput | string
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutInstructorNestedInput
    academy?: AcademyUpdateOneRequiredWithoutInstructorsNestedInput
  }

  export type InstructorUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
  }

  export type InstructorUncheckedUpdateManyWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
  }

  export type LiveRoomUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutLiveRoomNestedInput
    User?: UserUpdateManyWithoutLiveRoomNestedInput
  }

  export type LiveRoomUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityId?: StringFieldUpdateOperationsInput | string
    User?: UserUncheckedUpdateManyWithoutLiveRoomNestedInput
  }

  export type LiveRoomUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communityId?: StringFieldUpdateOperationsInput | string
  }

  export type PathUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUpdateManyWithoutPathNestedInput
    peers?: UserUpdateManyWithoutPathNestedInput
  }

  export type PathUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUncheckedUpdateManyWithoutPathNestedInput
    peers?: UserUncheckedUpdateManyWithoutPathNestedInput
  }

  export type PathUncheckedUpdateManyWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    completedTasks?: IntFieldUpdateOperationsInput | number
    remainingTime?: IntFieldUpdateOperationsInput | number
    studyTime?: IntFieldUpdateOperationsInput | number
    totalTasks?: IntFieldUpdateOperationsInput | number
    progress?: FloatFieldUpdateOperationsInput | number
    engagement?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateManyPathInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.MilestoneStatus
    createdAt?: Date | string
  }

  export type MilestoneUpdateWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMilestoneStatusFieldUpdateOperationsInput | $Enums.MilestoneStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    academy?: AcademyUpdateOneRequiredWithoutCoursesNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
  }

  export type UserUpdateWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutPathInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FileCreateManyLessonInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    accountingEntryId?: string | null
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type QuizCreateManyLessonInput = {
    id?: string
    title: string
    description?: string | null
    timeLimit?: number | null
    passingScore?: number | null
    upComing?: boolean
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyLessonInput = {
    id?: string
    studentId: string
    status: string
    method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountingEntry?: AccountingEntryUpdateOneWithoutFilesNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutFilesNestedInput
    meeting?: MeetingUpdateOneWithoutFilesNestedInput
    adminRole?: AdminRoleUpdateOneWithoutFilesNestedInput
    legalCase?: LegalCaseUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutQuizNestedInput
    submissions?: SubmissionUpdateManyWithoutQuizNestedInput
    Course?: CourseUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutQuizNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutQuizNestedInput
    Course?: CourseUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    upComing?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttendanceUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateManyQuizInput = {
    id?: string
    text: string
    type: string
    isMultiple?: boolean
    points: number
    isAnswered?: boolean
    createdAt?: Date | string
  }

  export type SubmissionCreateManyQuizInput = {
    id?: string
    userId: string
    answers?: SubmissionCreateanswersInput | InputJsonValue[]
    score?: number | null
    feedback?: string | null
    passed?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    isAnswered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OptionUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    isAnswered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: OptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    isAnswered?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    answers?: SubmissionUpdateanswersInput | InputJsonValue[]
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubmissionNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: SubmissionUpdateanswersInput | InputJsonValue[]
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answers?: SubmissionUpdateanswersInput | InputJsonValue[]
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    academy?: AcademyUpdateOneRequiredWithoutCoursesNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCourseNestedInput
    Path?: PathUpdateManyWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    instructors?: InstructorUncheckedUpdateManyWithoutCoursesNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCourseNestedInput
    Path?: PathUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    academyId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCourseStatusFieldUpdateOperationsInput | $Enums.CourseStatus
  }

  export type OptionCreateManyQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OptionUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptionUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutChannelsNestedInput
    owner?: OwnerUpdateOneRequiredWithoutChannelNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutChannelsNestedInput
    meeting?: MeetingUpdateOneWithoutChannelsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutChannelsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    content: string
    createdAt?: Date | string
  }

  export type DiscussionCreateManyPostInput = {
    id?: string
    communityId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutGroupsNestedInput
    admin?: AdminUpdateOneRequiredWithoutGroupNestedInput
    Community?: CommunityUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutGroupsNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUpdateManyWithoutCommunityNestedInput
    liveRoom?: LiveRoomUpdateManyWithoutCommunityNestedInput
    participants?: UserUpdateManyWithoutCommunityNestedInput
    discussions?: DiscussionUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groups?: GroupUncheckedUpdateManyWithoutCommunityNestedInput
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCommunityNestedInput
    participants?: UserUncheckedUpdateManyWithoutCommunityNestedInput
    discussions?: DiscussionUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutDiscussionsNestedInput
  }

  export type DiscussionUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PostUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    Community?: CommunityUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUpdateManyWithoutPostNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    publicRelationsRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    publicRelationsRecordId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunityUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    liveRoom?: LiveRoomUpdateManyWithoutCommunityNestedInput
    participants?: UserUpdateManyWithoutCommunityNestedInput
    posts?: PostUpdateManyWithoutCommunityNestedInput
    discussions?: DiscussionUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    liveRoom?: LiveRoomUncheckedUpdateManyWithoutCommunityNestedInput
    participants?: UserUncheckedUpdateManyWithoutCommunityNestedInput
    posts?: PostUncheckedUpdateManyWithoutCommunityNestedInput
    discussions?: DiscussionUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateManyWithoutGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupCreateManyAdminInput = {
    id?: string
    name: string
    subject: string
    image?: string | null
    createdAt?: Date | string
  }

  export type AccountingEntryCreateManyCreatedByAdminInput = {
    id?: string
    type: $Enums.AccountingType
    amount: number
    description: string
    date: Date | string
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicRelationsRecordCreateManyHandledByAdminInput = {
    id?: string
    message: string
    senderName: string
    senderContact: string
    status?: $Enums.PRRequestStatus
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PRResponseCreateManyRespondedByAdminInput = {
    id?: string
    response: string
    prRecordId: string
    createdAt?: Date | string
  }

  export type MeetingCreateManyCreatedByAdminInput = {
    id?: string
    meetingTitle: string
    meetingDate: Date | string
    location: string
    notes?: string | null
    academyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminAssignmentCreateManyAdminInput = {
    id?: string
    roleId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LegalCaseCreateManyAssignedLawyerInput = {
    id?: string
    caseTitle: string
    caseType: $Enums.LegalCaseType
    status?: $Enums.LegalCaseStatus
    description: string
    courtDate?: Date | string | null
    academyId: string
    relatedUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminRoleCreateManyAdminInput = {
    id?: string
    name: $Enums.AdminRoleType
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutGroupsNestedInput
    posts?: PostUpdateManyWithoutGroupNestedInput
    Community?: CommunityUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutGroupsNestedInput
    posts?: PostUncheckedUpdateManyWithoutGroupNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountingEntryUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academy?: AcademyUpdateOneRequiredWithoutAccountingEntryNestedInput
    invoice?: InvoiceUpdateOneWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUpdateManyWithoutAccountingEntryNestedInput
    reports?: ReportUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AccountingEntryUncheckedUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUncheckedUpdateOneWithoutAccountingEntryNestedInput
    salaryPayment?: SalaryPaymentUncheckedUpdateOneWithoutAccountingEntryNestedInput
    files?: FileUncheckedUpdateManyWithoutAccountingEntryNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAccountingEntryNestedInput
  }

  export type AccountingEntryUncheckedUpdateManyWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAccountingTypeFieldUpdateOperationsInput | $Enums.AccountingType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicRelationsRecordUpdateWithoutHandledByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academy?: AcademyUpdateOneRequiredWithoutPublicRelationsRecordNestedInput
    responses?: PRResponseUpdateManyWithoutPrRecordNestedInput
    events?: EventUpdateManyWithoutPrRecordNestedInput
    posts?: PostUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordUncheckedUpdateWithoutHandledByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: PRResponseUncheckedUpdateManyWithoutPrRecordNestedInput
    events?: EventUncheckedUpdateManyWithoutPrRecordNestedInput
    posts?: PostUncheckedUpdateManyWithoutPublicRelationsRecordNestedInput
    files?: FileUncheckedUpdateManyWithoutPrRecordNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutPrRecordNestedInput
  }

  export type PublicRelationsRecordUncheckedUpdateManyWithoutHandledByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderContact?: StringFieldUpdateOperationsInput | string
    status?: EnumPRRequestStatusFieldUpdateOperationsInput | $Enums.PRRequestStatus
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PRResponseUpdateWithoutRespondedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prRecord?: PublicRelationsRecordUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type PRResponseUncheckedUpdateWithoutRespondedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    prRecordId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PRResponseUncheckedUpdateManyWithoutRespondedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    prRecordId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academy?: AcademyUpdateOneRequiredWithoutMeetingNestedInput
    participants?: MeetingParticipantUpdateManyWithoutMeetingNestedInput
    files?: FileUpdateManyWithoutMeetingNestedInput
    reports?: ReportUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MeetingParticipantUncheckedUpdateManyWithoutMeetingNestedInput
    files?: FileUncheckedUpdateManyWithoutMeetingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutMeetingNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateManyWithoutCreatedByAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingTitle?: StringFieldUpdateOperationsInput | string
    meetingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    academyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAssignmentUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: AdminRoleUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AdminAssignmentUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAssignmentUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegalCaseUpdateWithoutAssignedLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academy?: AcademyUpdateOneRequiredWithoutLegalCaseNestedInput
    relatedUser?: UserUpdateOneWithoutLegalCaseNestedInput
    files?: FileUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUpdateManyWithoutLegalCaseNestedInput
    events?: EventUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateWithoutAssignedLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academyId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: FileUncheckedUpdateManyWithoutLegalCaseNestedInput
    reports?: ReportUncheckedUpdateManyWithoutLegalCaseNestedInput
    events?: EventUncheckedUpdateManyWithoutLegalCaseNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutLegalCaseNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLegalCaseNestedInput
  }

  export type LegalCaseUncheckedUpdateManyWithoutAssignedLawyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTitle?: StringFieldUpdateOperationsInput | string
    caseType?: EnumLegalCaseTypeFieldUpdateOperationsInput | $Enums.LegalCaseType
    status?: EnumLegalCaseStatusFieldUpdateOperationsInput | $Enums.LegalCaseStatus
    description?: StringFieldUpdateOperationsInput | string
    courtDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    academyId?: StringFieldUpdateOperationsInput | string
    relatedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AdminAssignmentUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUpdateManyWithoutAdminRoleNestedInput
    files?: FileUpdateManyWithoutAdminRoleNestedInput
    events?: EventUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutAdminRoleNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAdminRoleNestedInput
    files?: FileUncheckedUpdateManyWithoutAdminRoleNestedInput
    events?: EventUncheckedUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MessageUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChannelCreateManyOwnerInput = {
    id?: string
    name: string
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ChannelUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutChannelsNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutChannelsNestedInput
    meeting?: MeetingUpdateOneWithoutChannelsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutChannelsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutChannelsNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveRoomCreateManyCommunityInput = {
    id?: string
    title: string
    topic?: string | null
    participants?: number
    isLive?: boolean
    isActive?: boolean
    isPublic?: boolean
    isPrivate?: boolean
    isPasswordProtected?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    courseId?: string | null
  }

  export type DiscussionCreateManyCommunityInput = {
    id?: string
    postId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutGroupsNestedInput
    posts?: PostUpdateManyWithoutGroupNestedInput
    admin?: AdminUpdateOneRequiredWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutGroupsNestedInput
    posts?: PostUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type GroupUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LiveRoomUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateManyWithoutLiveRoomNestedInput
    course?: CourseUpdateOneWithoutLiveRoomNestedInput
  }

  export type LiveRoomUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUncheckedUpdateManyWithoutLiveRoomNestedInput
  }

  export type LiveRoomUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: IntFieldUpdateOperationsInput | number
    isLive?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    isPasswordProtected?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    LiveRoom?: LiveRoomUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    LiveRoom?: LiveRoomUncheckedUpdateManyWithoutUserNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PostUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    Group?: GroupUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUpdateManyWithoutPostNestedInput
    PublicRelationsRecord?: PublicRelationsRecordUpdateOneWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    publicRelationsRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Group?: GroupUncheckedUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    publicRelationsRecordId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DiscussionUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneWithoutDiscussionNestedInput
  }

  export type DiscussionUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscussionUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutLiveRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    academy?: AcademyUpdateOneWithoutUsersNestedInput
    profile?: ProfileUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    groups?: GroupUpdateManyWithoutMembersNestedInput
    channels?: ChannelUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUpdateManyWithoutUserNestedInput
    Owner?: OwnerUpdateManyWithoutUserNestedInput
    Admin?: AdminUpdateManyWithoutUserNestedInput
    Lesson?: LessonUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUpdateManyWithoutUserNestedInput
    Report?: ReportUpdateManyWithoutUserNestedInput
    Badge?: BadgeUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUpdateManyWithoutUserNestedInput
    Community?: CommunityUpdateManyWithoutParticipantsNestedInput
    NotificationSettings?: NotificationSettingsUpdateManyWithoutUserNestedInput
    Path?: PathUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLiveRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    groups?: GroupUncheckedUpdateManyWithoutMembersNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutMembersNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    Submission?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    Attendance?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
    Instructor?: InstructorUncheckedUpdateManyWithoutUserNestedInput
    Owner?: OwnerUncheckedUpdateManyWithoutUserNestedInput
    Admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutCompletedByNestedInput
    Payment?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    Report?: ReportUncheckedUpdateManyWithoutUserNestedInput
    Badge?: BadgeUncheckedUpdateManyWithoutUserNestedInput
    Certificate?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutParticipantsNestedInput
    NotificationSettings?: NotificationSettingsUncheckedUpdateManyWithoutUserNestedInput
    Path?: PathUncheckedUpdateManyWithoutPeersNestedInput
    LoginHistory?: LoginHistoryUncheckedUpdateManyWithoutUserNestedInput
    TwoFactor?: TwoFactorUncheckedUpdateManyWithoutUserNestedInput
    UserAcademyCEO?: UserAcademyCEOUncheckedUpdateManyWithoutUserNestedInput
    SalaryPayment?: SalaryPaymentUncheckedUpdateManyWithoutEmployeeNestedInput
    MeetingParticipant?: MeetingParticipantUncheckedUpdateManyWithoutUserNestedInput
    LegalCase?: LegalCaseUncheckedUpdateManyWithoutRelatedUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLiveRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    subRole?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    age?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FileCreateManyAccountingEntryInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateManyAccountingEntryInput = {
    id?: string
    userId: string
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type FileUpdateWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneWithoutFilesNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutFilesNestedInput
    meeting?: MeetingUpdateOneWithoutFilesNestedInput
    adminRole?: AdminRoleUpdateOneWithoutFilesNestedInput
    legalCase?: LegalCaseUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportNestedInput
    meeting?: MeetingUpdateOneWithoutReportsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutReportsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutAccountingEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PRResponseCreateManyPrRecordInput = {
    id?: string
    response: string
    respondedByAdminId: string
    createdAt?: Date | string
  }

  export type EventCreateManyPrRecordInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    academyId: string
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateManyPublicRelationsRecordInput = {
    id?: string
    authorId: string
    content: string
    title: string
    createdAt?: Date | string
    likesCount?: number
  }

  export type FileCreateManyPrRecordInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    accountingEntryId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ChannelCreateManyPrRecordInput = {
    id?: string
    name: string
    ownerId: string
    meetingId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type PRResponseUpdateWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedByAdmin?: AdminUpdateOneRequiredWithoutPrResponsesNestedInput
  }

  export type PRResponseUncheckedUpdateWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    respondedByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PRResponseUncheckedUpdateManyWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    response?: StringFieldUpdateOperationsInput | string
    respondedByAdminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academy?: AcademyUpdateOneRequiredWithoutEventsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutEventsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: StringFieldUpdateOperationsInput | string
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: StringFieldUpdateOperationsInput | string
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutPublicRelationsRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    Group?: GroupUpdateManyWithoutPostsNestedInput
    Community?: CommunityUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPublicRelationsRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Group?: GroupUncheckedUpdateManyWithoutPostsNestedInput
    Community?: CommunityUncheckedUpdateManyWithoutPostsNestedInput
    Discussion?: DiscussionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutPublicRelationsRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likesCount?: IntFieldUpdateOperationsInput | number
  }

  export type FileUpdateWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneWithoutFilesNestedInput
    accountingEntry?: AccountingEntryUpdateOneWithoutFilesNestedInput
    meeting?: MeetingUpdateOneWithoutFilesNestedInput
    adminRole?: AdminRoleUpdateOneWithoutFilesNestedInput
    legalCase?: LegalCaseUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutChannelsNestedInput
    owner?: OwnerUpdateOneRequiredWithoutChannelNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    meeting?: MeetingUpdateOneWithoutChannelsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutChannelsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutChannelsNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutPrRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingParticipantCreateManyMeetingInput = {
    id?: string
    userId: string
    isAttended?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateManyMeetingInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    accountingEntryId?: string | null
    prRecordId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateManyMeetingInput = {
    id?: string
    userId: string
    accountingEntryId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type ChannelCreateManyMeetingInput = {
    id?: string
    name: string
    ownerId: string
    prRecordId?: string | null
    adminRoleId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type MeetingParticipantUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    isAttended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMeetingParticipantNestedInput
  }

  export type MeetingParticipantUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isAttended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingParticipantUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isAttended?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneWithoutFilesNestedInput
    accountingEntry?: AccountingEntryUpdateOneWithoutFilesNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutFilesNestedInput
    adminRole?: AdminRoleUpdateOneWithoutFilesNestedInput
    legalCase?: LegalCaseUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportNestedInput
    accountingEntry?: AccountingEntryUpdateOneWithoutReportsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutReportsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutChannelsNestedInput
    owner?: OwnerUpdateOneRequiredWithoutChannelNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutChannelsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutChannelsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutChannelsNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminRoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutAdminRoleNestedInput
    assignments?: AdminAssignmentUpdateManyWithoutRoleNestedInput
    reports?: ReportUpdateManyWithoutAdminRoleNestedInput
    files?: FileUpdateManyWithoutAdminRoleNestedInput
    events?: EventUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AdminAssignmentUncheckedUpdateManyWithoutRoleNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAdminRoleNestedInput
    files?: FileUncheckedUpdateManyWithoutAdminRoleNestedInput
    events?: EventUncheckedUpdateManyWithoutAdminRoleNestedInput
    channels?: ChannelUncheckedUpdateManyWithoutAdminRoleNestedInput
  }

  export type AdminRoleUncheckedUpdateManyWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumAdminRoleTypeFieldUpdateOperationsInput | $Enums.AdminRoleType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    adminId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAssignmentCreateManyRoleInput = {
    id?: string
    adminId: string
    startDate: Date | string
    endDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyAdminRoleInput = {
    id?: string
    userId: string
    accountingEntryId?: string | null
    meetingId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type FileCreateManyAdminRoleInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    accountingEntryId?: string | null
    prRecordId?: string | null
    meetingId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type EventCreateManyAdminRoleInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    academyId: string
    prRecordId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateManyAdminRoleInput = {
    id?: string
    name: string
    ownerId: string
    prRecordId?: string | null
    meetingId?: string | null
    legalCaseId?: string | null
    createdAt?: Date | string
  }

  export type AdminAssignmentUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AdminAssignmentUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAssignmentUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportNestedInput
    accountingEntry?: AccountingEntryUpdateOneWithoutReportsNestedInput
    meeting?: MeetingUpdateOneWithoutReportsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneWithoutFilesNestedInput
    accountingEntry?: AccountingEntryUpdateOneWithoutFilesNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutFilesNestedInput
    meeting?: MeetingUpdateOneWithoutFilesNestedInput
    legalCase?: LegalCaseUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academy?: AcademyUpdateOneRequiredWithoutEventsNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutEventsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutChannelsNestedInput
    owner?: OwnerUpdateOneRequiredWithoutChannelNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutChannelsNestedInput
    meeting?: MeetingUpdateOneWithoutChannelsNestedInput
    legalCase?: LegalCaseUpdateOneWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutChannelsNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutAdminRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    legalCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateManyLegalCaseInput = {
    id?: string
    name: string
    url: string
    type: $Enums.FileType
    lessonId?: string | null
    accountingEntryId?: string | null
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateManyLegalCaseInput = {
    id?: string
    userId: string
    accountingEntryId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    createdAt?: Date | string
  }

  export type EventCreateManyLegalCaseInput = {
    id?: string
    title: string
    description?: string | null
    startTime: Date | string
    endTime: Date | string
    academyId: string
    prRecordId?: string | null
    adminRoleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChannelCreateManyLegalCaseInput = {
    id?: string
    name: string
    ownerId: string
    prRecordId?: string | null
    meetingId?: string | null
    adminRoleId?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateManyLegalCaseInput = {
    id?: string
    userId: string
    amount: number
    createdAt?: Date | string
  }

  export type FileUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneWithoutFilesNestedInput
    accountingEntry?: AccountingEntryUpdateOneWithoutFilesNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutFilesNestedInput
    meeting?: MeetingUpdateOneWithoutFilesNestedInput
    adminRole?: AdminRoleUpdateOneWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: NullableStringFieldUpdateOperationsInput | string | null
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReportNestedInput
    accountingEntry?: AccountingEntryUpdateOneWithoutReportsNestedInput
    meeting?: MeetingUpdateOneWithoutReportsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountingEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academy?: AcademyUpdateOneRequiredWithoutEventsNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutEventsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    academyId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUpdateManyWithoutChannelsNestedInput
    owner?: OwnerUpdateOneRequiredWithoutChannelNestedInput
    messages?: MessageUpdateManyWithoutChannelNestedInput
    prRecord?: PublicRelationsRecordUpdateOneWithoutChannelsNestedInput
    meeting?: MeetingUpdateOneWithoutChannelsNestedInput
    adminRole?: AdminRoleUpdateOneWithoutChannelsNestedInput
  }

  export type ChannelUncheckedUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: UserUncheckedUpdateManyWithoutChannelsNestedInput
    messages?: MessageUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelUncheckedUpdateManyWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    prRecordId?: NullableStringFieldUpdateOperationsInput | string | null
    meetingId?: NullableStringFieldUpdateOperationsInput | string | null
    adminRoleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutLegalCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}